\section{Critical systems}

In critical applications, precision and rigor are essential. 
One way to achieve this is through formal techniques, which rely on mathematical models of the system being designed.

By using formal models, we can (at least in principle) verify system properties with a high degree of confidence. 
In many cases, this verification can be automated, reducing the risk of human error.

\subsection{Formal verification}
When developing a critical system, we define:
\begin{itemize}
    \item Specification ($S$): a high-level formal model of the system.
    \item Requirement ($R$): a property we want the system to satisfy.
\end{itemize}
\noindent Requirements are typically divided into two main categories:
\begin{enumerate}
    \item \textit{Functional requirements}: define expected input/output behaviors.
    \item \textit{Non-functional requirements}: covers aspects such as ordering constraints, metric constraints, probabilistic guarantees, and real-time probabilistic constraints
\end{enumerate}
\noindent Once we have formalized $R$ and $S$, we aim to verify that $R$ holds given $S$. 
This is denoted as: 
\[R\models S\]
Which means that property $R$ holds for specification $S$. 
The ultimate goal of formal verification is to determine whether this statement is true or false.

\subsection{Model checking}
\begin{definition}[\textit{Model checking}]
    Model checking is an automated technique that, given a finite-state model of a system and a formal property, systematically checks whether this property holds in the model.
\end{definition}
In model checking, the system is typically represented as a finite-state automaton or a similar formal model. 
The properties to be verified are expressed in temporal logic, which allows reasoning about sequences of events over time. 
The fundamental idea is to explore all possible system states to determine whether the given property holds.

If verification succeeds, it provides strong assurance that the system behaves as expected. 
However, if the verification fails, the model checker generates a counterexample, which serves as a concrete illustration of a scenario where the property does not hold. 
This counterexample is invaluable for debugging and refining the system.

\paragraph*{Advantages}
One of the greatest advantages of model checking is its high degree of automation. 
Once the system model and properties are specified, the verification process becomes essentially a push-button task.

\paragraph*{Drawbacks}
A major issue is state space explosion, where the number of possible states grows exponentially with system complexity, making verification computationally expensive. 
Additionally, certain complex system behaviors may be difficult to express within the formalism, limiting the technique's applicability in some cases.