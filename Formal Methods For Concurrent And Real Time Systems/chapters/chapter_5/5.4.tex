\section{Verification}

The Region Transition System can be leveraged to verify the reachability of specific locations in a Timed Automaton.
\begin{theorem}
    Determining whether a location is reachable in a Timed Automaton is \\ PSPACE-complete.
\end{theorem}
\noindent The complexity arises from the exponential growth of the region Transition System, which depends on both the number of clocks and the binary representation of the constants used for clock comparisons.

Since bisimulation equivalence implies Computation Tree Logic equivalence (even for systems with aninfinite number of states).
This ensures that the verification results remain consistent.

However, Computation Tree Logic has limitations when expressing precise timing constraints, as it lacks a metric for time. 
Despite this, it remains a valuable tool for verification in many cases.

\subsection{Timed Computation Tree Logic}
Timed Computation Tree Logic extends Computation Tree Logic by introducing a metric until operator that allows reasoning about time constraints.

\subsubsection{Syntax}
Timed Computation Tree Logic state formulas follow the usual Computation Tree Logic structure but incorporate atomic clock constraints g (typically defined over the set of clocks in a Timed Automaton):
\[\Phi:==\text{true}\mid a \mid g \mid \Phi \land \Phi \mid \lnot\phi \mid E\phi\mid \forall\phi\]
\noindent Here, $a\in\text{AP}$ is the set of atomic propositions, and $g\in\text{acc}(C)$ are atomic clock constraints over the set of clocks $C$ in a Timed Automaton. 
In addition, Timed Computation Tree Logic introduces path formulas:
\[\phi:==\Phi U^J\Phi\]
\noindent Here, $J$ is an interval with natural number bounds.
The derived operators are: 
\begin{itemize}
    \item \textit{Future operator} ($F^J\Phi=\text{true}U^J\Phi$): $\Phi$ must hold at some point within interval $J$.
    \item \textit{Existential globally operator} ($EG^J\Phi=\lnot AF^J\lnot\Phi$): there exists a path where $\Phi$ holds during $J$.
    \item \textit{Universal globally operator} ($AG^J\Phi=\lnot EF^J\lnot\Phi$): for all paths, $\Phi$ holds throughout $J$.
\end{itemize}

\subsubsection{Semantic}
Path formulas must hold only on time-divergent paths.
If s is a state represented as $s=\left\langle \ell,\eta\right\rangle$, then:
\begin{itemize}
    \item $s\models\text{true}$
    \item $s\models a$ if and only if $a\in L(\ell)$
    \item $s\models g$ if and only if $\eta\models g$
    \item $s\models \lnot\Phi$ if and only if $s\not\models\Phi$
    \item $s\models \Phi\land\Psi$ if and only if $s\models\Phi\land s \models\Psi$
    \item $s\models \exists\phi$ if and only if $\pi\models\phi$ for some $\pi\in\text{paths}_{\text{div}}(s)$
    \item $s\models \forall\phi$ if and only if $\pi\models\phi$ for all $\pi\in\text{paths}_{\text{div}}(s)$
\end{itemize}
For a time-divergent path $\pi\in s_0\overset{d_0}{\implies}s_1\overset{d_2}{\implies}\dots$, we can define eventuality, globality and bounded until operators. 

\paragraph*{Eventuality}
Eventuality operator is denoted as $\pi\models\Diamond^J\Phi$. 
It holds when there esists some index $\exists i \geq 0$ and delay $d\in[0,d_i]$ such that: 
\[s_i+d\models\Phi\qquad \sum_{k=0}^{i-1}d_k+d\in J\]
This operator means that a $\phi$-state is reached at some time instant $t\in J$.

\paragraph*{Globality}
Globality operator is denoted as $\pi\models\square^J\Phi$. 
It holds when for every index $\exists i \geq 0$ and all delay $d\in[0,d_i]$ such that: 
\[s_i+d\models\Phi\qquad \sum_{k=0}^{i-1}d_k+d\in J\]
This operator means that all states visited within interval $J$ satisfy $\phi$. 

\paragraph*{Bounded until}
Bounded until operator is denoted as $\Phi\cup^J\Psi$. 
Holds when at some point within $J$, a state satisfying $\Psi$ is reached, and at all previous time instants, $\Phi$ or $\Psi$ holds.
In standard Linear Temporal Logic and Computation Tree Logic, $\Phi\cup\Psi$ is equivalent to $(\Phi\lor\Psi)\cup\Psi$.

\subsubsection{Timed Computation Tree Logic Semantics for Timed Automata}
Let Timed Automata be a Timed Automaton with: clocks $C$, locations $\text{Loc}$, initial states $\text{Loc}_0$, and a clock evaluation function $\text{eval}(C)$. 
For a Timed Computation Tree Logic state formula $\Phi$, the satisfaction set is defined as:
\[\text{sat}(\Phi)=\{s\in\text{Loc}\times\text{eval}(C)\mid s\models\Phi\}\]
A Timed Automaton Timed Automata satisfies a Timed Computation Tree Logic formula $\Phi$ if and only if $\Phi$ holds in all initial states:
\[\text{TA}\models\Phi\Leftrightarrow\forall\ell_0\in\text{Loc}_0\quad\left\langle \ell_0,\eta_0\right\rangle\models\Phi \]
Here, $\eta_0(x)=0$ for all $x\in C$. 

\subsection{Model checking}
The construction of the Region Transition System for a Timed Automaton can be modified to incorporate regions introduced by a Timed Computation Tree Logic formula $\Phi$. 
When defining $\text{RTS}(\text{TA})$, we must also consider clock constraints in $\Phi$, specifically the maximum constant $c_x$ for each clock $x$.
The resulting system is denoted as $\text{RTS}(\text{TA},\Phi)$. 

\subsubsection{Equivalence and clock elimination}
Unfortunately, $\text{RTS}(\text{TA},\Phi)$ is not bisimilar to $\text{TS}(\text{TA})$ because certain delay transitions are eliminated.
However, this is still valid since $\text{RTS}(\text{TA},\Phi)$ is stutter-equivalent to $\text{TS}(\text{TA})$.
A transformation exists to eliminate timing parameters from every Timed Computation Tree Logic subformula by introducing new clocks.

\paragraph*{Temporal logic with clocks}
Instead of using dense time operators, a logic called Timed Computation Tree Logic extends Computation Tree Logic by introducing a new set of formula clocks, atomic constraints, and a new in operator to reset a given clock to zero.
A Timed Computation Tree Logic formula $\Phi$ can always be rewritten into an equivalent Timed Computation Tree Logic formula $\Phi^\prime$.
We can then construct a Region Transition System  denoted as $\text{RTS}(\text{TA},\Phi^\prime)$, by introducing the formula clocks and their constraints into $\text{RTS}(A)$.

Timed Computation Tree Logic can be interpreted as a Computation Tree Logic formula over R$\text{RTS}(\text{TA},\Phi^\prime)$, as long as:
\begin{itemize}
    \item Clock constraints are treated as atomic propositions.
    \item Non-Zeno behaviors (paths with infinitely many actions in a finite time) are excluded.
\end{itemize}
\noindent Under the non-Zeno assumption:
\[\text{TA}\models\Phi\Leftrightarrow\text{RTS}(\text{TA},\Phi^\prime)\models\Phi^\prime\]
\noindent Thus, standard Computation Tree Logic model-checking techniques can be applied. Various optimizations are often introduced in practice.

\subsubsection{Complexity}
\begin{theorem}
    For Timed Automaton Timed Automata and Timed Computation Tree Logic formula $\Phi$, the Timed Computation Tree Logic model checking problem $\text{TA}\models\Phi$ can be determined in time: 
    \[\mathcal{O}((N+K)\times\left\lvert \Phi\right\rvert )\] 
    Here, $N$ and $K$ are the number of states and transitions in the region Transition System $\text{RTS}(\text{TS},\Phi)$, respectively. 
\end{theorem}
\noindent Since Region Transition System states grow exponentially in the number of clocks and the binary representation of constants, the complexity is significant.
\begin{theorem}
    The Timed Computation Tree Logic model checking problem is PSPACE-complete.
\end{theorem}

In practice, most model checkers do not support full Timed Computation Tree Logic.
Symbolic techniques, which improve verification efficiency, cannot easily extend to full Timed Computation Tree Logic.
Model checking safety, reachability, and $\omega$-regular properties, Linear Temporal Logic, and Computation Tree Logic for Timed Automata is PSPACE-complete.
Timed Computation Tree Logic satisfiability is undecidable.
Model checking Timed Linear Temporal Logic is undecidable.