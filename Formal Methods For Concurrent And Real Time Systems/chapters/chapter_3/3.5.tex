\section{Computation Tree Logic}

In branching-time temporal logics, time is represented as a tree-like structure where each state may have multiple successor states. 
This framework allows for reasoning about all or some possible futures, making it useful for verifying concurrent systems.

Computation Tree Logic (CTL) is a branching-time temporal logic used to specify properties of computation trees, which represent all possible executions of a TS. 
Unlike LTL, which interprets formulas in terms of single execution paths, CTL allows reasoning about multiple possible futures.

\subsection{Syntax}
The syntax of CTL formulas is based on two main type of formulas, based on states and paths. 

\paragraph*{State formulas}
In state formulas we have assertions about properties of individual states and their branching structure: 
\begin{itemize}
    \item $E\phi$: there exists a path from the current state along which $\phi$ holds.
    \item $A\phi$: for all paths from the current state, $\phi$ holds.
\end{itemize}
\noindent Therefore, the complete syntax for the state formulas is:
\[\Phi ::= true \mid a \mid \lnot \Phi \mid \Phi_1\cup \Phi_2 \mid E\phi \mid A\phi\]
\noindent Here, $a$ represents atomic propositions.

\paragraph*{Path formulas}
In path formulas we describe temporal properties along paths: 
\begin{itemize}
    \item $X\phi$: in the next state along the current path, $\phi$ holds.
    \item $F\phi$: there exists a future state along the current path where $\phi$ holds.
    \item $G\phi$: $\phi$ holds in all future states along the current path.
    \item $\phi_1 \cup \phi_2$: $\phi_2$ holds at some future state, and $\phi_1$ holds until then.
\end{itemize}
\noindent Therefore, the complete syntax for the path formulas is:
\[\Phi ::= X \Phi \mid F\Phi\mid G\Phi \mid\Phi_1\cup\Phi_2\]

\subsection{Semantic}
Given a TS $\left\langle S, \text{Act}, \rightarrow, I,\text{AP}, L\right\rangle$, we have: 
\begin{itemize}
    \item $s \models a$ if and only if $a \in L(s)$. 
    \item $s \models \lnot \Phi$ if and only if $s \not\models \Phi$.
    \item $s \models \Phi_1 \cup \Phi_2$ if and only if $s \models \Phi_1$ and $s \models \Phi_1$.
    \item $s \models E\phi$ if and only if there exists a path from $s$ where $\phi$ holds. 
    \item $s \models A\phi$  if and only if for all paths from $s$, $\phi$ holds. 
\end{itemize}
\noindent For path formulas, given a path $\sigma$ (a sequence of states $s_0s_1s_2\dots$ of a run) in $\text{TS}$: 
\begin{itemize}
    \item $\sigma \models X\Phi$ if and only if $s_1 \models \Phi$.
    \item $\sigma \models \Phi_1 \cup \Phi_2$ if and only if there exists $j\geq 0$ such that $s_j \models \Phi_2$ and for all $0 \leq i < j$, $s_i \models \Phi_1$.
\end{itemize}
\noindent A CTL formula $\Phi$ and an LTL formula $\phi$ are equivalent, denoted as $\Phi\equiv\phi$, if they hold for the same TS: 
\[\text{TS} \models \Phi \Leftrightarrow \text{TS} \models \phi\]
\begin{theorem}
    CTL and LTL are incomparable.
\end{theorem}
\begin{theorem}
    Let $\Phi$ be a CTL formula, and let $\phi$ be the LTL formula obtained by eliminating all path quantifiers in $\Phi$. 
    Then, one of the following holds:
    \begin{itemize}
        \item $\Phi\equiv\phi$, meaning $\Phi$ can be fully expressed in LTL.
        \item There does not exist any LTL formula that is equivalent to the CTL formula $\Phi$.
    \end{itemize}
\end{theorem}

\subsection{Fairness}
Fairness constraints are essential for verifying concurrent systems. 
A fair path is one where each fairness condition is satisfied infinitely often. 
However, CTL alone cannot express fairness conditions directly within its path formulas.
To address this limitation, Fair CTL is introduced:
\begin{itemize}
    \item Fair CTL has the same syntax as CTL but is interpreted over fair paths.
    \item Fair paths are defined using a CTL formula, interpreted as if it were LTL.
\end{itemize}

\subsection{Model checking}
\paragraph*{Normal form}
Similar to LTL, normal forms can be defined for CTL:
\begin{itemize}
    \item \textit{Positive normal form}: defined analogously to LTL.
    \item \textit{Existential normal form}: a form where only the modalities exists next, exists until, and exists globally appear.
        In this form, negation cannot be pushed to atomic propositions.
        However, model-checking algorithms can handle universal operators by duality. 
\end{itemize}

\paragraph*{Model checking}
Given a TS and a CTL formula $\Phi$, the problem is to determine whether $\text{TS} \models \Phi$. 
The approach follows these steps:
\begin{enumerate}
    \item For each state sub-formula $\psi$ of $\Phi$, explore the state space of $\text{TS}$ to determine the set of states where $\psi$ holds.
    \item Start from atomic propositions and incrementally evaluate sub-formulas with increasing temporal depth.
    \item The formula $\Phi$ itself has the highest nesting depth among its sub-formulas.
    \item Assume formulas are given in existential normal form. 
        The only allowed temporal sub-formulas are: exists until ($E(\phi_1\cup\phi_2)$), exists next ($EX\phi$), and exists globally ($EG\phi$).
\end{enumerate}

\paragraph*{Satisfaction set computation}
Given a finite TS with set state $S$ and CTL formula $\Phi$ in existential normal form, the algorithm computes $\text{sat}(\Phi)=\left\{s\in S\mid s\models\Phi\right\}$.
\begin{algorithm}[H]
    \caption{Satisfaction set computation}
        \begin{algorithmic}[1]
            \Repeat     
                \Switch{$\Phi$}
                    \Case{$\text{true}$}
                        \State \Return $S$
                    \EndCase
                    \Case{$a$}
                        \State \Return $\left\{s\in S\mid a \in L(s)\right\}$
                    \EndCase
                    \Case{$\Phi_1\land\Phi_2$}
                        \State \Return $\text{sat}(\Phi_1)\cap\text{sat}(\Phi_2)$
                    \EndCase
                    \Case{$\lnot\psi$}
                        \State \Return $S\setminus\text{sat}(\psi)$
                    \EndCase
                    \Case{$\exists\circ\psi$}
                        \State \Return $\left\{s\in S\mid\text{post}(s)\cap\text{sat}(\psi)\neq\varnothing\right\}$
                    \EndCase
                    \Case{$\exists(\Phi_1\cup\Phi_2)$}
                        \State $T=\text{sat}(\Phi_2)$ 
                        \While {$s\in\left\{s\in\text{sat}(\Phi_1)\setminus T\mid\text{post}(s)\cap T\neq \varnothing\right\}\neq \varnothing$}
                            \State $s= \left\{s\in\text{sat}(\Phi_1)\setminus T\mid\text{post}(s)\cap T\neq \varnothing\right\}$
                            \State $T=T\cup\{s\}$ 
                        \EndWhile 
                        \State \Return $T$
                    \EndCase
                    \Case{$\exists\Box\phi$}
                        \State $T=\text{sat}(\Phi)$ 
                        \While {$s\in\left\{s\in T\mid\text{post}(s)\cap T= \varnothing\right\}\neq \varnothing$}
                            \State $s= \left\{s\in T\mid\text{post}(s)\cap T= \varnothing\right\}$
                            \State $T=T\setminus\{s\}$ 
                        \EndWhile 
                        \State \Return $T$
                    \EndCase
                \EndSwitch
            \Until{all subformulas $\psi$ of $\Phi$ are evaluated}
        \end{algorithmic}
\end{algorithm}
\noindent For a TS with $N$ states and $K$ transitions, and CTL formula $\Phi$, the complexity of CTL model checking is $\mathcal{O}((N+K)\cdot\left\lvert \Phi\right\rvert )$.
his suggests that CTL model checking is computationally more efficient than LTL model checking.
However, there is an important caveat:
\begin{itemize}
    \item TL formulas can be exponentially more compact than their CTL equivalents (if they exist).
    \item If $\mathcal{P}\neq\mathcal{NP}$, there exist LTL formulas $\phi_n$ of polynomial length $n$, where any equivalent CTL formula must have non-polynomial length.
    \item Additionally, for properties expressible in both CTL and LTL, LTL model checking can also be made linear in time complexity.
\end{itemize}