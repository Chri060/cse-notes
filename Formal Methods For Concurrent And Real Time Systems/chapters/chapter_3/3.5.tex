\section{Computation Tree Logic}

In branching-time temporal logics, time is represented as a tree-like structure where each state may have multiple successor states. 
This framework allows for reasoning about all or some possible futures, making it useful for verifying concurrent systems.

Computation Tree Logic is a branching-time temporal logic used to specify properties of computation trees, which represent all possible executions of a Transition System. 
Unlike Linear Temporal Logic, which interprets formulas in terms of single execution paths, Computation Tree Logic allows reasoning about multiple possible futures.

\subsection{Syntax}
The syntax of Computation Tree Logic formulas is based on two main type of formulas, based on states and paths. 

\paragraph*{State formulas}
In state formulas we have assertions about properties of individual states and their branching structure: 
\begin{itemize}
    \item $E\phi$: there exists a path from the current state along which $\phi$ holds.
    \item $A\phi$: for all paths from the current state, $\phi$ holds.
\end{itemize}
\noindent Therefore, the complete syntax for the state formulas is:
\[\Phi ::= true \mid a \mid \lnot \Phi \mid \Phi_1\cup \Phi_2 \mid E\phi \mid A\phi\]
\noindent Here, $a$ represents atomic propositions.

\paragraph*{Path formulas}
In path formulas we describe temporal properties along paths: 
\begin{itemize}
    \item $X\phi$: in the next state along the current path, $\phi$ holds.
    \item $F\phi$: there exists a future state along the current path where $\phi$ holds.
    \item $G\phi$: $\phi$ holds in all future states along the current path.
    \item $\phi_1 \cup \phi_2$: $\phi_2$ holds at some future state, and $\phi_1$ holds until then.
\end{itemize}
\noindent Therefore, the complete syntax for the path formulas is:
\[\Phi ::= X \Phi \mid F\Phi\mid G\Phi \mid\Phi_1\cup\Phi_2\]

\subsection{Semantic}
Given a Transition System $\text{TS}=\left\langle S, \text{Act}, \rightarrow, I,\text{AP}, L\right\rangle$, we have: 
\begin{itemize}
    \item $s \models a$ if and only if $a \in L(s)$. 
    \item $s \models \lnot \Phi$ if and only if $s \not\models \Phi$.
    \item $s \models \Phi_1 \cup \Phi_2$ if and only if $s \models \Phi_1$ and $s \models \Phi_1$.
    \item $s \models E\phi$ if and only if there exists a path from $s$ where $\phi$ holds. 
    \item $s \models A\phi$  if and only if for all paths from $s$, $\phi$ holds. 
\end{itemize}
\noindent For path formulas, given a path $\sigma$ (a sequence of states $s_0s_1s_2\dots$ of a run) in $\text{TS}$: 
\begin{itemize}
    \item $\sigma \models X\Phi$ if and only if $s_1 \models \Phi$.
    \item $\sigma \models \Phi_1 \cup \Phi_2$ if and only if there exists $j\geq 0$ such that $s_j \models \Phi_2$ and for all $0 \leq i < j$, $s_i \models \Phi_1$.
\end{itemize}
\noindent A Computation Tree Logic formula $\Phi$ and an Linear Temporal Logic formula $\phi$ are equivalent, denoted as $\Phi\equiv\phi$, if they hold for the same Transition Systems: 
\[\text{TS} \models \Phi \Leftrightarrow \text{TS} \models \phi\]
\begin{theorem}
    Computation Tree Logic and Linear Temporal Logic are incomparable.
\end{theorem}
\begin{theorem}
    Let $\Phi$ be a Computation Tree Logic formula, and let $\phi$ be the Linear Temporal Logic formula obtained by eliminating all path quantifiers in $\Phi$. 
    Then, one of the following holds:
    \begin{itemize}
        \item $\Phi\equiv\phi$, meaning $\Phi$ can be fully expressed in Linear Temporal Logic.
        \item There does not exist any Linear Temporal Logic formula that is equivalent to the Computation Tree Logic formula $\Phi$.
    \end{itemize}
\end{theorem}

\subsection{Fairness}
airness constraints are essential for verifying concurrent systems. 
A fair path is one where each fairness condition is satisfied infinitely often. 
However, Computation Tree Logic alone cannot express fairness conditions directly within its path formulas.
To address this limitation, Fair Computation Tree Logic is introduced:
\begin{itemize}
    \item Fair Computation Tree Logic has the same syntax as Computation Tree Logic but is interpreted over fair paths.
    \item Fair paths are defined using a Computation Tree Logic formula, interpreted as if it were Linear Temporal Logic.
\end{itemize}

\subsection{Model checking}
\paragraph*{Normal form}
Similar to Linear Temporal Logic, normal forms can be defined for Computation Tree Logic:
\begin{itemize}
    \item \textit{Positive normal form}: defined analogously to Linear Temporal Logic.
    \item \textit{Existential normal form}: a form where only the modalities exists next, exists until, and exists globally appear.
        In this form, negation cannot be pushed to atomic propositions.
        However, model-checking algorithms can handle universal operators by duality. 
\end{itemize}

\paragraph*{Model checking}
Given a Transition System $\text{TS}$ and a Computation Tree Logic formula $\Phi$, the problem is to determine whether $\text{TS} \models \Phi$. 
The approach follows these steps:
\begin{enumerate}
    \item For each state subformula $\psi$ of $\Phi$, explore the state space of $\text{TS}$ to determine the set of states where $\psi$ holds.
    \item Start from atomic propositions (temporal depth 0) and incrementally evaluate subformulas with increasing temporal depth.
    \item The formula $\Phi$ itself has the highest nesting depth among its subformulas.
    \item Assume formulas are given in existential normal form. 
        The only allowed temporal subformulas are: exists until ($E(\phi_1\cup\phi_2)$), exists next ($EX\phi$), and exists globally ($EG\phi$).
\end{enumerate}

\paragraph*{Satisfaction set computation}
Given a finite Transition System $\text{TS}$ with set state $S$ and Computation Tree Logic formula $\Phi$ in existential normal form, the algorithm computes $\text{sat}(\Phi)=\left\{s\in S\mid s\models\Phi\right\}$.
\begin{algorithm}[H]
    \caption{Satisfaction set computation}
        \begin{algorithmic}[1]
            \Repeat     
                \Switch{$\Phi$}
                    \Case{$\text{true}$}
                        \State \Return $S$
                    \EndCase
                    \Case{$a$}
                        \State \Return $\left\{s\in S\mid a \in L(s)\right\}$
                    \EndCase
                    \Case{$\Phi_1\land\Phi_2$}
                        \State \Return $\text{sat}(\Phi_1)\cap\text{sat}(\Phi_2)$
                    \EndCase
                    \Case{$\lnot\psi$}
                        \State \Return $S\setminus\text{sat}(\psi)$
                    \EndCase
                    \Case{$\exists\circ\psi$}
                        \State \Return $\left\{s\in S\mid\text{post}(s)\cap\text{sat}(\psi)\neq\varnothing\right\}$
                    \EndCase
                    \Case{$\exists(\Phi_1\cup\Phi_2)$}
                        \State $T=\text{sat}(\Phi_2)$ 
                        \While {$s\in\left\{s\in\text{sat}(\Phi_1)\setminus T\mid\text{post}(s)\cap T\neq \varnothing\right\}\neq \varnothing$}
                            \State $s= \left\{s\in\text{sat}(\Phi_1)\setminus T\mid\text{post}(s)\cap T\neq \varnothing\right\}$
                            \State $T=T\cup\{s\}$ 
                        \EndWhile 
                        \State \Return $T$
                    \EndCase
                    \Case{$\exists\square\phi$}
                        \State $T=\text{sat}(\Phi)$ 
                        \While {$s\in\left\{s\in T\mid\text{post}(s)\cap T= \varnothing\right\}\neq \varnothing$}
                            \State $s= \left\{s\in T\mid\text{post}(s)\cap T= \varnothing\right\}$
                            \State $T=T\setminus\{s\}$ 
                        \EndWhile 
                        \State \Return $T$
                    \EndCase
                \EndSwitch
            \Until{all subformulas $\psi$ of $\Phi$ are evaluated}
        \end{algorithmic}
\end{algorithm}
\noindent For a Transition System $\text{TS}$ with $N$ states and $K$ transitions, and Computation Tree Logic formula $\Phi$, the complexity of Computation Tree Logic model checking is $\mathcal{O}((N+K)\cdot\left\lvert \Phi\right\rvert )$.
his suggests that Computation Tree Logic model checking is computationally more efficient than Linear Temporal Logic model checking.
However, there is an important caveat:
\begin{itemize}
    \item TL formulas can be exponentially more compact than their Computation Tree Logic equivalents (if they exist).
    \item If $\mathcal{P}\neq\mathcal{NP}$, there exist Linear Temporal Logic formulas $\phi_n$ of polynomial length $n$, where any equivalent Computation Tree Logic formula must have non-polynomial length.
    \item Additionally, for properties expressible in both Computation Tree Logic and Linear Temporal Logic, Linear Temporal Logic model checking can also be made linear in time complexity.
\end{itemize}