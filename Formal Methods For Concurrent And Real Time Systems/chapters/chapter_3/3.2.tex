\section{Liveness property}

Liveness properties ensure that certain desired behaviors eventually occur in a system. 
Unlike safety properties, liveness properties cannot be verified on a finite prefix of a run. 
Instead, they require reasoning about infinite sequences, necessitating a framework to handle infinite words. 

\subsection{Regular languages over infinite words}
An infinite word over an alphabet $\Sigma$ is an infinite sequence $A_0A_1A_2\dots$ where each symbol $A_i\in\Sigma$. 
The set of all infinite words over $\Sigma$ is denoted by $\Sigma^\omega$. 
Any subset of $\Sigma^\omega$ is called an $\omega$-language.

Regular languages over infinite words, known as $\omega$-regular languages, can be defined using automata or generalized regular expressions. 
While $\omega$-regular expressions provide an intuitive understanding, automata-based definitions are more practical for verification purposes.

\subsection{Nondeterministic Büchi automata}
A nondeterministic Büchi automaton is a variation of a nondeterministic finite automaton that accepts infinite words instead of finite ones.
\begin{definition}[\textit{Nondeterministic Büchi automaton}]
    A nondeterministic Büchi automaton $\mathcal{A}$ is formally defined as a tuple $\mathcal{A} = \left\langle Q, \Sigma, \delta, Q_0, F\right\rangle$, where: 
    \begin{itemize}
        \item $Q$ is a finite set of states.
        \item $\Sigma$ is an input alphabet.
        \item $\delta : Q \times \Sigma \rightarrow 2^Q$ is the transition function.
        \item $Q_0 \subseteq Q$ is a set of initial states.
        \item $F \subseteq Q$ is a set of final (accepting) states.
    \end{itemize}
\end{definition}

\subsubsection{Acceptance condition}
A run of $\mathcal{A}$ on an infinite word $\sigma=A_0A_1A_2\dots\in\Sigma^\omega$ is an infinite sequence of states $q_0q_1q_2\dots$ such that: 
\begin{itemize}
    \item $q_0\in Q_0$ (initial state). 
    \item $q_i\xrightarrow{A_i}q_{i+1}$ for all $i\geq 0$. 
\end{itemize}
\noindent The run is accepted if it visits a state in $F$ infinitely often.
The language recognized by $\mathcal{A}$ is: 
\[\mathcal{L}_{\omega}(\mathcal{A})=\left\{\sigma\in\Sigma^\omega\mid\text{there exists an accepting run for }\sigma\text{ in }\mathcal{A}\right\}\]

\subsubsection{Deterministic and nondeterministic comparison}
Nondeterministic Büchi automata are strictly more powerful than deterministic Büchi automata. 
\begin{theorem}
    There does not exists a deterministic Büchi automata $\mathcal{A}$ such that $\mathcal{L}_{\omega}(\mathcal{A})=\mathcal{L}_{\omega}((A+B)^\ast B^\omega)$
\end{theorem}

\subsection{Regular property model checking}
Given a finite TS without terminal states and an $\omega$-regular $P$, the goal is to verify whether $\text{TS} \models P$.
This is equivalent to checking whether the traces of $\text{TS}$ intersect with the complement of $P$, recognized by an nondeterministic Büchi automata $\mathcal{A}$: 
\[\text{traces}(\text{TS})\cap\mathcal{L}_{\omega}(\mathcal{A})\neq\varnothing\]

\subsubsection{Algorithm}
The verification process consists of the following steps:
\begin{enumerate}
    \item \textit{Construct the product automaton}: compute the product $\text{TS} \otimes \mathcal{A}$, which combines paths in $\text{TS}$ with runs in $\mathcal{A}$.
    \item \textit{Graph analysis}: check if there exists a path in $\text{TS} \otimes \mathcal{A}$ that visits an accepting state infinitely often.
    \item \textit{Counterexample detection}: if such a path exists, it serves as a counterexample, proving that $\text{TS}$ does not satisfy $P$.
        Otherwise, all runs corresponding to traces in TS are non-accepting, meaning $\text{TS}\models P$.
\end{enumerate}
\noindent The core of the algorithm is detecting cycles in the product automaton that include accepting states. 
This can be achieved using depth-first search.
With optimizations like nested depth-first search, the algorithm runs in linear time concerning the size of the product graph.
However, complementing an Nondeterministic Büchi automaton recognizing $P$ is computationally expensive, requiring up to $(0.76n)^n$ time, making direct complement impractical.