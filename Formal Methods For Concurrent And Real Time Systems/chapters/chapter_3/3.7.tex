\section{Bounded model checking}

Bounded Model Checking is a technique used to verify properties of transition systems by checking the satisfiability of Boolean formulae. 
SAT solvers, which work on Boolean formulae in Conjunctive Normal Form (CNF), play a crucial role in this approach. 
Although SAT is an $\mathcal{NP}$-complete problem with no known sub-exponential worst-case algorithm, recent advancements in SAT solvers have led to efficient solutions for many practical cases. 
These solvers use the standard DIMACS-CNF format and can routinely handle formulae with tens of thousands of variables and millions of constraints. 

Most modern solvers implement sophisticated variations of the Davis-Putnam-Logemann-Loveland (DPLL) algorithm, which is based on backtracking.
The DPLL algorithm is the foundation of many SAT solvers.
Given a formula $F$ in conjunctive normal form a set of true literals $T$ (initially empty), the procedure is as follows:
\begin{algorithm}[H]
    \caption{Davis-Putnam-Logemann-Loveland}
        \begin{algorithmic}[1]
            \Function{DPLL}{$F$, $T$}
                \If{$F$ evaluted over $T$ is $\text{true}$}
                    \State \Return $\text{true}$
                \ElsIf{$F$ evaluted over $T$ is $\text{false}$}
                    \State \Return $\text{false}$
                \ElsIf{a clause of $F$ has only one literal $L$}
                    \State \Return \Call{DPLL}{$F(L=\text{true})$, $T \cup \{L\}$}
                \ElsIf{a literal $L$ appears only as $L=x$ or $L=\lnot x$ but not both}
                    \State \Return \Call{DPLL}{$F(L=\text{true})$, $T$}
                \EndIf 
                \State Choose a literal $L$
                \State \Return \Call{DPLL}{$F(L=\text{true})$, $T \cup \{L\}$} \textbf{or} \Call{DPLL}{$F(L=\text{false})$, $T \cup \{\lnot L\}}$
            \EndFunction
        \end{algorithmic}
\end{algorithm}

\paragraph*{Counterexamples}
A fundamental aspect of Bounded Model Checking is the concept of counterexamples for Linear Temporal Logic properties in a transition system. 
Since the number of states in a system is finite, any counterexample must have a finite length.
If a cycle occurs within a path, it must do so within a bounded length of at most the number of states plus one. 
This bound, referred to as the diameter or completeness threshold, allows us to encode the unfolding of the transition relation up to $k$ steps into a Boolean formula. 
By adding constraints based on the property being verified and cycle detection, we construct a formula $\phi_k$ such that $\phi_k$ is satisfiable if and only if there exists a counterexample to the property of length at most $k$.

\subsection{Back loops amd transition relation}
A finite prefix of length k can represent an infinite path if a back loop exists from the last state of the prefix to any of the previous states. 
If no such back loop is found, the prefix does not provide information about the infinite behavior of the path. 
The $k$-times unfolding of a transition system's transition relation is represented as a propositional formula ${\left\lvert [M]\right\rvert}_k$, where states are encoded as bit vectors.
This unfolding captures all finite paths of length $k$: 
\[{\left\lvert [M_S]\right\rvert}_k\leftrightarrow I(S_0)\bigwedge_{0\leq i \leq k1}T(S_i,S_{i+1}) \]
New loop selector variables are introduced to identify possible loops, ensuring that at most one loop exists and that if a loop occurs at position $h$, then the state at$S_{h-1}$ must be identical to $S_k$. 
Additional Boolean variables indicate whether a state is within a loop and whether a loop exists in the structure.

\subsection{Temporal logic properties}
The semantics of a LTL formula $\Phi$ in positive normal form is expressed through Boolean constraints over new formula variables.
Each subformula of $\Phi$  is associated with a propositional variable at every time step.

\paragraph*{Propositional constraint}
Propositional constraints define how these variables interact with system states.
Given a formula $\phi$ and a index $0\leq i\leq k$, we have the following: 
\begin{itemize}
    \item $p\rightarrow{\left\lvert [p]\right\rvert}_i\leftrightarrow p\in S_i$
    \item $\lnot p\rightarrow{\left\lvert [\lnot p]\right\rvert}_i\leftrightarrow p\notin S_i$
    \item $\phi_1\land\phi_2\rightarrow{\left\lvert [\phi_1\land\phi_2]\right\rvert}_i\leftrightarrow{\left\lvert [\phi_1]\right\rvert}_i\land {\left\lvert [\phi_2]\right\rvert}_i$
    \item $\phi_1\lor\phi_2\rightarrow{\left\lvert [\phi_1\lor\phi_2]\right\rvert}_i\leftrightarrow{\left\lvert [\phi_1]\right\rvert}_i\lor {\left\lvert [\phi_2]\right\rvert}_i$
\end{itemize}

\paragraph*{Temporal Operators}
Temporal operators such as weak until ($\mathcal{W}$) and strong until ($\mathcal{U}$) require additional handling, particularly when eventualities appear inside loops.
Special propositional variables track eventualities to ensure that strong properties are correctly encoded.
Given a formula $\phi$ and a index $0\leq i\leq k$, we have the following: 
\begin{itemize}
    \item $\circ\phi_1\rightarrow{\left\lvert [\circ\phi_1]\right\rvert}_i\leftrightarrow{\left\lvert [\phi_1]\right\rvert}_{i+1}$
    \item $\phi_1\mathcal{U}\phi_2\rightarrow{\left\lvert [\phi_1\mathcal{U}\phi_2]\right\rvert}_i\leftrightarrow{\left\lvert [\phi_2]\right\rvert}_i\lor\left({\left\lvert [\phi_1]\right\rvert}_i\land {\left\lvert [\phi_1\mathcal{U}\phi_2]\right\rvert}_{i+1}\right)$
    \item $\phi_1\mathcal{R}\phi_2\rightarrow{\left\lvert [\phi_1\mathcal{R}\phi_2]\right\rvert}_i\leftrightarrow{\left\lvert [\phi_2]\right\rvert}_i\land\left({\left\lvert [\phi_1]\right\rvert}_i\lor {\left\lvert [\phi_1\mathcal{R}\phi_2]\right\rvert}_{i+1}\right)$
\end{itemize}

\paragraph*{Complete encoding}
The complete encoding $\Phi_k$ results in a Boolean formula that logically conjoins all components, including loops, propositional connectives, temporal operators, and eventualities.
The formula is evaluated at instant 0, ensuring that the verification process correctly captures the required behaviors.

\subsection{Model checking}
Bounded Model Checking translates the verification problem into a propositional satisfiability (SAT) problem, leveraging SAT solvers for efficiency.
The transformation procedure is as follows: 
\begin{enumerate}
    \item Unfolding the transition relation: the system's transition relation is unfolded $k$ times, producing a propositional formula ${\left\lvert [M]\right\rvert }_k$. 
    \item Loop constraints: additional variables and constraints define the presence and position of loops (if any). 
    \item Encoding LTL semantics: a Linear Temporal Logic formula $F$, in release-positive normal form, is translated into Boolean constraints over newly introduced formula variables.
    \item For each subformula and each instant $0\leq i \leq k+1$, a propositional variable ${\left\lvert [j]\right\rvert }_i$ is introduced.
\end{enumerate}
\noindent Then, we follow this procedure: 
\begin{enumerate}
    \item Choose a $k$ value that is large enough but not excessive.
    \item Construct the formula $\Phi_k$.
    \item Use a SAT solver to check $\Phi_k$. 
    \item If $\Phi_k$ is satisfiable: the solver returns a valid counterexample of length less or equal than $k$.
    \item If $\Phi_k$ is unsatisfiable: the property may hold, but longer counterexamples may still exist. 
        Increment $k$ and repeat the process.
    \item Completeness threshold: if $k\geq\text{CT}$ and $\Phi_k$ remains unsatisfiable, the property $P$ holds. 
        However, $\text{CT}$ is often unknown and computationally challenging to determine.
\end{enumerate}
\noindent Bounded Model Checking is significantly faster than traditional model checking in finding counterexamples due to its reliance on SAT solvers.
It is particularly useful for debugging models early in development.
However, an unsatisfiable result for $k<\text{CT}$ does not rule out violations at larger $k$, necessitating further exploration.