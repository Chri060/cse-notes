\section{Linear Time Logic}

Linear Temporal Logic is a formalism used to describe temporal properties of systems. 
It is widely used in model checking, verification, and automated reasoning. 
Linear Temporal Logic operates over sequences of states, allowing the specification of temporal constraints using logical operators.

\subsection{Syntax}
Linear Time Logic formulas are constructed using the following grammar:
\[\phi::=\text{true}\mid a \mid \phi_1\land\phi_2\mid\lnot\phi\mid\bigcirc \phi\mid\phi_1\cup\phi_2\]
\noindent Here, $a$ is an atomic proposition, $\bigcirc\phi$ (next) asserts that $\phi$ holds in the next state, $\phi_1\cup\phi_2$ (until) states that $\phi_2$ will eventually hold, and until then, $\phi_1$ must hold.
From this, we can derive the eventually ($\Diamond\phi\overset{\text{def}}{=}\text{true}\cup\phi$) and always ($\square\phi\overset{\text{def}}{=}\lnot\Diamond\lnot\phi$) operators.

\subsection{Semantics}
TL formulas are interpreted over infinite sequences of states $\sigma=A_0A_1\dots$, where $A_i \subseteq 2^{\text{AP}}$.
The satisfaction relation $\sigma\models\phi$ is defined as:
\begin{itemize}
    \item $\sigma\models\text{true}$
    \item $\sigma\models a \Leftrightarrow a\in A_0$
    \item $\sigma\models \phi_1\land\phi_2 \Leftrightarrow \sigma\models\phi_1 \land \sigma\models\phi_2$
    \item $\sigma\models \lnot\phi \Leftrightarrow \sigma\not\models\phi$
    \item $\sigma\models \bigcirc \phi \Leftrightarrow \sigma[1\dots]=A_1A_2A_3\dots\models\phi$
    \item $\sigma\models \phi_1\cup\phi_2 \Leftrightarrow \exists j \geq 0\quad\sigma[j\dots]\models\phi_2 \land \sigma[1\dots]\models\phi_1\forall 0\leq i<j$
    \item $\sigma\models\Diamond\phi \Leftrightarrow \exists j\geq 0 \quad \sigma[j\dots]\models\phi$
    \item $\sigma\models\square\phi \Leftrightarrow \forall j\geq 0 \quad \sigma[j\dots]\models\phi$
\end{itemize}
\noindent The timed interpretation of the operators is as follows: 
\begin{itemize}
    \item $\bigcirc^k\phi$ means $\phi$ holds after exactly $k$ steps. 
    \item $\Diamond^{\leq k}\phi$ means $\phi$ will hold within at most $k$ steps. 
    \item $\square^{\leq k}\phi$ means $\phi$ holds now and for the next $k$ steps.
\end{itemize}

\paragraph*{Past operators}
Although Linear Time Logic primarily focuses on the future, past operators can be introduced without increasing expressive power:
\begin{itemize}
    \item \textit{Previous}: $\bullet\phi$ holds if $\phi$ was true in the previous state.
    \item \textit{Since}: $\phi S \psi$ means $\psi$ held at some past time, and $\phi$ was true until then.
    \item \textit{Eventually in the past}: $\blacklozenge \phi\text{ is true }S\phi$.
    \item \textit{Always in the past}: $\blacksquare \phi=\lnot\blacklozenge \lnot\phi$.
\end{itemize}

\paragraph*{Metric operators}
Metric extensions allow explicit bounds on temporal operators:
\begin{itemize}
    \item $\phi\mathcal{U_{\sim t}}\psi$ means $\psi$ holds within time $t$ while $\phi$ holds until then.
    \item $\phi\mathcal{S_{\sim t}}\psi$ means $\psi$ holds within time $t$ while $\phi$ holds until then.
\end{itemize}

\subsection{Fainrness}
Linear Temporal Logic is defined over atomic propositions, not directly over actions.
Therefore, fairness constraints in Linear Time Logic are expressed in terms of states, rather than actions.

Action-based fairness is more intuitive and straightforward but Linear Time Logic fairness is equally expressive.
Action-based fairness assumptions can be translated into Linear Time Logic fairness assumptions.
One way to achieve this is by making a copy of each non-initial state $s$ and recording which action led to this state. 
For each possible action $a$, a copy of the state is created to indicate that state $s$ was reached through action $a$. 
This copied state, denoted $\left\langle s,a\right\rangle$, indicates that the state $s$ has been reached via action $a$.

In Linear Time Logic, fairness can be expressed using different types of fairness constraints:
\begin{enumerate}
    \item \textit{Unconditional fairness}: $\square\blacklozenge\psi$. 
    \item \textit{Strong fairness}: $\square\blacklozenge\phi\rightarrow\square\blacklozenge\psi$.
    \item \textit{Weak fairness}: $\blacklozenge\square\phi\rightarrow\blacklozenge\square\psi$.
\end{enumerate}

\paragraph*{Assumptions}
To combine fairness assumptions, we use:
\[\text{fair}=\text{unconditionally fair}\land\text{strongly fair}\land\text{weakly fair}\]
\noindent This leads to the following:
\begin{itemize}
    \item Fair paths from state $s$: 
        \[\text{fairPaths}(s)=\{\pi\in\text{paths}(s)\mid\pi\models\text{fair}\}\]
    \item Fair satisfaction of a formula $\phi$: 
        \[s\models_{\text{fair}}\phi\Leftrightarrow\forall\pi\in\text{fairPaths}(s)\quad\pi\models\phi\]
    \item Fair satisfaction in the transition system: 
        \[\text{TS}\models_{\text{fair}}\phi\Leftrightarrow\forall s_0\in I\quad s_0\models_{\text{fair}}\phi\]
\end{itemize}
\begin{theorem}
    For a transition system $\text{TS}$ without terminal states, an Linear Time Logic formula $\phi$, and fairness assumption $\text{fair}$: 
    \[\text{TS}\models_{\text{fair}}\Leftrightarrow\text{TS}\models(\text{fair}\rightarrow\phi)\]
\end{theorem}

\subsection{Positive Normal Form}
Positive Normal Form is a canonical form where negations appear only adjacent to atomic propositions. 
This is similar to disjunctive and conjunctive normal forms in propositional logic.
Every Linear Time Logic formula can be transformed into PNF, but this transformation requires new dual operators.
\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Operator} & \textbf{Dual} & \textbf{Formula} \\ \hline
    OR                & AND           & $\lor\rightarrow\land$                \\ \hline
    Next              & Next          & $\lnot\bigcirc\phi\rightarrow\bigcirc\lnot\phi$                 \\ \hline
    Until             & Weak until    & $\lnot(\phi\cup\psi)\rightarrow(\phi\land\lnot\psi)W(\lnot\phi\land\lnot\psi)$                \\ \hline
    \end{tabular}
\end{table}
The syntax of Linear Time Logic in weak until Positive Normal Form is:
\[\phi::=\text{true}\mid\text{false}\mid a \mid\lnot a\mid \phi_1\land\phi_2\mid\bigcirc\phi\mid\phi_1\cup\phi_2\mid\phi_1 W\phi_2\]
\begin{theorem}
    For any Linear Time Logic formula $\phi$, there exists an equivalent Linear Time Logic formula in weak until Positive Normal Form. 
\end{theorem}
\noindent However, the size of the resulting formula may be exponential in the size of the original formula.

\paragraph*{Release operator}
The release operator $R$ is defined as: 
\[\phi R \psi \overset{\text{def}}{=}\lnot(\lnot\phi\cup\lnot\psi)\]
\noindent The semantycs is $\sigma\models\phi R \psi$ if $\forall j \geq 0, \sigma[j\dots]\models\psi$ or $\exists i \geq 0 \quad (\sigma[i\dots]\models\phi)\land \forall k \leq i \quad \sigma[k\dots]\models\psi$.
Intuitively, the formula $\phi R \psi$ holds if $\psi$ is always true unless $\phi$ becomes true, at which point the requirement for $\psi$ is released. 
The syntax for Linear Time Logic with the release operator is:
\[\phi::=\text{true}\mid\text{false}\mid a \mid\lnot a\mid \phi_1\land\phi_2\mid\bigcirc\phi\mid\phi_1\cup\phi_2\mid\phi_1 R \phi_2\]
\noindent Rewriting rules for Linear Time Logic formulas with the release operator:
\begin{itemize}
    \item $\lnot\text{true}\rightsquigarrow \text{false}$
    \item $\lnot\lnot\phi\rightsquigarrow \phi$
    \item $\lnot(\phi\land\psi)\rightsquigarrow\lnot\phi\lor\lnot\psi$
    \item $\lnot\bigcirc\phi\rightsquigarrow\bigcirc\lnot\phi$
    \item $\lnot(\phi\cup\psi)\rightsquigarrow\lnot\phi R \lnot\psi$
\end{itemize}
\noindent For any Linear Time Logic formula $\phi$, there exists an equivalent formula $\phi^\prime$ in release Positive Normal Form with the same size.

\subsection{Automata model checking}
An important observation is that every Linear Time Logic formula $\phi$ can be represented by a nondeterministic Büchi automaton
Let $\text{words}(\phi)$ be the set of $\omega$-words satisfying an Linear Time Logic formula $\phi$. 
The model checking condition states that $\text{TS}\models\phi$ if and only if: 
\begin{itemize}
    \item $\text{traces}(\text{TS}) \subseteq \text{words}(\phi)$
    \item $\text{traces}(\text{TS}) \cap \left( 2^{\text{AP}} \right)^{\omega} \setminus \text{words}(\phi) = \varnothing$
    \item $\text{traces}(\text{TS}) \cap \text{words}(\lnot \phi) = \varnothing$
\end{itemize}
\noindent For a nondeterministic Büchi automaton $\mathcal{A}$ with language $\mathcal{L}_{\omega}(\mathcal{A})=\text{words}(\lnot\phi)$, we have:
\[\text{TS}\models\phi\Leftrightarrow\text{traces}(\text{TS})\cap\mathcal{L}_{\omega}(\mathcal{A})=\varnothing\]
Instead of building a Büchi automaton equivalent to the negation of the formula and complementing it, it's more efficient to complement the formula first and then construct the equivalent Büchi automaton.

\subsubsection{Linear Time Logic to generalized Büchi automaton}
The construction first builds a generalized Büchi automaton and then converts it to a nondeterministic Büchi automaton. 
A generalized Büchi automaton has a set $\mathcal{F}\subseteq 2^Q$ of acceptance sets, where the accepted language consists of all $\omega$-words that have an infinite run $q_0q_1q_2\dots$ such that for each acceptance set $F \in \mathcal{F}$, there are infinitely many indices $i$ with $q_i\in F$.

For any Linear Time Logic formula $\phi$, there exists a corresponding generalized Büchi automaton $\mathcal{G}_{\phi}$. 
For any Linear Time Logic formula $\phi$, there exists a nondeterministic Büchi automaton $\mathcal{A}_\phi$ such that $\text{words}(\phi)=\mathcal{L}_{\omega}(\mathcal{G}_{\phi})$. 
This can be constructed in time and space $2^{\mathcal{O}(\left\lvert \phi\right\rvert )}$.

\paragraph*{Until operator}
To model the semantics of the until operator ($\cup$), an acceptance set $F_\psi$  is introduced for each subformula $\psi = \phi_1 \cup \phi_2$ of $\phi$.
The semantics of the until operator ensures that for a word $\sigma$ to satisfy $\psi = \phi_1 \cup \phi_2$, the condition is met only if $\phi_2$ eventually becomes true, while $\phi_1$ must hold until $\phi_2$ becomes true
This is enforced by the acceptance set $F_{\phi_1\cup\phi_2}$, defined as: 
\[F_{\phi_1\cup\phi_2}=\left\{B \in Q\mid\phi_1\cup\phi_2\notin B \lor \phi_2\in B\right\}\]
\noindent The complete set of acceptance sets $\mathcal{F}$ for a given Linear Time Logic formula is:
\[\mathcal{F}=\left\{F_{\phi_1\cup\phi_2}\mid\phi_1\cup\phi_2\in\text{closure}(\phi)\right\}\]

\begin{theorem}
    For any Linear Time Logic formula $\phi$ (over a set of atomic propositions $\text{AP}$) there exists a nondeterministic Büchi automaton $\mathcal{A}_\phi$ such that $\text{words}(\phi)=\mathcal{L}_{\omega}(\mathcal{A}_\phi)$ which can be constructed in time and space $2^{\mathcal{O}(\left\lvert \phi\right\rvert )}$.
\end{theorem}
\begin{theorem}
    There exists a family of Linear Time Logic formulas $\phi_n$ with $\left\lvert \phi_n\right\rvert\mathcal{O}(\text{poly}(n))$ such that every nondeterministic Büchi automaton has at least $2^n$ states. 
\end{theorem}
\noindent While the NBA construction can have an exponential number of states, these automata are more expressive than Linear Time Logic formulas themselves.

\paragraph*{Complexity}
The time and space complexity of the Linear Time Logic model-checking algorithm is PSPACE-complete, with the complexity of checking a formula $\phi$ against a transition system $\text{TS}$ given by:
\[\mathcal{O}(\left\lvert \text{TS}\right\rvert 2^{\left\lvert \phi\right\rvert })\]
\noindent However, in practice, the performance can be quite good due to optimizations, such as on-the-fly model checking. 
This approach, which constructs the NBA for the negation of $\phi$ during the process of checking the system, can help avoid constructing the entire automaton upfront.

\subsubsection{Algorithm}
The satisfiability and validity of Linear Time Logic formulas can be determined by checking the emptiness of the corresponding NBA. 
This check can be performed using a nested depth-first search that looks for a reachable cycle containing an accepting state. 
Both satisfiability and validity checking are PSPACE-complete problems.

Given a Linear Time Logic formula $\phi$ over the atomic propositions $\text{AP}$, the algorithm returns true if $\phi$ is satisfiable or false otherwise.
\begin{algorithm}[H]
    \caption{Linear Time Logic model cheking}
        \begin{algorithmic}[1]
            \State Construct a nondeterministic Büchi automaton $\mathcal{A}=\left\langle Q,2^{\text{AP}},\delta,Q_0,F\right\rangle$ with $\mathcal{L}_{\omega}(\mathcal{A})=\text{words}(\phi)$
            \If {$\mathcal{L}_{\omega}(\mathcal{A})=\varnothing$}
                \State \Return $\text{false}$
            \EndIf
            \Repeat
                \State Perform a nested depth first search
                \If{there exists a state $q\in F$ reachable from $q_0\in Q_0$ and that lies on a cycle}
                    \State \Return $\text{true}$
                \EndIf 
            \Until{all nodes are explored}
            \State \Return $\text{false}$
        \end{algorithmic}
\end{algorithm}