\section{Linear time properties}

A linear time property specifies a desired behavior of a system. 
Unlike a formula, it is a set of infinite words over the alphabet $2^{\text{AP}}$, where $\text{AP}$ represents a set of atomic propositions.
We denote: 
\begin{itemize}
    \item The set of infinite words over alphabet $A$ as $A^\omega$. 
    \item The set of finite words over alphabet $A$ as $A^\ast$. 
    \item A linear time property over $\text{AP}$ as a subset of $\left(2^{\text{AP}}\right)^\omega$. 
\end{itemize}

\subsection{Linear time property in Transition Systems}
\begin{definition}[\textit{Linear time property}]
    A TS $(S,\text{Act},\rightarrow,I,\text{AP},l)$ satisfies a linear time property $P$ if and only if: 
    \[\text{TS}\models P\Leftrightarrow\text{traces}(\text{TS})\subseteq P\] 
\end{definition}
\begin{definition}[\textit{Transition equivalence}]
    Two TS $\text{TS}_1$ and $\text{TS}_2$ are trace equivalent with respect to $\text{AP}$ if: 
    \[\text{traces}_{\text{AP}}(\text{TS}_1)=\text{traces}_{\text{AP}}(\text{TS}_2)\]
\end{definition}
\begin{corollary}
    If $\text{TS}_1$ and $\text{TS}_2$ are TS without terminal states and share the same atomic propositions, then:
    \[\text{traces}(\text{TS}_1)=\text{traces}(\text{TS}_2)\] 
    if and only if $\text{TS}_1$ and $\text{TS}_2$ satisfy the same linear time properties. 
\end{corollary}
\noindent Thus, no linear time property can distinguish between trace equivalent TS. 
To prove that two TS are not trace-equivalent, it suffices to find a linear time property that holds for one but not the other.

\subsection{Linear time property taxonomy}
Linear time properties for TS are often expressed using regular properties and finite state automata. 
They are typically classified as invariants, safety properties, and liveness properties.

\subsubsection{Invariant}
\begin{definition}[\textit{Invariant}]
    An invariant is a linear time property where a propositional logic formula $\Phi$ over $\text{AP}$ holds at every step:
    \[P=\left\{A_0A_1A_2\dots\mid A_j\text{ satisfies }\Phi\text{ for all }j\geq 0\right\}\]
\end{definition}
\noindent Verifying an invariant involves checking $\Phi$ in all states reachable from an initial state.
Standard graph traversal algorithms, such as depth-first search or breadth-first search, can efficiently perform this check in linear time relative to the number of states.

\subsubsection{Safety property}
A safety property ensures that a bad event never occurs. 
If an infinite word $\sigma$ violates a safety property, then it must contain a bad prefix $\sigma^\prime$, meaning that any infinite word starting with $\sigma^\prime$ also violates the property.
\begin{definition}[\textit{Safety property}]
    A safety property $P_{\text{safe}}$ is a linear time property over $\text{AP}$ if:
    \[P_{\text{safe}}\cap\left\{\sigma^\prime\in\left(2^{\text{AP}}\right)^\omega\mid\hat{\sigma}\text{ is a finite prefix of }\sigma^\prime\right\}=\varnothing\]
\end{definition}

\subsubsection{Liveness property}
A liveness property ensures that something good eventually happens. 
Unlike safety properties, finite traces provide no information about whether a liveness property holds. 
Instead, every finite prefix must be extendable to an infinite trace that satisfies the property.
\begin{definition}[\textit{Liveness}]
    A liveness property $P_{\text{live}}$ over $\text{AP}$ satisfies: 
    \[\text{pref}(P_{\text{live}})=\left(2^{\text{AP}}\right)^\ast\]
\end{definition}
\noindent This means that every finite word $w$ can be extended to an infinite word $\sigma$ such that $w\sigma\in P$.

\subsection{Decomposition theorem}
Safety and liveness properties are disjoint.
The only linear time property that is both a safety and a liveness property is $\left(2^{\text{AP}}\right)^\omega$. 
\begin{theorem}
    Every linear time property $P$ over $\text{AP}$ can be decomposed into a safety property $P_{\text{safe}}$ and a liveness property $P_{\text{live}}$ such that: 
    \[P=P_{\text{safe}}\cap P_{\text{live}}\]
\end{theorem}