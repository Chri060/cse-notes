\section{Depth testing}

In complex scenes, objects often overlap, necessitating that polygons closer to the observer obscure those behind them.
Failure to draw faces in the correct order, as briefly discussed in the context of 3D normalized screen coordinates, can result in unrealistic visuals.
Maintaining the appropriate visualization order within a set of primitives is known as hidden surfaces elimination.

\paragraph*{Painter algorithm}
When dealing with non-transparent objects, the painter algorithm is commonly employed.
This technique involves drawing primitives in reverse order based on their distance from the projection plane.
Consequently, objects nearer to the viewer overlay those further away.
However, there are scenarios where determining the correct order becomes challenging, rendering the straightforward application of the painter algorithm impractical through mere object sorting.
In such cases, the solution lies in splitting the primitives to facilitate the determination of an appropriate order for the individual pieces.

\subsection{Z-buffer}
The $z$-buffer technique operates at the pixel level, often referred to as depth-testing due to its association with the distance from the projection plane. 
This method relies on a dedicated memory area known as the $z$-buffer or depth-buffer, storing additional information for each pixel on the screen.
Here's how the algorithm works:
\begin{itemize}
    \item All primitives in the scene are drawn, and pixels on the screen are tested for rendering.
    \item For every pixel, both color and distance from the observer are computed.
    \item The $z$-buffer stores the normalized screen $z$-coordinate (distance from the observer) for each pixel.
    \item When a new pixel is written to the same position, its distance from the observer is compared with the value stored in the $z$-buffer.
    \item If the distance of the new pixel is less than the stored value in the $z$-buffer, the new pixel is drawn on screen, and the $z$-buffer value is updated.
    \item If the distance of the new pixel is greater than the stored value in the $z$-buffer, the new pixel is discarded, as it corresponds to an object behind the one already displayed, and no update is performed.
\end{itemize}
While the $z$-buffering technique is straightforward, it requires an additional memory area to store distance information for all pixels.
In Vulkan, programmers must create this memory area, making z-buffer usage more complex compared to other environments. 
Additionally, it necessitates generating pixels for all primitives, even if they are fully obscured by other objects.

The main challenge with $z$-buffering lies in numerical precision. 
Since a significant portion of the [0,1] range of normalized screen $z$-coordinates is used for points near the projection plane, sufficient precision is required to store distances for objects further away. 
Failure to maintain precision may lead to z-fighting, where the final color is determined by the round-off of distances between two nearly co-planar figures.

As normalized screen $z$-coordinates are relative to the near and far planes, these parameters cannot be arbitrarily set small or large. 
They must be chosen appropriately for the specific scene to prevent issues.

\subsection{Stencil buffer}
The stencil buffer technique, akin to the $z$-buffer, serves to restrict drawing within specified regions of the screen. 
Similar to $z$-buffering, it involves storing additional information for each pixel on the screen in a designated memory area known as the stencil buffer.
Here's an overview of stencil buffer functionality:
\begin{itemize}
    \item Stencil buffer usage enables applications to limit drawing to particular areas of the screen.
    \item This technique employs a special memory area, the stencil buffer, to store information for each pixel on the screen.
    \item A common application of the stencil buffer is to define rendering areas of arbitrary shapes, such as reserving space to depict the cabin of a ship or a Head-Up Display (HUD).
    \item More intricate uses of stencil buffers include rendering shadows, reflections, or contours in multi-pass rendering techniques.
    \item The stencil buffer assigns integer information, typically encoded at the bit level, to each pixel on the screen.
    \item During rendering, data from the stencil buffer is utilized to execute specific tasks on corresponding pixels.
\end{itemize}
Typically, the stencil buffer stores a single bit of information for each pixel (1 indicating that the pixel should be drawn, 0 indicating it can be skipped), although more complex functions can be achieved using this technique.