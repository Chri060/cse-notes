\section{Introduction}

Understanding kernel concurrency is crucial for modules to work correctly in multithreaded scenarios.
However, the kernel is not your average user-space multithreaded program:
\begin{itemize}
    \item It includes interrupt handling, spinning waits, reentrancy.
    \item Deadlocks can bring to system freeze or crashes
    \item Must be performant as otherwise the whole system will suffer;
\end{itemize}
The main sources of cocncurrency are: interrupts, multiple processors, and kernel preemption. 

\subsection{Kernel preemption}
With no kernel prrmption only when the kernel has finished working for A the kernel can return to user space process B.
With kernel preemption Upon returning from I0, rather than continuing Process A kernel activities, the kernel preempts it and switches to Process B.
IMAGE 
From 2.6, Linux kernel became optionally preemptive.  
The preemption points are:
\begin{itemize}
    \item At the end of interrupt/exception handling, when \texttt{TIF\_NEED\_RESCHED} flag in the thread descriptor has been set (forced process switch). 
    \item If a task in the kernel explicitly blocks and calls \texttt{schedule} (planned process switch). 
        It is however always assumed that the code that explicitly calls \texttt{schedule} knows it is safe to reschedule.
\end{itemize}

Preemption is unsafe in atomix contexts.
\begin{definition}[\textit{Atomic context}]
    Atomic context refers to the places in the Linux source code where, while it could be possible to admit a preemption it is not safe to do so.
\end{definition}
Typical atomic contexts are when: 
\begin{itemize}
    \item The kernel is within an interrupt handler.
    \item The kernel is holding a spinning lock.
    \item The kernel is modifying the per-cpu structures.
    \item The kernel state cannot restored completely with a context switch (e.g., floating point registers).
\end{itemize}

Consider the following code: 
\begin{verbatim}
struct this_needs_locking tux[NR_CPUS];
tux[smp_processor_id()] = some_value;
// preemption occurs
something = tux[smp_processor_id()];
\end{verbatim}
when a preempted task is finally rescheduled (after line three), the previous value of \texttt{smp\_processor\_id} (at line two) may not equal the one at line four. 
You must protect these situations by disabling preemption around them.








