\section{PRAM analysis}

\begin{lemma}
    Assume $M^\prime < M$. 
    Any problem that can be solved for a $P$-processor and $M$-cell PRAM in $T$ steps can be solved on a $(\max(P, M^\prime))$-processor $M^\prime$-cell PRAM in $O\left(\frac{TM}{M^\prime}\right)$ steps.
\end{lemma}

\begin{proof}
    We can partition the $M$ simulated shared memory cells into $M^\prime$ continuous segments $S_i$ of size $\frac{M}{M^\prime}$ each.
    Each simulating processor $P^\prime_i$ ($1 \leq i \leq P$) will simulate processor $P_i$ of the original PRAM.
    Each simulating processor $P^\prime_i$ ($1 \leq i \leq M^\prime$) stores the initial contents of segment $S_i$ into its local memory and will use $M^\prime[i]$ as an auxiliary memory cell for simulating accesses to cells of $S_i$.
    
    Each $P^\prime_i$ ($i=1, \ldots, \max(P, M^\prime)$) repeats the following for $k = 1, \ldots, \frac{M}{M^\prime}$. 
    Write the value of the $k$-th cell of segment $S_i$ into $M^\prime[i]$ for $i=1, \ldots, M^\prime$.
    Read the value that the simulated processor $P_i$ ($i=1, \ldots, P$) would read in this simulated substep, if it appeared in the shared memory.
    The local computation substep of $P_i$ ($i=1, \ldots, P$) is simulated in one step by $P^\prime_i$.
    The simulation of one original write operation is analogous to that of the read operation.
\end{proof}

\subsection{Implementation}
PRAM serves as a powerful idealized model for designing and analyzing parallel algorithms. 
However, its direct implementation on real hardware poses certain challenges due to its theoretical nature. 
Despite this, PRAM algorithms can be adapted for practical systems, allowing the abstract model to influence real-world designs.

In some cases, PRAM can be implemented directly by translating its concepts to hardware. 
Handling concurrent writes, however, is more complex.
Different strategies are employed based on the specific type of concurrent write model. 

PRAM's common CRCW (Concurrent Read, Concurrent Write) model can be implemented using detect-and-merge techniques, where write conflicts are resolved by merging results. 
Priority CRCW, on the other hand, resolves conflicts by detecting and prioritizing certain writes over others. 
In the arbitrary CRCW model, where conflicts are resolved without a strict rule, the system handles multiple writes in an arbitrary manner.

\subsection{Motivations}
PRAM is an attractive model for parallel computing due to several key factors. 
One major advantage is the large body of algorithms developed specifically for it, offering a rich resource for problem-solving. 
Its simplicity makes it easy to conceptualize, as PRAM abstracts away the complexities of synchronization and communication, allowing a pure focus on algorithm design.

The synchronized shared memory model in PRAM eliminates many of the challenges related to synchronization and communication that arise in practical implementations. 
However, PRAM retains the flexibility to incorporate these issues when necessary, enabling exploration of more complex scenarios.

A notable strength of PRAM is its adaptability. 
Algorithms initially designed for this model can often be converted into asynchronous versions, which are better suited to real-world architectures. 
With support for both synchronized and asynchronous shared memory models, PRAM algorithms can be effectively mapped to various other computational frameworks, providing a versatile foundation for both theoretical and practical advancements in parallel computing.