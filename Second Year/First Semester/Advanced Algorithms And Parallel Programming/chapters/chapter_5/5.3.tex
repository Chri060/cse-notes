\section{Parallelism design}




Design a «good» parallel algorithm by extracting
all the available parallelism is not enough
not all the extracted parallelism is exploitable
on a real architecture
❑ We need to consider which parallelism is available
on the considered architecture
Non suitable parallelism can introduce overhead
❑ We need to «describe» the parallelism to the
compilation tools to make it exploitable

Translation from pseudo-code to high level source
code (e.g., C/C++) is usually quite trivial
❑ All the sequential machine can be modeled as a
von Neumann Architecture
❑ Real processors can differ a lot, but compilers are
usually able to manage this gap and optimize the
application for a given architecture

New programming languages (mainly developed
for research activity):
+Introduced since parallel programming is a
different paradigm
- did not have big success:
• too immature compilers
• you need to learn a new language
❑ Extensions to existing programming language
+can be easily adopted by designer
+can be easily integrated in existing compilers
- can describe only some types of parallelism
(e.g., pipeline parallelism is difficult to be
described)

Designing parallel algorithms is not an easy task
❑ There is not an algorithm to design parallel
algorithms
❑ These are some rules which can help in the design
❑ Design of parallel programs have more specific
rules but they depend on the particular chosen
language/architecture
Most problems have several possible parallel
solutions
❑ A good approach is to start from machineindependent issues (concurrency) and delay
target-specific aspects as much as possible

Parallel Algorithms and Parallel
Programs
1. Design a parallel algorithm:
• Understand the problem to be solved
• Analyze data dependences
• Partition the solution
• PCAM methodology
2. Design a parallel program:
⚫ Analyze the target architecture(s)
⚫ Select best parallel programming language
⚫ Analyze the communications (cost, latency,
bandwidth, visibility, synchronization, etc.)

