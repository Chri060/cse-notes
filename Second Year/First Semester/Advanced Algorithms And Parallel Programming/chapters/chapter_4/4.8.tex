\section{Skip lists}

Skip lists, introduced by William Pugh in 1989, are a randomized, dynamic data structure that maintains a sorted set of elements with efficient average-case operations for search, insertion, and deletion.
They offer a probabilistic time complexity of $\mathcal{O}(\log n)$ for these operations, making them simple to implement yet powerful for dynamic sets where performance is expected rather than strictly guaranteed.

Skip lists improve upon the basic sorted linked list by adding additional linked lists layered above the main list. 
The main list connects all elements, like a standard linked list, while each higher level connects increasingly sparse subsets of elements, allowing faster traversal by skipping over parts of the lower lists.

\subsection{Search}
To search for an element in a skip list:
\begin{enumerate} 
    \item Begin at the highest level list.
    \item Traverse each level by moving right until the target is either found or overshot.
    \item If overshot, drop down to the next level and repeat the process.
    \item Continue this process until reaching the bottom level, where the target element is either located or confirmed absent.
\end{enumerate} 
The higher levels of the skip list serve as express lanes, allowing large jumps, while the lower levels provide finer granularity in search.

\paragraph*{Analysis}
With two levels in the skip list, the search cost is approximately:
\[T(n)=\left\lvert L_1\right\rvert +\dfrac{\left\lvert L_2\right\rvert }{\left\lvert L_1\right\rvert }\]
This is minimized when:
\[T(n)=\left\lvert L_1\right\rvert ^2=\left\lvert L_2\right\rvert =n\implies \left\lvert L_1\right\rvert =\sqrt{n}\]
Resulting in $T(n)=2\sqrt{n}$. 
Generalizing this to $k$ levels gives a cost of $k\sqrt[k]{n}$
With $\log n$ levels, the cost becomes:
\[T(n)=2\log n\]
This efficient layout mimics a balanced binary tree, enabling skip lists to support rapid searching in practice.

\subsection{Insertion}
To insert a new element $x$: 
\begin{enumerate}
    \item Search for $x$'s position in the bottom list.
    \item Insert $x$  into the bottom list, which holds all elements in sorted order.
    \item Randomly promote $x$ to higher levels based on coin flips.
        For each level, $x$ is promoted with a probability of $\frac{1}{2}$, ensuring that, on average, only a small fraction of elements reach the top levels.
        This randomized promotion keeps the structure balanced with $\log n$ expected levels.
\end{enumerate}
The insertion process results in a skip list with a logarithmic number of levels, where the promotion of elements ensures balance across the structure.

\subsection{Implementation}
Skip lists are widely used in practice due to their efficiency, with search operations typically taking average time $\mathcal{O}(\log n)$.
\begin{theorem}
    With high probability, the search time for an $n$-element skip list is $\mathcal{O}(\log n)$.
\end{theorem}
Here, the phrase with high probability signifies that the probability of this time complexity holding is at least $1-\mathcal{O}\left(\frac{1}{n^\alpha}\right)$ for a chosen constant $\alpha\geq 1$. 
By increasing $\alpha$, the likelihood of search times exceeding $\mathcal{O}(\log n)$ can be made arbitrarily low, making this bound practically reliable.
\begin{lemma}
    With high probability, an $n$-element skip list has $\mathcal{O}(\log n)$ levels.
\end{lemma}