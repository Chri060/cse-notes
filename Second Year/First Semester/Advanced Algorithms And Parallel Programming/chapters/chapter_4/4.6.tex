\section{Dictionary problem}

A dictionary is a collection of elements, each associated with a unique search key.
The goal is to maintain the set efficiently while supporting operations such as insertions and deletions.
\renewcommand*{\arraystretch}{2}
\begin{table}[H]
    \centering
    \begin{tabular}{|c|l|} \hline
        \textbf{Operation} & \textbf{Description} \\ \hline
        \textit{Search}($x, S$) & Check if $x \in S$. \\ \hline
        \textit{Insert}($x, S$) & Insert $x$ into $S$ if it is not already present \\ \hline
        \textit{Delete}($x, S$) & Remove $x$ from $S$ if it exists \\ \hline
        \textit{Minimum}($S$) & Return the smallest key in $S$ \\ \hline
        \textit{Maximum}($S$) & Return the largest key in $S$ \\ \hline
        \textit{List}($S$) & Output the elements of $S$ in increasing order of keys \\ \hline
        \textit{Union}($S_1, S_2$) & \makecell[l]{Merge two sets $S_1$ and $S_2$, maintaining the order such that \\ for every $x_1 \in S_1$ and $x_2 \in S_2$, $x_1 < x_2$} \\ \hline
        \textit{Split}($S, x, S_1, S_2$) & \makecell[l]{Split $S$ into two sets $S_1$ and $S_2$, where all elements in \\ $S_1$ are $\leq x$ and all elements in $S_2$ are $> x$} \\ \hline
    \end{tabular}
\end{table}

The basic strutures complexity for the main operations are the following: 
\begin{table}[H]
    \centering
    \begin{tabular}{l|l|l|l|}
    \cline{2-4}
                                                   & \multicolumn{1}{c|}{\textbf{Search}} & \multicolumn{1}{c|}{\textbf{Delete}} & \multicolumn{1}{c|}{\textbf{Insert}} \\ \hline
    \multicolumn{1}{|l|}{\textit{Unordered array}} & $\mathcal{O}(n)$                     & $\mathcal{O}(n)$                     & $\mathcal{O}(1)$                     \\ \hline
    \multicolumn{1}{|l|}{\textit{Ordered array}}   & $\mathcal{O}(\log n)$                & $\mathcal{O}(n)$                     & $\mathcal{O}(n)$                     \\ \hline
    \multicolumn{1}{|l|}{\textit{Trees}}           & $\mathcal{O}(\log n)$                & $\mathcal{O}(\log n)$                & $\mathcal{O}(\log n)$                \\ \hline
    \end{tabular}
\end{table}
\renewcommand*{\arraystretch}{1}
\subsection{Trees}
\paragraph*{Binary Search Tree}
A Binary Search Tree (BST) is a binary tree where each internal node stores an item $(k, e)$ representing a key $k$ and associated element $e$. 
The structure of the tree satisfies the property that: 
\begin{itemize} 
    \item Keys in the left subtree of any node $v\leq k$. 
    \item Keys in the right subtree of $v>k$. 
\end{itemize}
The drawback of the standard BST is that an unbalanced sequence of insertions may degrade it into a linear structure, resulting in poor performance for searches, inserts, and deletes.

\paragraph*{AVL}
An AVL tree is a self-balancing BST where the heights of the two child subtrees of any node differ by at most one. 
Rotations ensure that the height of the tree remains logarithmic. 
While AVL trees guarantee fast lookups and updates, they can be more complex to implement due to the need for maintaining balance factors.

\paragraph*{Splay}
Splay trees are another type of self-adjusting BST.
The key idea is the splay operation, which moves a node accessed via a search or update to the root through rotations. 
This ensures that frequently accessed nodes stay near the root, while infrequently accessed nodes do not contribute much to the overall cost.