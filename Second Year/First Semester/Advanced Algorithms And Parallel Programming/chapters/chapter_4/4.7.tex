\section{Random treaps}

Treaps provide efficient time bounds similar to other balanced search tree structures, without requiring explicit balance information to be maintained. 
The expected number of rotations performed during each operation is small, making them simple to implement. 
Like skip lists, treaps benefit from randomization, providing good performance for search and update operations.

When $n$ elements are inserted in random order into a binary search tree, the expected depth is approximately $1.39 \log n$
The goal of using treaps is to maintain a search tree structure that resembles the one produced if the elements were inserted in order of their randomly assigned priorities.

\begin{definition}[\textit{Treap}]
    A treap is a binary tree where each node contains an element $x$ with a unique key $\text{key}(x) \in U$ and a priority $\text{prio}(x) \in \mathbb{R}$. 
\end{definition}
The tree satisfies the following two properties:
\begin{itemize}
    \item \textit{Search tree property}: for any node $x$, all elements $y$ in the left subtree satisfy $\text{key}(y)<\text{key}(x)$, and all elements $y$ in the right subtree satisfy $\text{key}(y)>\text{key}(x)$.
    \item \textit{Heap property}: for any pair of nodes $x$ and $y$, if $y$ is a child of $x$, then $\text{prio}(y)>\text{prio}(x)$.
\end{itemize}

\begin{lemma}
    Given $n$ elements $x_1, x_2,\dots, x_n$ with keys $\text{key}(x_i)$ and priorities $\text{prio}(x_i)$, there exists a unique treap that satisfies both the search tree property and the heap property.
\end{lemma}

Thus, the structure of the treap is determined by the order of insertion based on the priorities of the elements.

\subsection{Search}
The search operation in a treap is straightforward, following the same logic as in binary search trees. 
The search path is determined by comparing the search key with the keys of the nodes along the path from the root.
\begin{algorithm}[H]
    \caption{Random treaps search}
    \begin{algorithmic}[1]
        \State $v = root$
        \While{$v \neq \text{null}$}
            \If{$\text{key}(v) = k$}
                \State \Return $v$ \Comment Element found
            \EndIf
            \If{$\text{key}(v) < k$}
                \State $v = \Call{rightchild}{v}$
            \EndIf
            \If{$ \text{key}(v) > k$}
                \State $v = \Call{leftchild}{v}$
            \EndIf
        \EndWhile
        \State \Return $\text{null}$ \Comment Element not found
    \end{algorithmic}
\end{algorithm}
The running time of this algorithm depends only on the number of elements along the search path.
Let $x_1, x_2,\dots, x_n$ be elements with sorted keys such that $\text{key}(x_1)<\text{key}(x_2) < \text{key}(x_3)< \dots <\text{key}(x_n)$. 
Let $M$ be a subset of the elements, and define $P_{\min}(M)$ as the element in $M$ with the lowest priority. 
The following lemma describes the relationship between elements based on their priorities.
\begin{lemma}
    For elements $x_1,x_2,\dots,x_n$: 
\end{lemma}
\begin{itemize}
    \item[\textit{a.}] \textit{If $i<m$, then $x_i$ is an ancestor of $x_m$ if and only if $P_{\min}(\{x_i,\dots,x_m\})=x_i$}. 
    \item[\textit{b.}] \textit{If $i>m$, then $x_i$ is an ancestor of $x_m$ if and only if $P_{\min}(\{x_m,\dots,x_i\})=x_i$}. 
\end{itemize}

\begin{definition}[\textit{Harmonic number}]
    The $n$-th harmonic number is defined as:
    \[H_n=\sum_{k=1}^n\dfrac{1}{k}=\ln n + \mathcal{O}(1)\]    
\end{definition}
Let $T$ be a treap with elements $x_1, \dots, x_n$, and let $x_m$ be the element we are searching for.
\begin{lemma}[Succesful search]
    The expected number of nodes on the path to $x_m$ is given by:
    \[H_{m}+H_{n-m+1}-1\]
\end{lemma}
Let $m$ represent the number of keys smaller than the search key $k$.
\begin{lemma}[Unsuccesful search]
    The expected number of nodes on the path during an unsuccessful search is:
    \[H_{m}+H_{n-m}\] 
\end{lemma}

\subsection{Insertion and deletion}
We describe the following algorithms for insertion and deletion in a random treap:
\begin{algorithm}[H]
    \caption{Random treaps insert}
    \begin{algorithmic}[1]
        \State Choose $\text{prio}(x)$
        \State Search for the position of $x$ in the tree
        \State Insert $x$ as a leaf
        \While{$\text{prio}(\text{parent}(x)) > \text{prio}(x)$} \Comment Restore the heap property
            \If{$x$ is left child} 
                \State \text{RotateRight}(\text{parent}($x$))
            \Else 
                \State \text{RotateLeft}(\text{parent}($x$))
            \EndIf
        \EndWhile;
    \end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
    \caption{Random treaps delete}
    \begin{algorithmic}[1]
        \State Find $x$ in the tree
        \While{$x$ is not a leaf} 
            \State $u = \text{child with smaller priority}$
            \If{$u$ is left child} 
                \State RotateRight($x$)
            \Else 
                \State RotateLeft($x$)
            \EndIf
        \EndWhile
        \State Delete $x$
    \end{algorithmic}
\end{algorithm}
The rotations maintain the search tree property and restore the heap property.
\begin{lemma}
    The expected running time of the insert and delete operations is $\mathcal{O}(\log n)$, and the expected number of rotations is 2.
\end{lemma}

\subsection{Other operations}
For a treap $T$ with $n$ elements, we have the following operations:
\begin{itemize}
    \item 
    \item \textit{Minimum}($T$): return the smallest key with a complexity of $\mathcal{O}(\log n)$. 
    \item \textit{Maximum}($T$): return the largest key with a complexity of $\mathcal{O}(\log n)$. 
    \item \textit{List}($T$): output elements in increasing order with a complexity of $\mathcal{O}(n)$.
    \item \textit{Union}($T_1,T_2$): merge $T_1$ and $T_2$ under the condition that:
        \[\text{key}(x_1) < \text{key}(x_2) \qquad\forall x_1 \in T_1,x_2 \in T_2 \]
        The complexity of this operation is $\mathcal{O}(\log n)$. 
    \item \textit{Split}($T,k,T_1,T_2$): split $T$ into $T_1$ and $T_2$ such that: 
        \[\text{key}(x_1) \leq k < \text{key}(x_2)\qquad\forall x_1 \in T_1,x_2 \in T_2\]
        The complexity of this operation is $\mathcal{O}(\log n)$. 
\end{itemize}

\paragraph*{Split}
To split treap $T$ by key $k$:
\begin{enumerate}
    \item Insert a new element $x$ with $\text{key}(x) = k$ and $\text{prio}(x) = -\infty$.
    \item Insert $x$ into $T$.
    \item Delete the new root. The left subtree becomes $T_1$, and the right subtree becomes $T_2$.
\end{enumerate}

\paragraph*{Union}
To merge two treaps $T_1$ and $T_2$:
\begin{enumerate}
    \item Select a key $k$ such that $\text{key}(x_1) < k < \text{key}(x_2)$ for all $x_1 \in T_1$ and $x_2 \in T_2$.
    \item Create a new element $x$ with $\text{key}(x) = k$ and $\text{prio}(x) = -\infty$.
    \item Create a new treap with $x$ as the root, $T_1$ as the left subtree, and $T_2$ as the right subtree.
    \item Delete $x$ from the new treap.
\end{enumerate}
\begin{lemma} 
    The expected running time of the union and split operations is $\mathcal{O}(\log n)$. 
\end{lemma}

\subsection{Implementation}
In treaps, priorities are drawn from the range $[0, 1)$, and are used to maintain the heap property. Below are some key aspects of the priority handling:
\begin{itemize}
    \item \textit{Priorities are only used for comparisons}: When two elements are compared, their priorities determine which node becomes the root of a subtree during operations like insertion and deletion. 
        The element with the smaller (higher) priority moves higher in the tree, maintaining the heap property.
    \item \textit{Handling priority ties}: In the rare case that two elements have equal priorities, a tie-breaking mechanism is employed. 
        Specifically, the priorities are extended by adding random bits, chosen uniformly, to break the tie. 
        This process continues until a difference is found between the corresponding bits, ensuring that ties are resolved without compromising randomness. 
        This guarantees that the heap property is maintained.
\end{itemize}