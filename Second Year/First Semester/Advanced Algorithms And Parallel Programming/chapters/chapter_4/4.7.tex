\section{Treaps}

Treaps are a type of randomized binary search tree that provide efficient time bounds for operations while requiring minimal balance maintenance.
Unlike traditional balanced search trees, treaps rely on randomized priorities to achieve a balanced structure, leading to simplicity and efficiency in implementation.
The structure of a treap resembles the one obtained if elements were inserted in the order of randomly assigned priorities.
\begin{definition}[\textit{Treap}]
    A is a binary search tree where each node contains an element $x$ with a unique key $\text{key}(x) \in U$ and an associated random priority $\text{prio}(x) \in \mathbb{R}$.
\end{definition}
\begin{property}[Search tree]
    For any node $x$, all elements $y$ in the left subtree satisfy $\text{key}(y) < \text{key}(x)$, and all elements $y$ in the right subtree satisfy $\text{key}(y) > \text{key}(x)$.
\end{property}
\begin{property}[Heap]
    For any pair of nodes $x$ and $y$, if $y$ is a child of $x$, then $\text{prio}(y) > \text{prio}(x)$.
\end{property}
\begin{lemma}
    Given $n$ elements with keys $\text{key}(x_i)$ and priorities $\text{prio}(x_i)$, there exists a unique treap that satisfies both the search tree property and the heap property.
\end{lemma}
Thus, the structure of the treap is entirely determined by the insertion order of elements based on their priorities.

\subsection{Search}
Searching in a treap follows the same process as in binary search trees: starting from the root, the search path is determined by comparing the search key with the keys of nodes along the path.
\begin{algorithm}[H]
    \caption{Search}
    \begin{algorithmic}[1]
        \State $v = root$
        \While{$v \neq \text{null}$}
            \If{$\text{key}(v) = k$}
                \State \Return $v$ \Comment Element found
            \EndIf
            \If{$\text{key}(v) < k$}
                \State $v = \Call{rightchild}{v}$
            \EndIf
            \If{$ \text{key}(v) > k$}
                \State $v = \Call{leftchild}{v}$
            \EndIf
        \EndWhile
        \State \Return $\text{null}$ \Comment Element not found
    \end{algorithmic}
\end{algorithm}
The expected time complexity of a search depends on the depth of the path traversed. 
For a treap with $n$ elements, the expected depth is $\mathcal{O}(\log n)$ due to the randomized priorities.

\begin{definition}[\textit{Harmonic number}]
    The $n$-th harmonic number is defined as:
    \[H_n=\sum_{k=1}^n\dfrac{1}{k}=\ln n + \mathcal{O}(1)\]    
\end{definition}
Let $T$ be a treap with elements $x_1, \dots, x_n$, and let $x_m$ be the element we are searching for.
\begin{lemma}[Succesful search]
    The expected number of nodes on the path to $x_m$ is given by:
    \[H_{m}+H_{n-m+1}-1\]
\end{lemma}
Let $m$ represent the number of keys smaller than the search key $k$.
\begin{lemma}[Unsuccesful search]
    The expected number of nodes on the path during an unsuccessful search is:
    \[H_{m}+H_{n-m}\] 
\end{lemma}

\subsection{Insertion and deletion}
Insertion and deletion operations in treaps involve rotating nodes to maintain the heap property.
\begin{algorithm}[H]
    \caption{Insert}
    \begin{algorithmic}[1]
        \State Choose $\text{prio}(x)$
        \State Search for the position of $x$ in the tree
        \State Insert $x$ as a leaf
        \While{$\text{prio}(\text{parent}(x)) > \text{prio}(x)$} \Comment Restore the heap property
            \If{$x$ is left child} 
                \State \text{RotateRight}(\text{parent}($x$))
            \Else 
                \State \text{RotateLeft}(\text{parent}($x$))
            \EndIf
        \EndWhile
    \end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
    \caption{Delete}
    \begin{algorithmic}[1]
        \State Find $x$ in the tree
        \While{$x$ is not a leaf} 
            \State $u = \text{child with smaller priority}$
            \If{$u$ is left child} 
                \State RotateRight($x$)
            \Else 
                \State RotateLeft($x$)
            \EndIf
        \EndWhile
        \State Delete $x$
    \end{algorithmic}
\end{algorithm}
These operations maintain both the search tree property and heap property.
\begin{lemma}
    The expected running time of the insert and delete operations is $\mathcal{O}(\log n)$, with an expected 2 rotations per operation.
\end{lemma}

\subsection{Split and union}
To split treap $T$ by key $k$:
\begin{enumerate}
    \item Insert a new element $x$ with $\text{key}(x) = k$ and $\text{prio}(x) = -\infty$.
    \item Insert $x$ into $T$.
    \item Delete $x$; the left and right subtrees of $x$ become $T_1$ and $T_2$, respectively.
\end{enumerate}

To merge two treaps $T_1$ and $T_2$:
\begin{enumerate}
    \item Select a key $k$ such that $\text{key}(x_1) < k < \text{key}(x_2)$ for all $x_1 \in T_1$ and $x_2 \in T_2$. 
    \item Create a new node $x$ with $\text{key}(x) = k$ and $\text{prio}(x) = -\infty$. 
    \item Set $T_1$ and $T_2$ as the left and right subtrees of $x$, respectively. 
    \item Delete $x$ from the resulting tree.
\end{enumerate}
\begin{lemma} 
    The expected time complexity of both union and split operations is $\mathcal{O}(\log n)$.
\end{lemma}

\subsection{Implementation}
In treaps, priorities are random values drawn from $[0, 1)$, ensuring that tree balancing remains probabilistic rather than explicit.
If two nodes have equal priorities, tie-breaking is achieved by appending uniformly random bits to the priorities until a difference is found. 
This preserves randomness and ensures that the heap property is maintained.