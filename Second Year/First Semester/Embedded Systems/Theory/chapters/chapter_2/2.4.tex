\section{Application specific microprocessors}

Embedded systems need to solve problem with high degree of specialization and with a limited number of functions.
GPP are frequently not the best choice
Specialized architectures have been designed

\subsection{Digital Signal Processors}
DSP are the popular one dedicated processors
They can vary a lot among the producers, but they have in common the design tailored to perform numerical computing. 
To understand their structure, let's review the main operations used in the algorithm for numeric processing
Widely used operation
\[z_{t+1} = z_t + x \cdot y\]
It is so important for DSP to worth a specific name, MAC : Multiply Accumulate
A valuable DSP architecture should optimized as much as possible the sum and mul operation, possibly by exploiting a single 3-operand instruction

Given the nature of the operations, a relevant part of the
algorithms to be executed, contains loops
– The possibility to optimize loops in a DSP is possible, since
• The body is typically small (~10 asm instructions)
• The control loop variable is not altered within the loop body
• The update of the control loop variable is simple
• The pattern to access the vector is generally regular and simple
– Specific Hw to optimize loops
• Circular buffer to store the loop body
• Dedicated register where to store the control loop variable
• Add/Sub to perform inc/dec operation without using ALU

Access to the data in memory could be a bottleneck
• High bandwidth interfaces are designed to this purpose
– Memory hierarchy for DSP
• High speed bus with word width up to 256 bits
• Multi-level cache hierarchy
– Classic
» Stanford: unified for data and instructions
– Specialised
» Harvard: cache L0 separate for data and instructions
» SHARC: Three L0 caches for data, instructions and constants

n addition to the flexibility and computing power offered by the
special instructions and by the specific ALUs, modern DSPs are
frequently organized by following a VLIW approach
– In fact, it is suitable for numerical applications, where the control
is limited and there exists a high intrinsic parallelisms of
operation

\subsection{Network Processors}
Dedicated architectures tailored to process network packets
Complex system-on-chip with high parallelism, for network applications (e.g. routers)
Functionalities and protocols are evolving, the design of a NP is not trivial
Classes of the typical operations of a NP
• Buffering of input/output packets
• Remove/add of header at the level of data-link
• Search for a specific field in an IP header
• Search for an address in a lookup table
• Computation of CRC codes
• Send or delete of packets

To increase performance, dedicated hw is used
• Fast I/O interfaces, queue management, cripto-cores, multi RISC
cores
– Frequently packet processing application requires the
management of several independent channels who can benefit
from parallel processing
– Each channels is managed by a dedicated hw units frequently
named as PP (Packet Processor) or CP (Channel Processor)

When the separate flows and not fully disjoint
• Use of RISC cores, to supervise and for high-level management
– The typical structure of an application of packet processing is a
set of simple routines, each working on a huge amount of
packets
• Small programs working on a enormous amount of data

Which type of programming?
• Core RISC
RISC
– Development of programs starting from C source code like that of a
• Single PP
– Sometime is still carried out in assembly, bunch of simple routines
» Programming CP is not well structured and only some time we can use a
functional approach based on pattern recognition

\subsection{Summary}
(MCU – Micro Controller Unit) is a class of microprocessor
integrating peripherals and interfaces on a single-chip
– Their SoC nature is fine to deal with not top computing power,
but with application having constraints on the use of hw
resources and development time
Frequently there is no interface to external memory
• Programs for MCU are typically small
• Memory interface increases the pinout
– Small size in frequently a strict requirement
• To provide a memory interface limiting the pinout, some
architectures use a multiplexing of the I/O ports
– The control logic must be properly configured to exploit this operating
mode
The architectures offer several peripheral and interfaces
• I2C, SPI, CAN, JTAG, PWM, UART/USART, watchdog, timer,
analog I/O and comparators, etc…
– Programming in typically in C, only sometime in assembly
– SDKs for microcontrollers ranges from simple C compiler up to
integrated framework for performance analysis and configuration
management