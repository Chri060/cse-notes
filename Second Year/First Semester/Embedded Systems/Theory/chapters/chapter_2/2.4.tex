\section{System boot}

\begin{definition}[\textit{System boot}]
    System boot refers to the sequence of steps that transitions a system from a powered-off state to a fully operational state.
\end{definition}
The complexity of the system boot process can vary depending on the type of system involved, as it requires the coordination of both hardware and software components.
These components typically include the hardware platform, the microcontroller or microprocessor, the BIOS, the bootloader, the operating system, and the application layer.

A critical phase within this sequence is the point when the BIOS begins execution.
At this moment, the hardware initialization has completed, and the first instruction of the system firmware is executed.

\subsection{Microcontroller boot sequence}
we consider a typical system with a microcontroller, flash memory to store the binary executable, and RAM to hold data during execution. 
We assume the binary contains the complete code required for operation.
In our case, the code is executed directly from flash memory. 
The scenario where code is executed from RAM, which is common in general-purpose microprocessor-based or larger embedded systems, follows a similar process.

Flash memory is typically organized into different sections, including:
\begin{itemize}
    \item \textit{Text}: stores the executable code.
        Here, we have three logically distinct types of information:
        \begin{enumerate}
            \item \textit{Interrupt Vector Table} (IVT): a fixed-size table that contains the initial stack pointer, the address of the reset handler, and the addresses of the interrupt service routines.
            \item \textit{Startup code}: a small portion of assembly code (usually provided by microcontroller vendor) responsible for initializing the system.
            \item \textit{Application code}: the main executable code of the application.
        \end{enumerate}
    \item \textit{Rodata}: holds constants.
    \item \textit{Data}: contains initialized variables.
    \item \textit{Bss}: holds uninitialized variables.
\end{itemize}

\paragraph*{Boot process}
When the microcontroller exits the reset state, it begins by loading the program counter with the address from the second entry in the IVT, which points to the reset handler. 
The microcontroller then starts executing the code at this address.
In more general cases, the location of the IVT base may not be fixed but is stored in a specific register in the microcontroller.
While the exact position of the reset handler in the table may vary by microcontroller model, having it as the second entry is quite common.

Once the reset handler begins execution, it performs the following key operations:
\begin{enumerate}
    \item \textit{Stack pointer initialization}: it loads the initial stack pointer address into the stack pointer register.
        From this point on, the stack is operational, allowing functions to be called.
    \item \textit{System initialization}: the reset handler invokes a system initialization function, which usually sets up the system's clocks and waits for the PLL to stabilize.
    \item \textit{Memory preparation}: the memory is prepared by: copying the data section from flash to RAM (based on linkler directives), and zeroing out the bss section in RAM.
    \item \textit{Jump to} \texttt{main}: the reset handler jumps to the \texttt{main} function, which serves as the entry point for the application or the application combined with the OS. 
        This jump is not a function call, meaning execution transfers directly to main without returning to the reset handler.
\end{enumerate}

\subsection{Bootloader}
A bootloader is essential for firmware updates in embedded systems. 
Unlike typical development environments where the application is loaded into the microcontroller's flash memory using a programmer, the bootloader allows the system to update its firmware in the field without external programming tools.
The bootloader is a small program designed to handle three main tasks:
\begin{itemize}
    \item \textit{Receiving a firmware binary}: the bootloader obtains the new firmware through a communication interface.
    \item \textit{Writing the firmware to flash memory}: the new firmware is written into flash, replacing the old version, often after validating its integrity.
    \item \textit{Executing the updated firmware}: once the new firmware is successfully loaded, the bootloader transfers control to the new application.
\end{itemize}
When a bootloader is present, it is the first software to execute upon system startup. 
It occupies its own dedicated area in flash memory, coexisting with the main firmware. 
However, the bootloader and the application each maintain separate IVTs, which is crucial for switching between the two. 
The bootloader's IVT is located at the default address, and its role ends once it successfully transfers control to the new firmware.

Suppose that the bootloader has already perfromed the firmware update. 
At this point, the bootloader must hand over control to the new firmware. 
This involves switching to the application's IVT and starting the new firmware execution. 
How this is done depends on whether the microcontroller has an IVT offset register: 
\begin{itemize}
    \item \textit{With IVT offset register}: first, it prepares for the handover by disabling all interrupts and clearing any pending ones. 
        This is crucial to prevent any interrupt from being serviced using the bootloader's IVT while the bootloader itself is still executing. 
        The system must also ensure that all memory operations are fully completed before proceeding, to avoid any issues with uncommitted data.
        Once these preparatory steps are completed, the bootloader executes the new firmware by updating the IVT offset register with the address of the new IVT. 
        The stack pointer is then loaded with the value found in this updated IVT, ensuring the system is ready to handle interrupts and function calls as intended by the new firmware. 
        Finally, control is transferred by jumping to the reset handler address specified in the new IVT, which starts the execution of the new firmware.
    \item \textit{Without IVT offset register}: in systems lacking an IVT offset register, the IVT may be stored at two fixed addresses: one in flash memory and the other in RAM. 
        Typically, the bootloader operates with its IVT in flash. 
        Here, the bootloader begins by disabling all interrupts and clearing any pending ones.
        The next step is to copy the new IVT from flash memory to RAM, as this will be the new location for interrupt handling during the firmware's operation.
        To execute the new firmware, the bootloader enables memory remapping, which switches the system to use the newly copied IVT in RAM. 
        The stack pointer is then loaded from the new IVT, ensuring the system is properly configured for the upcoming firmware execution. 
        Finally, the bootloader jumps to the reset handler in the new IVT, thereby initiating the execution of the new firmware.
\end{itemize}