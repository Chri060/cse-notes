\section{Documental database}

In traditional relational databases, data is distributed across multiple tables. 
However, in business applications, it is often beneficial to structure the data into a single, cohesive document that pulls together relevant information from various sources. 
This approach provides a more intuitive representation of the data, simplifying query processes by avoiding the need to join multiple tables. 
Additionally, document-oriented databases are highly flexible, allowing for the easy addition of attributes, which makes handling schema changes much more straightforward. 
The document model also closely aligns with object-oriented programming paradigms, effectively resolving the impedance mismatch problem that arises when trying to map objects to relational tables.

\subsection{MongoDB}
MongoDB is a widely-used, open-source, document-oriented database. 
It stores data in flexible, JSON-like documents, offering developers agility and scalability. With MongoDB, the schema is dynamic, allowing for flexible and evolving data models. 
Furthermore, it supports automatic data sharding, enabling seamless horizontal scaling.
Key advantages of MongoDB include: 
\begin{itemize} 
    \item \textit{General-purpose}: MongoDB offers a rich data model, full-featured indexes, and a sophisticated query language that can handle a wide variety of use cases. 
    \item \textit{Ease of use}: its structure allows for an easy mapping to object-oriented code, with native drivers for popular programming languages. 
        The setup and management process is simple and developer-friendly. 
    \item \textit{Performance and scalability}: MongoDB operates at in-memory speed whenever possible, and its built-in auto-sharding ensures smooth scaling without downtime. 
        Developers can dynamically add or remove capacity as needed. 
\end{itemize}

\paragraph*{Security features} 
SSL encryption between client and server, and intra-cluster communication. 
Fine-grained authorization controls at the database level, supporting read-only, read and write, and administrative roles.

\paragraph*{MongoDB processes}
MongoDB operates with three core processes:
\begin{itemize}
    \item \textit{Mongod}: this is the primary process that runs the MongoDB database instance. 
        It handles all the database operations, data storage, and query processing.
    \item \item \textit{Mongos}: Responsible for managing the sharding architecture, mongos acts as a query router. 
    It directs client requests to the appropriate mongod instances based on the sharding configuration. 
        You can deploy either a single mongos for the entire system or multiple mongos instances (e.g., one per client) to reduce network latency and improve performance.
    \item \textit{Mongo}: this is an interactive command-line shell used by clients to interact with MongoDB, perform queries, administrative tasks, and more.
\end{itemize}

\paragraph*{Sharding}
Sharding is MongoDB's method for partitioning large datasets across multiple servers to achieve horizontal scaling, optimize performance, and provide resilience.
Key features of MongoDB sharding are:
\begin{itemize} 
    \item \textit{Scale}: Designed to handle the massive workloads of modern applications, ensuring scalability as data volume grows. 
    \item \textit{Geo-locality}: Allows geographically distributed deployments, optimizing user experience across different regions. 
    \item \textit{Hardware optimization}: Enables fine-tuning performance versus cost by distributing data intelligently across available resources. 
    \item \textit{Lower recovery times}: Facilitates faster recovery during failures, supporting stringent Recovery Time Objectives (RTO). 
\end{itemize}
A shard key is defined by the data modeler and determines how MongoDB partitions data across shards. 
The data is divided into chunks based on this key, which are then evenly distributed across the available shards on different physical servers.
The sharding unfolds in the following steps:
\begin{itemize} 
    \item Initially, the system starts with a single chunk, but as the dataset grows, MongoDB automatically splits and migrates chunks to ensure balanced distribution across shards. 
        The default maximum chunk size is 64MB. 
    \item MongoDB routes queries directly to the appropriate shard(s), reducing query overhead. 
    \item A config server stores information about the shard ranges and their locations. 
        In production environments, it is recommended to have three config servers to ensure high availability. 
\end{itemize}
The sharding can be: 
\begin{itemize}
    \item \textit{Range}: data is partitioned based on a continuous range of shard keys (e.g., \{deviceId\}). Composite keys are also supported (e.g., \{deviceId, timestamp\}).
    \item \textit{Hash}: MongoDB applies an MD5 hash to the shard key, ensuring that data is randomly distributed across the available shards. 
        This technique minimizes hotspots and ensures even distribution.
    \item \textit{Tag}: this method allows specific shards to be tagged with labels, ensuring that certain data subsets (e.g., users from a specific region) are stored on a designated group of shards. 
        This is particularly useful for optimizing geo-locality.
\end{itemize}
\begin{table}[!ht]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Usage} & \textbf{Required strategy} \\ \hline
        Scale & Range or hash \\ \hline
        Geo-locality & Tag-aware \\ \hline
        Hardware optimization & Tag-aware \\ \hline
        Lower recovery times & Range or hash \\ \hline
    \end{tabular}
\end{table}
MongoDB focuses on consistency and partition tolerance. 

\subsection{Data model}
MongoDB stores data in JSON format, which is ideal for web applications due to its readability and flexibility. 
JSON structures can be easily adapted to various needs, and MongoDB's dynamic schema approach means that new fields can be added without requiring changes to the existing schema.
Key features of the MongoDB data model: 
\begin{itemize} 
    \item MongoDB keeps frequently accessed data in memory to optimize performance. 
    \item It is highly horizontally scalable, allowing servers to be added as needed. 
    \item MongoDB organizes data in contiguous regions for better locality and access speed.
\end{itemize}
Although MongoDB lacks traditional database features such as schemas, transactions, and joins, it is highly optimized for modern application development. 
Large documents can be stored using GridFS, and the maximum document size is 16MB.

\paragraph*{Binary JSON} 
MongoDB uses BSON, a binary representation of JSON documents, to improve speed and efficiency. 
BSON supports more data types than JSON, including date and byte array types, while optimizing space and serialization speed. 
Each document must have a unique identifier, which MongoDB can automatically generate if not provided.
MongoDB also allows for embedding multiple documents within a single document, which simplifies data retrieval and reduces the need for complex joins.

\subsection{Query language}
MongoDB allow to perform the CRUD operations: 
\begin{itemize}
    \item \textit{Create}: we can create an entire database: 
        \begin{verbatim}
use database_name
        \end{verbatim}
        We may create a collection: 
        \begin{verbatim}
db.createCollection(name, options)
        \end{verbatim}
        And also inser a new document: 
        \begin{verbatim}
db.<collection_name>.insert()
        \end{verbatim}
    \item \textit{Read}: we can query for all elements: 
        \begin{verbatim}
db.<collection_name>.find().pretty()
        \end{verbatim}
        With the \texttt{find} function we can insert some filters. 

        We can also aggregate documens, by pipelining documents from a collection through an aggregation pipeline. 
        Expressions produce output documents based on calculations performed on input documents: 
        \begin{verbatim}
db.parts.aggregate()
        \end{verbatim}
    \item \textit{Update}: the general command to update documents is: 
        \begin{verbatim}
db.<collection_name>.update(<select_criteria>,<updated_data>)
        \end{verbatim}
        We can also use the save method to replace an already existsing document: 
        \begin{verbatim}
db.students.save()
        \end{verbatim}
    \item \textit{Delete}: we can drop a database: 
        \begin{verbatim}
db.dropDatabase()
        \end{verbatim}
        We can drop a collection or a document: 
        \begin{verbatim}
db.<collection_name>.drop()
db.<collection_name>.remove(options)
        \end{verbatim}
\end{itemize}