\documentclass[paper=a4, fontsize=11pt]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage{fourier}
\usepackage[english]{babel}															
\usepackage[protrusion=true,expansion=true]{microtype}	
\usepackage{amsmath,amsfonts,amsthm} 
\usepackage[pdftex]{graphicx}	
\usepackage{url}
\usepackage{sectsty}
\allsectionsfont{\centering \normalfont\scshape}
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead{}											
\fancyfoot[L]{}											
\fancyfoot[C]{}											
\fancyfoot[R]{\thepage}									
\renewcommand{\headrulewidth}{0pt}			
\renewcommand{\footrulewidth}{0pt}				
\setlength{\headheight}{13.6pt}
\numberwithin{equation}{section}		
\numberwithin{figure}{section}			
\numberwithin{table}{section}			
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 	

\title{
		\vspace{-1in} 	
		\usefont{OT1}{bch}{b}{n}
		\normalfont \normalsize \textsc{Advanced Algorithms And Parallel Programmming} \\ [25pt]
		\horrule{0.5pt} \\[0.4cm]
		\huge Selection algorithms challenge \\
		\horrule{2pt} \\[0.5cm]
}
\author{
		\normalfont 								\normalsize
        Christian Rossi (10736464) - Kirolos Shroubim (10719510) - Antonio Sulfaro (10742266)\\[-3pt]		\normalsize
        \today
}
\date{}


\begin{document}
    \maketitle

    \section{Selection problem}
    The selection problem involves finding the $k$-th smallest or largest element in an unsorted array or list of numbers.
    The goal is to determine the $k$-th order statistic (i.e., the $k$-th smallest or largest element) efficiently, without necessarily sorting the entire array.

    In this work, we will implement two algorithms for solving the selection problem: the Median of Medians (standard version) and Quickselect (randomized version).

    \section{Experimental setup}
    To evaluate the performance of both Quickselect and Median of Medians of the algorithms, we implemented them in C.
    In the file \texttt{ith\_element.c}, two functions are defined for each version: \texttt{getIthElement} for Median of Medians and \texttt{getIthElementRand} for Quickselect. 

    For testing, we utilized the Google Test framework to verify the correctness of both implementations.
    We designed common test cases for both algorithms, which include arrays with negative numbers, ordered and unordered arrays, and cases that select the smallest, largest, and median elements.
    Additionally, we included arrays with repeated elements to ensure robustness.

    For benchmarking, we employed the Google Benchmark library to measure the time complexity of the algorithms.
    We generated random arrays of increasing sizes to compare the performance of both versions.
    The benchmarks take two arguments: the size of the randomly generated array and the index of the element to be selected.
    All test arrays may contain repeated elements to simulate real-world scenarios.

    \section{Performance measurment}
    Since our benchmarks use random array initialization, we run the tests multiple times to ensure accurate results and minimize errors.
    The benchmarks include two versions: one with unordered arrays and another with pre-sorted arrays.

    \paragraph{Unordered arrays}
    We first analyze the performance of both algorithms on unordered arrays.
    Theoretically, we expect Quickselect to be faster on average compared to Median of Medians.
    Our experimental results are as follows:
    \begin{table}[h!]
        \centering
        \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Version}  & \textbf{Average complexity found with benchmark} & \textbf{Temporal complexity}      \\ \hline
        \textit{Standard} & $T(n) \approx 100n$                                   & $\mathcal{O}(n)$             \\
        \textit{Random}   & $T(n) \approx 35n$                                    & $\mathcal{O}(n)$             \\ \hline
        \end{tabular}
        \caption{Ordered array benchmarks}
    \end{table}
    
    As shown, both algorithms exhibit linear time complexity, but Quickselect has a significantly smaller constant factor, making it faster in practice ($35n$ vs. $100n$).

    \paragraph{Ordered arrays}
    Next, we consider the case of pre-sorted arrays.
    In this scenario, we expect Quickselect to still outperform Median of Medians.
    Note that for sorted arrays, the task simplifies to returning the $i$-th element directly.
    The results are as follows:
    \begin{table}[h!]
        \centering
        \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Version}  & \textbf{Average complexity found with benchmark} & \textbf{Temporal complexity}      \\ \hline
        \textit{Standard} & $T(n) \approx 50n$                                   & $\mathcal{O}(n)$             \\
        \textit{Random}   & $T(n) \approx 5500$                                  & $\mathcal{O}(1)$             \\ \hline
        \end{tabular}
        \caption{Unordered array benchmarks}
    \end{table}
    
    As expected, both algorithms perform better than in the unordered case, with Quickselect achieving constant time complexity due to the simplicity of directly returning the element.

    \section{Design choices}
    Median of Medians is implemented using the \texttt{getIthElement} function. 
    This function iteratively calls \texttt{select}, which repeatedly selects elements until the correct index is found.
    The \texttt{select} function relies on two helper functions: \texttt{partition} and \texttt{partition5}.
    The \texttt{partition} function divides the array into two parts, while \texttt{partition5} handles sub-arrays of five elements.

    In this algorithm, the array is divided into groups of five. 
    The median of each group is found, and then the medians of these groups are recursively used to find a pivot. 
    We chose groups of five because smaller groups provide too little information, while larger groups would require more sorting, reducing efficiency.

    For Quickselect, we skip the process of dividing the array into groups and simply select the pivot randomly from the entire array.

    The key difference between the two approaches is that the randomized version does not require sorting small groups, making it more efficient on average.
    However, once the pivot is chosen, both algorithms proceed similarly, as the randomized version also uses the same \texttt{partition} function from the standard algorithm.
\end{document}