\section{NoSQL Databases}

NoSQL databases are designed to offer greater flexibility and scalability, making them well-suited for dynamic data structures in modern applications. 
Unlike traditional relational databases that rely on fixed schemas, NoSQL databases often operate without an explicit schema, or they use flexible schemas that can evolve over time. 
This adaptability allows them to accommodate various types of data, including unstructured and semi-structured formats such as JSON, XML, or key-value pairs.

The lack of a rigid schema enables NoSQL databases to manage large-scale, constantly changing datasets efficiently. 
This characteristic makes them ideal for applications where data formats are unpredictable or subject to frequent changes, such as social media platforms, IoT systems, and real-time analytics.

\paragraph*{Paradigmatic shift}
The rise of Big Data has led to a fundamental shift in how databases are designed and used. 
Traditional databases typically follow a schema on write approach, where a well-defined schema must be agreed upon before data can be stored. 
This model is limiting in fast-changing environments where the data structure may not be fully known at the time of ingestion, resulting in the potential loss of valuable information.
NoSQL databases adopt a schema on read approach, allowing data to be ingested without predefined structure. 
The minimal schema necessary for analysis is applied only when the data is read or queried. 
This flexibility allows for more comprehensive data retention and analysis, enabling new types of queries and insights to be derived as the requirements evolve.

\paragraph*{Object-Relational Mapping}
In traditional databases, Object-Relational Mapping (ORM) is used to bridge the gap between object-oriented programming languages and relational databases, a problem known as the impedance mismatch.
Despite the existence of ORM solutions, this process is often complex and can hinder performance and flexibility. 
NoSQL databases, particularly object-oriented and document-based databases, can eliminate or reduce the impedance mismatch by storing data in formats that align more naturally with the objects in application code. 
While early object-oriented database systems were commercially unsuccessful, modern NoSQL systems provide a more pragmatic solution to these challenges.

\paragraph*{Data lake}
NoSQL databases often serve as the backbone of data lakes, where raw, unstructured, and structured data is stored in its native format. 
Data lakes are designed to allow for future analysis, without requiring immediate transformation into a rigid schema, making them highly compatible with NoSQL databases.

\paragraph*{Scalability}
Traditional SQL databases scale vertically, meaning performance improvements come from upgrading to more powerful hardware with better memory, processing power, or storage capacity. 
However, vertical scaling has physical and financial limits, and adding data to a traditional SQL system can degrade its performance over time.
In contrast, NoSQL databases are designed to scale horizontally. 
This means that when the system needs more capacity, additional machines (nodes) can be added to the cluster, allowing the database to distribute both data and computational load across multiple nodes. 
This architecture is especially effective for handling the vast datasets and high-throughput demands characteristic of Big Data applications.

\subsection{CAP theorem}
The CAP theorem highlights the trade-offs inherent in distributed systems.
\begin{theorem}
A distributed system cannot simultaneously guarantee all three of the following properties:
\end{theorem}
\begin{itemize}
    \item \textit{Consistency: all nodes see the same data at the same time.}
    \item \textit{Availability: every request receives a response, whether it is successful or not.}
    \item \textit{Partition tolerance: the system continues to operate even if communication between nodes is interrupted due to network failures.}
\end{itemize}
NoSQL databases typically sacrifice either consistency or availability, depending on the specific use case. 
Systems can be categorized as:
\begin{itemize}
    \item \textit{CP} (Consistency, Partition tolerance): prioritize data correctness at the cost of availability during network failures.
    \item \textit{AP} (Availability, Partition tolerance): prioritize availability, potentially returning stale or outdated data during partition events.
\end{itemize}
Understanding this trade-off is crucial for designing systems that balance performance, reliability, and scalability based on specific application requirements.

\paragraph*{BASE properties}
While traditional databases follow the ACID (Atomicity, Consistency, Isolation, Durability) principles, many NoSQL databases adhere to the BASE model:
\begin{itemize}
    \item \textit{Basically Available}: the system guarantees availability, even if data is not fully consistent.
    \item \textit{Soft state}: the state of the system may change over time, even without input (due to eventual consistency).
    \item \textit{Eventual consistency}: The system will eventually become consistent, but intermediate states may be inconsistent.
\end{itemize}
This model is particularly useful in environments where high availability and scalability are prioritized over strict consistency, such as in distributed systems that can tolerate temporary inconsistencies.

\subsection{NoSQL history}
NoSQL databases have a rich history, beginning as early as the 1960s. 
xKey milestones include:
\begin{itemize}
    \item 1965: multiValue databases developed by TRW.
    \item 1979: AT\&T releases DBM, an early precursor to NoSQL systems.
    \item 2000s: modern NoSQL databases emerge, including Google BigTable (2004), CouchDB (2005), Amazon Dynamo (2007), and MongoDB (2009).
    \item 2009: the term NoSQL is reintroduced to describe a new generation of non-relational databases optimized for scalability and flexibility.
\end{itemize}

\subsection{NoSQL taxonomy}
NoSQL databases can be categorized into several types:
\begin{itemize}
    \item \textit{Key-value stores}: data is stored as key-value pairs. 
        Examples include Redis and Azure Table Storage.
    \item \textit{Column stores}: data is stored in columns, making them highly efficient for analytical queries. 
        Examples include Cassandra and Hadoop.
    \item \textit{Document stores}: these databases store data as documents, often in formats like JSON or BSON. 
        Examples include MongoDB and CouchDB.
    \item \textit{Graph databases}: these databases represent data in terms of nodes and relationships (edges), ideal for complex relationship mapping. 
        An example is Neo4j.
\end{itemize}
Each type of NoSQL database has its strengths and is designed to meet different kinds of scalability, flexibility, and performance needs.