\section{Relational databases}

The design levels of a database are the following: 
\begin{itemize}
    \item \textit{Conceptual database design}: constructing an information model, independent from all physical consideration for an enterprise.
        In entity relationship databases we have: entities, relationships, attributes, attribute domain, and key attributes. 
    \item \textit{Logical database design}: building an organization database based on a specific data model
    \item \textit{Physical database design}: implementing a database using specific data storage structure(s) and access methods,
\end{itemize}

\subsection{Model characteristics}
In entity-relationship database models, key components include entities and relationships. 
An entity represents a distinct real-world object that can be differentiated from others, characterized by a set of attributes. 
These entities are grouped into an entity set, which consists of similar entities that share the same attributes. 
Each entity set is identified by a unique key made up of a set of attributes, and each attribute has a defined domain.

Relationships are associations among two or more entities. A relationship set is a collection of similar relationships, where an n-ary relationship set $R$ connects $n$ entity sets $E_1,\dots,E_n$. 
Each relationship in this set involves entities from the corresponding entity sets. 
Notably, the same entity set can participate in different relationship sets or assume various roles within the same set. 
Additionally, relationship sets can have descriptive attributes. 
Uniquely, a relationship is defined by the participating entities without relying on descriptive attributes, while the cardinality indicates the number of potential connections between the entities. 
ISA hierarchies can further enhance the model by adding descriptive attributes specific to subclasses.

Aggregation comes into play when modeling a relationship that involves both entity sets and a relationship set. 
This technique allows us to treat a relationship set as an entity set, facilitating its participation in other relationships.

\paragraph*{Conceptual design}
Crucial design choices involve determining whether a concept should be modeled as an entity or an attribute, and deciding if it should be represented as an entity or a relationship.
It is essential to identify the nature of relationships, considering whether they are binary or ternary, and whether aggregation is appropriate.
In the ER model, it is important to capture a significant amount of data semantics. 
However, some constraints cannot be represented within ER diagrams.

\section{Relational databases}
The SQL standard was first proposed by E. F. Codd in 1970 and became available in commercial DBMSs in 1981. It is based on a variant of the mathematical notion of a relation. 
Relations are naturally represented by means of tables.

Given $n$ sets $D_1, D_2, \dots, D_n$, which are not necessarily distinct:
\begin{definition}[\textit{Cartesian product}]
    The Cartesian product on $D_1, D_2, \dots, D_n$, denoted as $D_1 \times D_2 \times \dots \times D_n$, is the set of all ordered $n$-tuples $(d_1, d_2, \dots, d_n)$ such that $d_1 \in D_1, d_2 \in D_2, \dots, d_n \in D_n$. 
\end{definition}
\begin{definition}[\textit{Mathematical relation}]
    A mathematical relation on $D_1, D_2, \dots, D_n$ is a subset of the Cartesian product $D_1 \times D_2 \times \dots \times D_n$. 
\end{definition}
\begin{definition}[\textit{Relation domains}]
    The sets $D_1, D_2, \dots, D_n$ are called the domains of the relation.
\end{definition}
\begin{definition}[\textit{Relation degree}]
    The number $n$ is referred to as the degree of the relation.
\end{definition}
\begin{definition}[\textit{Cardinality}]
    The number of $n$-tuples is called the cardinality of the relation.
\end{definition}
In practice, cardinality is always finite.
\begin{definition}[\textit{Ordered set}]
    A mathematical relation is a set of ordered $n$-tuples $(d_1, d_2, \dots, d_n)$ such that $d_1 \in D_1, d_2 \in D_2, \dots, d_n \in D_n$, where:
    \begin{itemize}
        \item There is no specific ordering between $n$-tuples.
        \item The $n$-tuples are distinct from one another.
    \end{itemize}
\end{definition}
The $n$-tuples are ordered internally: the $i$-th value comes from the $i$-th domain.
\begin{example}
    Consider a simple mathematical relation:
    \[\text{game} \subseteq \text{string} \times \text{string} \times \text{integer} \times \text{integer}\]
    For instance:
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|c|c|}
        \hline
        Juve & Lazio & 3 & 1 \\ \hline
        Lazio & Milan & 2 & 0 \\ \hline
        Juve & Roma  & 1 & 2 \\ \hline
        Roma  & Milan & 0 & 1 \\ \hline
        \end{tabular}
    \end{table}
    Each of the domains has two roles, which are distinguished by their position. 
    The structure is positional.
    
    We can move towards a non-positional structure by associating a unique name (attribute) with each domain, which describes the role of the domain. 
    For instance:
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{Home team} & \textbf{Visiting team} & \textbf{Home goals} & \textbf{Visitor goals} \\ \hline
        Juve & Lazio & 3 & 1 \\ \hline
        Lazio & Milan & 2 & 0 \\ \hline
        Juve & Roma  & 1 & 2 \\ \hline
        Roma  & Milan & 0 & 1 \\ \hline
        \end{tabular}
    \end{table}
\end{example}
\begin{definition}[\textit{Relation schema}]
    A relation schema consists of a name (of the relation) $R$ with a set of attributes $A_1, \dots, A_n$:
    \[R(A_1, \dots, A_n)\]
\end{definition}
\begin{definition}[\textit{Database schema}]
    A database schema is a set of relation schemas with different names: 
    \[R = \{R_1(X_1), \dots, R_n(X_n)\}\]
\end{definition}
\begin{definition}[\textit{Instance of a relation}]
    A relation instance on a schema $R(X)$ is a set $r$ of tuples on $X$.
\end{definition}
\begin{definition}[\textit{Instance of a database}]
    A database instance on a schema $R = \{R_1(X_1), \dots, R_n(X_n)\}$ is a set of relations $r = \{r_1, \dots, r_n\}$, where $r_i$ is a relation on $R_i$.
\end{definition}
The relational model imposes a rigid structure on data:
\begin{itemize}
    \item Information is represented by tuples.
    \item Tuples must conform to relation schemas.
\end{itemize}
There are at least three types of null values:
\begin{itemize}
    \item \textit{Unknown value}: there is a domain value, but it is not known.
    \item \textit{Non-existent value}: the attribute is not applicable for the tuple.
    \item \textit{No-information value}: we don'â€™'t know whether a value exists or not (logical disjunction of the above two).
\end{itemize}
DBMSs typically do not distinguish between these types of nulls and implicitly adopt the no-information value.

An integrity constraint is a property that must be satisfied by all meaningful database instances. 
It can be seen as a predicate: a database instance is legal if it satisfies all integrity constraints. 
Types of constraints include:
\begin{itemize}
    \item Intrarelational constraints (e.g., domain constraints, tuple constraints).
    \item Interrelational constraints.
\end{itemize}

\begin{definition}[\textit{Key}]
    A key is a set of attributes that uniquely identifies tuples in a relation.
\end{definition}
A set of attributes $K$ is a superkey for a relation $r$ if $r$ does not contain two distinct tuples $t_1$ and $t_2$ such that $t_1[K] = t_2[K]$.
$K$ is a key for $r$ if $K$ is a minimal superkey (i.e., there exists no other superkey $K^\prime$ of $r$ that is a proper subset of $K$).

\paragraph*{Primary Keys}
The presence of nulls in keys must be limited.
A practical solution is to select a primary key for each relation, on which nulls are not allowed. 
Primary key attributes are underlined in notation. 
References between relations are realized through primary keys.

\paragraph*{Foreign Keys}
Data in different relations are correlated by means of values of (primary) keys. 
Referential integrity constraints are imposed to ensure that these values correspond to actual values in the referenced relation.

\subsection{ER to relational transformation}
To transform an Entity-Relationship (ER) diagram into a relational database schema, the following steps should be performed:
\begin{enumerate}
    \item \textit{Create a separate table for each entity}:
        \begin{itemize}
            \item Each attribute of the entity becomes a column in the corresponding relational table.
            \item Each instance of the entity set becomes a row in the relational table.
        \end{itemize}
    \item \textit{Handle relationships}:
        \begin{itemize}
            \item For each relationship in the ER diagram, decide whether to represent it as a separate table or as a foreign key in an existing table.
            \item Binary relationships with a one-to-many or many-to-one cardinality can often be handled by adding a foreign key to the table corresponding to the many side.
            \item Many-to-many relationships typically require the creation of a separate relationship table, where foreign keys from the related entities form the primary key of the new table.
        \end{itemize}
\end{enumerate}