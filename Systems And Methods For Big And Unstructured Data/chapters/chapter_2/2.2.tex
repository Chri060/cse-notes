\section{Document-oriented databases}

In traditional relational databases, data is typically distributed across multiple tables, necessitating complex joins to retrieve related information.
While this model has its advantages, it can become cumbersome for certain business applications that require a more cohesive and intuitive representation of data.

Document-oriented databases address this challenge by structuring data into self-contained documents. 
Each document encapsulates all relevant information, often combining what would traditionally be spread across multiple tables into a single, unified structure. 
This approach not only simplifies queries by eliminating the need for intricate joins but also enhances performance in scenarios with high read or write demands.

One of the key advantages of document-oriented databases is their inherent flexibility. 
They allow for schema-less design, enabling developers to adapt and evolve the data structure with minimal friction. 
This adaptability is particularly valuable in agile development environments where requirements can change frequently.

Moreover, the document model aligns closely with object-oriented programming paradigms. 
By mapping data structures directly to objects in code, it effectively eliminates the impedance mismatch often encountered when trying to bridge the gap between object-oriented designs and relational database schemas. 
As a result, development becomes more streamlined, and applications can handle data more naturally.

\subsection{MongoDB}
MongoDB is a highly popular, open-source, document-oriented database that offers flexibility, scalability, and performance for modern application development. 
Unlike traditional relational databases, MongoDB stores data in JSON-like documents, making it more dynamic and developer-friendly. 
Its schema-less design enables the effortless adaptation of data models as requirements evolve. 
Moreover, MongoDB supports automatic data sharding, which ensures seamless horizontal scaling across multiple servers.
\begin{table}[H]
    \centering
    \begin{tabular}{|l|p{10cm}|}
    \hline
    \textbf{Feature} & \textbf{Description} \\ \hline
    \textit{General-purpose design} & Rich data model, advanced indexing, and powerful query language suited for diverse use cases like CMS and real-time analytics \\ \hline
    \textit{Ease of use} & Document model maps easily to object-oriented programming, with native drivers and simple setup for developers \\ \hline
    \textit{Performance and scalability} & In-memory operations and auto-sharding ensure high performance and seamless scaling without downtime \\ \hline
    \textit{Security} & SSL encryption, fine-grained access controls, and role-based authorization for robust data protection \\ \hline
    \end{tabular}
\end{table}

\subsubsection{Architecture}
MongoDB relies on three key processes to manage and operate its architecture:
\begin{itemize} 
    \item \textit{Mongod}: the primary process responsible for running the MongoDB database instance. 
        It handles all core database operations, including data storage and query execution. 
    \item \textit{Mongos}: acts as the query router in a sharded cluster, distributing queries based on the sharding configuration. 
        Multiple mongos instances can be deployed to improve performance and reduce network latency. 
    \item \textit{Mongo}: an interactive command-line shell that enables users to execute database commands and queries. 
\end{itemize}

\paragraph*{Indexes}
Indexes in MongoDB significantly enhance query performance by providing faster access to data. 
Key characteristics include:
\begin{itemize} 
    \item A default index is created on the id field (the primary key) of every document. 
    \item Users can define additional indexes, including single-field and compound indexes, to optimize query execution or enforce constraints such as uniqueness. 
    \item Array fields are supported, where separate index entries are created for each array element. 
    \item Sparse indexes include entries only for documents that contain the indexed field, effectively ignoring documents without the field. 
    \item Unique sparse indexes reject duplicate values but allow documents without the indexed field. 
\end{itemize}

\paragraph*{Sharding}
Sharding is MongoDB's strategy for partitioning large datasets across multiple servers, ensuring horizontal scaling and optimized performance. 
Sharding provides several benefits:
\begin{itemize} 
    \item \textit{Scale}: efficiently handles massive workloads and ensures scalability as data volume grows. 
    \item \textit{Geo-locality}: supports geographically distributed deployments to enhance user experience across regions. 
    \item \textit{Hardware optimization}: allows intelligent data distribution across resources, balancing performance and cost. 
    \item \textit{Recovery time optimization}: reduces downtime during failures, supporting strict Recovery Time Objectives (RTO).
\end{itemize}
A shard key is defined by the data modeler and determines how MongoDB partitions data across shards. 
The sharding process involves defining a shard key, which determines how data is distributed across shards. 
The main steps are:
\begin{enumerate} 
    \item MongoDB begins with a single chunk of data. 
        As the dataset grows, it automatically splits and migrates chunks to balance the load across shards.
    \item Queries are routed directly to the relevant shard, reducing overhead. 
    \item Config servers store metadata about shard ranges and their locations. 
        To ensure high availability, production systems typically use three config servers. 
\end{enumerate}
The sharding strategy can be: 
\begin{itemize} 
    \item \textit{Range-based}: data is partitioned by a continuous range of shard keys. 
    \item \textit{Hash-based}: MongoDB applies a hash to the shard key to distribute data randomly across shards, ensuring even distribution and minimizing hotspots. 
    \item \textit{Tag-aware}: specific shards are tagged to store particular subsets of data, such as region-based user data, optimizing geo-locality. 
\end{itemize}
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Usage} & \textbf{Required strategy} \\ \hline
        Scale & Range or hash \\ \hline
        Geo-locality & Tag-aware \\ \hline
        Hardware optimization & Tag-aware \\ \hline
        Lower recovery times & Range or hash \\ \hline
    \end{tabular}
\end{table}
MongoDB is designed to prioritize consistency and partition tolerance, making it an excellent choice for applications requiring scalability, performance, and flexibility.

\subsubsection{Data model}
MongoDB employs a flexible and intuitive data model based on JSON-like documents. 
This format is particularly well-suited for modern web and mobile applications due to its human readability, hierarchical structure, and adaptability to evolving requirements. 
Data is stored in contiguous regions, ensuring better data locality and faster access speeds.

MongoDB's design is optimized for contemporary application development, enabling developers to handle complex data relationships without the rigidity of traditional schemas. 
Large documents can be stored efficiently using GridFS, a feature that splits and distributes data across multiple files, supporting documents larger than the standard 16MB size limit.

\paragraph*{Binary JSON} 
MongoDB leverages BSON (Binary JSON), a binary-encoded serialization of JSON documents, to improve speed and efficiency. 
BSON enhances the traditional JSON format by introducing the following key features:
\begin{itemize} 
    \item \textit{Extended data types}: BSON supports additional data types such as dates, byte arrays, and embedded objects, which are not natively available in JSON. 
    \item \textit{Optimized storage}: the binary format is more compact, reducing storage overhead and improving data transmission speeds. 
    \item \textit{Serialization efficiency}: BSON enables faster serialization and deserialization, enhancing database performance during read and write operations. 
\end{itemize}

\subsubsection{Query language}
MongoDB provides a robust and flexible query language that supports all CRUD (Create, Read, Update, Delete) operations, enabling developers to interact with the database effectively. 
Its syntax is intuitive, leveraging JavaScript-like methods to simplify database management.

\paragraph*{Create}
A new database is created as soon as a document is inserted into a collection. 
You can switch to a database (creating it implicitly) using:
\begin{lstlisting}[style=MongoDB]
use database_name
\end{lstlisting}
To explicitly create a collection with optional parameters like schema validation:
\begin{lstlisting}[style=MongoDB]
db.createCollection(name, options)
\end{lstlisting}
Documents can be inserted into a collection using:
\begin{lstlisting}[style=MongoDB]
db.<collection_name>.insert()
\end{lstlisting}
Indexes are data structures that store a small portion of the collection's data set in an easy to traverse form, ordered by the value of the field. 
Indexes support the efficient execution of some types of queries.
Indexes are created with the \texttt{createIndex} operator which accepts a list of the fields with respect to which create the index and their corresponding ordering. 
\begin{lstlisting}[style=MongoDB]
db.<collection_name>.createIndex()
\end{lstlisting}

\paragraph*{Read}
Retrieve all documents in a collection with optional formatting for readability:
\begin{lstlisting}[style=MongoDB]
db.<collection_name>.find().pretty()
\end{lstlisting}
Filters can be added to the \texttt{find} function to narrow down results:
\begin{lstlisting}[style=MongoDB] 
db.<collection_name>.find() 
\end{lstlisting}
When collecting documents, it is possible to sort and limit the results. 
These operations can be performed through the \texttt{\$sort} and \texttt{\$limit} stages or using the \texttt{sort} and \texttt{limit} methods.
\begin{lstlisting}[style=MongoDB] 
db.<collection_name>.find().sort().limit(number)
\end{lstlisting}
Filtering operations may exhibit different behaviors depending on the type of complex field a query accesses, such as subdocuments or arrays. 
Queries that evaluate one or more conditions on the fields of a subdocument are not subject to any particular behavioral change. 
However, queries that evaluate a single condition on the fields of documents within an array will return the main document if at least one of the documents in the array satisfies the condition. 
When multiple conditions are evaluated on the documents in an array field, they will be assessed individually for each document in the array. 
In this case, the main document is returned if, for each condition, there exists at least one document that satisfies it. 
It does not matter if only one document satisfies all conditions or if multiple documents each satisfy a single condition.
If a query targets multiple conditions on the fields of the same document within an array, the \texttt{\$elemMatch} stage must be used. 
The \texttt{\$elemMatch} operator matches documents containing an array field with at least one element that satisfies all of the specified query criteria.
When a collection consists of documents containing arrays, retrieving the content of those arrays may be useful. This can be accomplished using the \texttt{\$unwind} stage. 
The \texttt{\$unwind} stage reshapes the collection so that each document is replaced by a set of new documents, one for each element in the document's array.
These new documents retain all fields from the original document and include a field with the name of the array field, which contains one of the elements.

MongoDB supports SQL-like aggregation for advanced data processing. 
Data passes through a pipeline where transformations and calculations are applied:
\begin{lstlisting}[style=MongoDB]
db.parts.aggregate()
\end{lstlisting}
Aggregate operations in MongoDB, aimed at grouping data with respect to one or more fields, are achieved using the \texttt{\$group} stage within the \texttt{aggregate} method.
This stage requires specifying the fields on which to perform the aggregation and the aggregation functions to apply. 
When the \texttt{\$group} stage is applied, only the fields used for the aggregation or explicitly created within this stage will be available in subsequent stages of the pipeline. 
To perform a grouping operation on the entire dataset, a dummy \texttt{\_id} can be used in the \texttt{\$group} stage by setting \texttt{\_id} to a constant value. 
This is why the \texttt{\$} operator is crucial in the grouping stage for referencing specific fields.
MongoDB's aggregation framework employs a pipeline model, where multiple stages are chained together to transform and analyze data. 
It is necessary to explicitly define all the stages in the pipeline. 
In addition to \texttt{\$group}, the following are some commonly used stages:
\begin{itemize}
    \item \texttt{\$match}: filters documents based on specified conditions.
    \item \texttt{\$project}: defines projections to reshape the document structure.
    \item \texttt{\$unwind}: deconstructs array fields into separate documents (explained earlier).
    \item \texttt{\$sort}: orders the documents based on specified fields.
    \item \texttt{\$limit}: limits the number of documents passed to the next stage.
\end{itemize}
\noindent For complex data aggregation, MongoDB supports the map-reduce paradigm:
\begin{lstlisting}[style=MongoDB]
db.collection.mapReduce()
\end{lstlisting}

\paragraph*{Update}
The general update command specifies selection criteria and new data:
\begin{lstlisting}[style=MongoDB]
db.<collection_name>.update(<select_criteria>,<updated_data>)
\end{lstlisting}
The \texttt{save} method replaces an existing document if it matches the identifier or inserts a new document if none exists:
\begin{lstlisting}[style=MongoDB]
db.<collection_name>.save()
\end{lstlisting}

\paragraph*{Delete}
To delete an entire database:
\begin{lstlisting}[style=MongoDB]
db.dropDatabase()
\end{lstlisting}
To remove a collection:
\begin{lstlisting}[style=MongoDB]
db.<collection_name>.drop()
\end{lstlisting}
To delete documents based on a filter: 
\begin{lstlisting}[style=MongoDB]
db.<collection_name>.remove(options)
\end{lstlisting}

\paragraph*{Comparison operators}
MongoDB supports a wide range of comparison operators to filter query results efficiently. 
These operators enable precise matching and logical operations. 
\begin{longtable}{|l|p{10cm}|}
    \hline \textbf{Name} & \textbf{Description} \\ \hline
    \texttt{\$eq} & Matches values that are equal to a specified value \\ \hline
    \texttt{\$gt}, \texttt{\$gte} & Matches values greater or equal to a specified value \\ \hline
    \texttt{\$lt}, \texttt{\$lte} & Matches values less or equal to a specified value \\ \hline
    \texttt{\$ne} & Matches values that are not equal to a specified value \\ \hline
    \texttt{\$in} & Matches any of the values specified in an array \\ \hline
    \texttt{\$nin} & Matches none of the values specified in an array \\ \hline
    \texttt{\$or} & Joins query clauses with a logical OR \\ \hline
    \texttt{\$and} & Joins query clauses with a logical AND \\ \hline
    \texttt{\$not} & Inverts the effect of a query expression \\ \hline
    \texttt{\$nor} & Joins query clauses with a logical NOR \\ \hline
    \texttt{\$exists} & Matches documents that have a specified field \\ \hline
    \texttt{\$type} & Matches documents whose chosen field is of a specified type \\ \hline
    \texttt{\$text} & Matches documents based on text search on indexed fields \\ \hline
    \texttt{\$regex} & Matches documents based on a specified regular expression \\ \hline
    \texttt{\$where} & Matches documents based on a JavaScript expression \\ \hline
\end{longtable}