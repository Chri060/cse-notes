\section{Quaternions}

A rotation characterized by Euler angles is ideal for planar tasks, such as driving simulations or first-person shooters (FPS). 
However, they are not suitable for applications like flight or space simulators due to the potential issue of gimbal lock.

A gimbal is a circular ring capable of rotating around its diameter. 
To freely orient an object in space, a physical system requires a minimum of three interconnected gimbals. 
During rotations, the pitch movement affects the roll axis, and the yaw movement affects both the pitch and roll axes. 
When the pitch rotates exactly $90^\circ$, the roll and yaw axes align, resulting in a loss of one degree of freedom. 
This phenomenon is known as gimbal lock, where certain natural movements become impossible, necessitating complex combinations of the three basic rotations. 
One common solution to this issue is to represent object rotations using quaternions, a mathematical device. 
However, Euler angles are frequently preferred in many applications, particularly in virtual reality (VR), where gimbal lock rarely occurs, and using quaternions introduces additional mathematical complexity to the process.

Quaternions are an extension of complex numbers, featuring three imaginary components represented as: 
\[a+ib+jc+kd\]
These imaginary components, collectively referred to as the vector part, adhere to specific relationships:
\[i^2=j^2=k^2=ijk=-1\]
With this specification, a comprehensive algebraic system can be established, incorporating various operations:
\begin{itemize}
    \item Addition: 
        \[(a_1 + ib_1 + jc_1+kd_1) + (a_2+ib_2+ jc_2 +kd_2 ) = (a_1+a_2 ) +i(b_1+b_2 ) + j (c_1+c_2) +k(d_1+d_2 )\]
    \item Scalar product: 
        \[\alpha (a+ib+ jc+kd) =\alpha a+i \alpha b+ j  \alpha c+k  \alpha d\]
    \item Quaternion product: 
        \begin{multline*}
            (a_1 + ib_1 + jc_1+kd_1)(a_2+ib_2+ jc_2 +kd_2 ) = (a_1a_2-b_1b_2-c_1c_2-d_1d_2)+ \\
            +i(a_1b_2-b_1a_2-c_1d_2-d_1c_2)+j(a_1c_2-c_1a_2-d_1b_2-b_1d_2)+\\
            +k(a_1d_2-d_1a_2-b_1c_2-c_1b_2)
        \end{multline*}
    \item Norm: 
        \[\left\lVert a+ib+jc+kd \right\rVert =\sqrt{a^2+b^2+c^2+d^2}\]
    \item Phase: 
        \[\theta=\arccos \dfrac{a}{\sqrt{a^2+b^2+c^2+d^2}}\]
    \item Power: 
        \[{(a+ib+jc+kd)}^\alpha=\left\lVert a+ib+jc+kd \right\rVert^\alpha\left( \cos(\alpha\theta)+\dfrac{ib+jc+kd}{\sqrt{b^2+c^2+d^2}}\sin(\alpha\theta) \right)\]
\end{itemize}

\subsection{Rotation}
A unit quaternion $q$ possesses a norm of $\left\lVert q \right\rVert = 1$. 
These unit quaternions are employed to encode 3D rotations.

Let's examine a rotation of an angle $\theta$ around an axis aligned with a unit vector $v = (x,y,z)$. 
This rotation can be succinctly represented using the following quaternion:
\[q=\cos\dfrac{\theta}{2}+\sin\dfrac{\theta}{2}(ix+jy+kz)\]
Given that $v$ is unitary, $q$ also is unitary.
Quaternions can be directly transformed into rotation matrices: 
\[R(q)=\begin{bmatrix}
    1-2c^2-2d^2 & 2bc+2ad & 2bd-2ac & 0 \\
    2bc-2ad & 1-2b^2-2d^2 & 2cd+2ab & 0 \\
    2bd+2ac & 2cd-2ab & 1-2b^2-2c^2 & 0 \\
    0 & 0 & 0 & 1
\end{bmatrix}\]

If $q_1$ and $q_2$ represent two distinct unit quaternions encoding separate rotations, their product encodes the composite transformation:
\[M_1\cdot M_2 \Leftrightarrow q_1\cdot q_2\]
With these definitions established, we can convert a set of Euler angles to a quaternion:
\[R=R_y(\phi)\cdot R_x(\theta)\cdot R_z(\varphi) \rightarrow q=\left(\cos\dfrac{\phi}{2}+j\sin\dfrac{\phi}{2}\right)\left(\cos\dfrac{\theta}{2}+i\sin\dfrac{\theta}{2}\right)\left(\cos\dfrac{\varphi}{2}+k\sin\dfrac{\varphi}{2}\right)\]
It's important to note that quaternion multiplication is non-commutative.
As the order of rotations matters, the sequence of quaternion multiplication should mirror that of the corresponding matrices.

To derive Euler angles from a quaternion, the process begins by computing its corresponding rotation matrix. 
Subsequently, the angles are extracted from this matrix.

\subsection{Usage}
When dealing with complex rotations, an object's orientation is typically stored in memory using a quaternion, represented as $q$.
When there's a need to calculate the world matrix, this quaternion is converted into the corresponding rotation matrix.
Subsequently, this matrix is utilized for both the translation and scaling components via multiplication.
In essence, the World Matrix $M_W$ can be computed as follows:
\[M_W = T(p_x, p_y, p_z) \cdot R(q) \cdot S(s_x, s_y, s_z)\]
The application consistently conducts rotations using quaternion operations: any relative changes in an object's direction are encoded with a quaternion $\Delta q$, expressing both the direction and the amount of rotation.

When the rotation quaternion is applied first, the rotation takes place in world space:
\[q=\Delta q \cdot q\]
When the rotation quaternion is positioned at the end, local space is employed: 
\[q=q \cdot\Delta q\]

\subsection{Quaternions in GLM}
GLM provides quaternion support through both base and extended functions. 
To utilize quaternion functions, include the specific part of the GLM library:
\begin{verbatim}
#include <glm/gtc/quaternion.hpp>    
\end{verbatim}
Quaternions can be created in three ways:
\begin{enumerate}
    \item From Euler angles, specified in the pitch, yaw, roll order:
        \begin{verbatim}
glm::quat qe = glm::quat(glm::vec3(0, glm::radians(45.0f), 0));
        \end{verbatim}
        Note: This constructor is rarely used due to the pitch, yaw, roll order. 
        It's mainly suitable for building base quaternions corresponding to the three main rotations. 
        To obtain a quaternion representing a proper rotation matrix with given Euler angles in the considered $zxy$ order, compose the building blocks manually:
        \begin{verbatim}
glm::quat qe = glm::quat(glm::vec3(0, glm::radians(yaw), 0)) *
               glm::quat(glm::vec3(glm::radians(pitch), 0, 0)) *
               glm::quat(glm::vec3(0, 0, glm::radians(roll)));
glm::mat4 MQ = glm::mat4(qe);
        \end{verbatim}
    \item Specifying the scalar part first, followed by the $i$, $j$, $k$ vector components:
        \begin{verbatim}
glm::quat qv = glm::quat(cos(glm::radians(22.5f)), 0, 
                         sin(glm::radians(22.5f)), 0);
        \end{verbatim}
    \item From the rotation angle and the axis direction, using the \texttt{rotate ()} function: 
        \begin{verbatim}
glm::quat qa = glm::rotate(glm::quat(1,0,0,0), glm::radians(45.0f), 
                           glm::vec3(0,1,0));
        \end{verbatim}
\end{enumerate}
The scalar component can be accessed with the \texttt{.w} field, and the $i$, $j$, $k$ vector components with the \texttt{.x}, \texttt{.y}, and \texttt{.z} fields, respectively:
\begin{verbatim}
std::cout << qe.x << "\t" << qe.y << "\tâ€
          << qe.z << "\t" << qe.w << "\n" ;
\end{verbatim}
Algebraic operations, including the product among quaternions, can be performed using the usual symbols. 
For example, for the product:
\begin{verbatim}
glm::quat qp = qb * qa;
\end{verbatim}
Compute the equivalent $4\times4$ rotation matrix by passing it as a constructor parameter to the \texttt{glm::mat4} matrix type: 
\begin{verbatim}
glm::mat4 R = glm::mat4(qe);
\end{verbatim}
Since rotations are encoded with unit quaternions, ensure this property using the \texttt{normalize}  function starting from an arbitrary element:
\begin{verbatim}
glm::quat qn = glm::quat(-1, 0, 2, 3);
glm::quat qnn = glm::normalize(qn);
\end{verbatim}
The extended functions offer various additional features such as Euler angle extraction, interpolation, and faster construction and conversion procedures.