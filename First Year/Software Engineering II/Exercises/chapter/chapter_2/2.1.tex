\section{Alloy}

Consider construction cubes of three different sizes, small, medium, and large. You can build towers by piling up these cubes one on top of the other respecting the following rules:
\begin{itemize}
    \item A large cube can be piled only on top of another large cube.
    \item A medium cube can be piled on top of a large or a medium cube.
    \item A small cube can be piled on top of any other cube.
    \item It is not possible to have two cubes, A and B, simultaneously positioned right on top of the same other cube C. 
\end{itemize}
\begin{enumerate}
    \item Model in Alloy the concept of cube and the piling constraints defined above.
    \item Model also the predicate canPileUp that, given two cubes, is true if the first can be piled on top of the second and false otherwise.
    \item Consider now the possibility of finishing towers with a top component having a shape that prevents further piling, for instance, a pyramidal 
        or semispherical shape. This top component can only be the last one of a tower, in other words, it cannot have any other component piled on it.
        Rework your model to include also this component. You do not need to consider a specific shape for it, but only its property of not allowing further 
        piling on its top. Modify also the canPileUp predicate so that it can work both with cubes and top components.
\end{enumerate}

\paragraph*{Solution}
\begin{enumerate}
\item The concept of cube and its constraints can be defined in the following way. 
    \begin{lstlisting}[language=alloy]
abstract sig Size{}

sig Large extends Size{} 

sig Medium extends Size{} 

sig Small extends Size{}

sig Cube {
size: Size,
piledOn: lone Cube
}{piledOn != this}

fact noCircularPiling {
no c: Cube | c in c.^piledOn
}

fact pilingUpRules {
all c1, c2: Cube | c1.piledOn = c2 implies (
c2.size = Large or
c2.size = Medium and (c1.size = Medium or c1.size = Small) or c2.size = Small and c1.size = Small)
}

fact noMultipleCubesOnTheSameCube {
no disj c1, c2: Cube | c1.piledOn = c2.piledOn
}
    \end{lstlisting}
\item The predicate canPileUp can be defined as follows. 
    \begin{lstlisting}[language=alloy]
pred canPileUp[cUp: Cube, cDown: Cube] {
cUp.piledOn = cDown and
(cDown.size = Large or
cDown.size = Medium and (cUp.size = Medium or cUp.size = Small) or 2
cDown.size = Small and cUp.size = Small) 
}

pred show {} 

run show

run canPileUp
    \end{lstlisting}
\item The now model become: 
    \begin{lstlisting}[language=alloy]
abstract sig Size{}

sig Large extends Size{} 

sig Medium extends Size{} 

sig Small extends Size{}

abstract sig Block{ 
piledOn: lone Cube
}

sig Cube extends Block { 
size: Size
}{piledOn != this}

sig Top extends Block { }

fact noCircularPiling {
no c: Cube | c in c.^piledOn
}

fact noMultipleBlocksOnTheSameCube {
no disj b1, b2: Block | b1.piledOn = b2.piledOn
}

fact pilingUpRules {
all c1, c2: Cube | c1.piledOn = c2 implies (
c2.size = Large or
c2.size = Medium and (c1.size = Medium or c1.size = Small) or c2.size = Small and c1.size = Small)
}

pred canPileUp[bUp: Block, cDown: Cube] {
bUp.piledOn = cDown and (bUp in Top or
(cDown.size = Large or
cDown.size = Medium and (bUp.size = Medium or bUp.size = Small) or cDown.size = Small and bUp.size = Small))
}   

pred show {} 

run show

run canPileUp 
    \end{lstlisting}
\end{enumerate}