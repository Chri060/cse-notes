\section{Search-based software testing}
Search-Based Software Testing (SBST) functions as a complementary approach to existing test case generation methods, operating seamlessly at both the component and system levels. 
Departing from conventional approaches, SBST adopts a goal-oriented strategy, directing test case generation towards specific testing objectives.
In contrast to fuzzing, SBST stands out by incorporating domain-specific knowledge into its methodology, resulting in the production of more meaningful and context-aware test cases. 
This approach addresses a spectrum of considerations, including functional and non-functional aspects such as reliability and safety.
At its core, SBST redefines testing as an optimization problem, striving to create test cases that fulfill pre-defined testing objectives. 
The iterative process involves enhancing test cases progressively to achieve the desired objectives. 
The fundamental steps in SBST encompass:
\begin{enumerate}
    \item \textit{Identify the objective}: clearly define the testing objective that needs to be achieved.
    \item \textit{Define distance measurement}: specify the method for measuring the distance of the current execution from the objective. 
        This distance serves as the fitness metric, evaluating the alignment of the current execution (represented by inputs or the test case) with the testing goal.
    \item \textit{Instrument code for fitness computation}: modify the code to compute the fitness (distance) of the current execution concerning the defined objective.
    \item \textit{Select random inputs}: randomly choose inputs to execute the program, effectively generating test cases.
    \item \textit{Execute test case}: run the selected test case and compute its fitness in relation to the testing objective.
    \item \textit{Check fitness threshold}: if the fitness is insufficient, return to step four and select new inputs.
    \item \textit{Objective achieved}: if the fitness is satisfactory, consider the testing objective achieved, concluding the process.
\end{enumerate}

\subsection{Test generation}
\begin{definition}[\textit{Search space}]
    Search space refers to the domain within which we are seeking specific entities, namely, test cases, and this definition is contingent on the particular testing problem at hand.
\end{definition}
Within this search space, each individual point possesses neighboring points. 
These neighbors are comprised of inputs that exhibit a relationship with the given point. 
When combining the concept of the search space with its corresponding neighborhood relation, we can delineate the following components:
\begin{itemize}
    \item \textit{Fitness function}: this function serves to quantify the quality or appropriateness of a given test case, essentially functioning as a measure of its goodness as a candidate solution.
    \item \textit{Exploration algorithm}: an algorithm is introduced to systematically navigate the neighborhood. 
        This algorithm utilizes a heuristic to guide and direct the search process effectively.
\end{itemize}

\paragraph*{Fitness function}
The fitness function establishes the quality of an entity, evaluating an individual's merit within the given context.
It assigns a numerical value to a test case, with a higher value indicating a more favorable candidate. 
The nature of this function is contingent upon the specific testing objective in consideration.

\paragraph*{Algorithm}
An example of a search algorithm employed for test generation is known as hill climbing.
The procedural steps for this approach are as follows:
\begin{enumerate}
    \item Commence from a randomly chosen starting point.
    \item Evaluate the fitness values of all neighboring points.
    \item Progress to the neighbor exhibiting the best fitness value.
    \item If a solution is not achieved, repeat the process from step two.
\end{enumerate}
To circumvent the possibility of getting stuck in a local optimum, a straightforward strategy involves restarting the process from a new random point until the global optimum is reached.
However, it's important to note that hill climbing proves less effective in scenarios with expansive search spaces, as it tends to focus on local exploration.
To enhance global search efficiency, the concept of mutation can be incorporated to facilitate more extensive steps.

\subsection{Summary}
In terms of strengths, this method stands out by steering the generation process toward specific testing objectives, such as identifying incorrect outputs or achieving coverage of designated branches, in contrast to concolic guides. 
Furthermore, it surpasses traditional fuzzing techniques by consistently generating more meaningful test cases. 
Notably, it demonstrates the ability to reach the testing objective with sufficient budget allocation.

On the flip side, there are notable weaknesses. 
One major drawback is the necessity for domain-specific knowledge to define the notion of fitness, making this aspect a nontrivial challenge. 
Additionally, the effectiveness of this method heavily relies on the quality of heuristics employed to explore the testing space. 
Moreover, its computational expense and time-consuming nature pose significant drawbacks.