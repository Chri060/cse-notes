\section{OpenGL Shading Language}

Most of the Bidirectional Reflectance Distribution Function (BRDF) functions, indirect light approximation, and light emission models are typically implemented using shaders written in the GLSL language.

To illustrate its features, let's consider an example that computes the Mandelbrot set, the most famous fractal, using vertex and fragment shaders.

\subsection{Vertex shader}
The vertex shader is defined as: 
\begin{verbatim}
#version 450
layout(set = 0, binding = 0) uniform
UniformBufferObject {
    mat4 worldMat;
    mat4 vpMat;
} ubo;
layout(location = 0) in vec3 inPosition;
layout(location = 0) out float real;
layout(location = 1) out float img;

// The main procedure
void main () {
    gl_Position = ubo.vpMat * ubo.worldMat *
    vec4(inPosition, 1.0);
    real = inPosition.x * 2.5;
    img = inPosition.y * 2.5;
}
\end{verbatim}
Shaders in GLSL follow classical conventions, where global variables and functions are declared in the main scope of the file. 
The entry point of the shader can be user-defined within the code, but it is typically the function \texttt{main ()}.

Vulkan requires support for at least a certain GLSL version. Therefore, a shader source code should begin with the \texttt{\#version} directive, specifying at least version 4.5.

Comments in GLSL code follow the classical C notations. 
Blocks are denoted using curly brackets. 

Variables in GLSL are typed, and their names follow the same conventions as in C (case-sensitive, allowing letters, numbers, and underscores, but cannot start with a number). 
Like in C, variables are local to the block they are defined in.

In addition to type and name, variables can be preceded by various qualifiers. 
GLSL supports a wide range of types, including scalar types (such as \texttt{int} and \texttt{float}), vector types (such as \texttt{vec2}, \texttt{vec3}, and \texttt{vec4}), and matrix types (such as \texttt{mat2}, \texttt{mat3}, and \texttt{mat4}).

\paragraph*{Vectors}
In GLSL, types are available for containing vectors of two, three, or four components. 
Floating-point vectors are commonly used to represent colors and coordinates.
Vector elements can be accessed individually using the dot syntax.

\paragraph*{Matrices}
GLSL also defines matrix types, with the most commonly used being the $2\times 2$, $3\times 3$, or $4\times 4$ matrices composed of single precision elements.
GLSL uses column-major encoding for matrices, which means that elements are stored column-wise in memory. 
Elements of a matrix can be accessed using indices starting from zero in \texttt{[][]} brackets. 

\paragraph*{GLM and GLSL}
The types defined in the GLM library used in our C++ source code have been named to follow the equivalent GLSL conventions. 
This simplifies the interactions between the shaders and the application code.

By aligning the naming conventions between GLM types and GLSL types, it becomes easier to pass data between the application and shaders. 
This consistency enhances the overall development process and promotes code readability.

\subsection{Fragment shader}
The fragment shader is defined as: 
\begin{verbatim}
#version 450
layout(location = 0) in float real;
layout(location = 1) in float img;
layout(location = 0) out vec4 outColor;
layout(set = 0, binding = 1) uniform
GlobalUniformBufferObject {
    float time;
} gubo;

// The main procedure
void main() {
    float m_real = 0.0f, m_img = 0.0f, temp;
    int i;
    for(i = 0; i < 16; i++) {
        if(m_real * m_real + m_img * m_img > 4.0) {
            break;
        }
        temp = m_real * m_real - m_img * m_img + real;
        m_img = 2.0 * m_real * m_img + img;
        m_real = temp;
    }
    outColor =
    vec4((float(i % 5) + sin(gubo.time*6.28)) / 5.0,
    float(i % 10) / 10.0, float(i) / 15.0, 1.0);
}
\end{verbatim}
