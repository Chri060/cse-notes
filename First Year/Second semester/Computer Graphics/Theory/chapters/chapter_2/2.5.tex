\section{Transformation properties}

The associativity property holds for the product of two matrices and for the product of a matrix and a vector:
\[A \cdot \left(B \cdot C\right)=\left(A \cdot B\right) \cdot C\]
\[A \cdot \left(B \cdot p\right)=\left(A \cdot B\right) \cdot p\]
Exploiting this property allows us to factorize all transformations into a single matrix. 
By computing the product of all transformations, a composed matrix is obtained, which can then be used to apply all transformations in a single operation.

Furthermore, the inverse of the product of two matrices follows a specific pattern:
\[\left( A \cdot B \right)^{-1}=B^{-1}\cdot A^{-1}\]
This property enables us to compute the inverse of a composed transformation. 

It's crucial to note that matrix multiplication is not commutative, meaning the order of transformations matters. 
Swapping two transformations results in a different outcome.

\subsection{OpenGL Mathematics}
To address the issue of non-commutativity in matrix operations, we can utilize GLM, a straightforward linear algebra library commonly employed in computer graphics.

GLM employs the same type names as those defined in the GLSL shading language. 
Being a header-only library simplifies compilation and linking processes. 
Leveraging C++ operator overloading capabilities, complex mathematical operations can be expressed using a simple syntax.

The necessary headers to include are:
\begin{verbatim}
#define GLM_FORCE_RADIANS    
#include glm/glm.hpp
#include glm/gtc/matrix_transform.hpp
#include glm/gtx/matrix_transform2.hpp
\end{verbatim}
The initial \texttt{define} ensures that all angles are interpreted as radians. 
The first \texttt{include} imports the entire library, while the other two imports the four principal transformations.

\paragraph*{Matrix and vectors definitions}
The following commands utilize GLM's functionality to define and manipulate matrices and vectors in the context of computer graphics:
\begin{itemize}
    \item To define $4 \times 4$ matrices: \\
        \texttt{glm::mat4 M;}
    \item To create a matrix from its elements (passed per column): \\
        \texttt{M = glm::mat4(m11, m21, m31, m41, ..., m14, m24, m34, m44);}
    \item To create an identity matrix: \\
        \texttt{M = glm::mat4(1);}
    \item To define three-component vectors: \\
        \texttt{v = glm::vec3(m1, m2, m3);}
    \item To define four-component vectors: \\
        \texttt{v = glm::vec4(m1, m2, m3, m4);} 
\end{itemize}
Note that to access the elements of a matrix we have to specify the index of the column followed by the index of the row: 
\begin{verbatim}
elem = matrix[column_index][row_index];
\end{verbatim}

\paragraph*{Matrix and vectors operations}
The possible operations, that needs to respect the dimensionality of them, are: 
\begin{itemize}
    \item To compute matrix product: \\ 
        \texttt{Mprod = matrix1 * matrix2;}
    \item To invert a matrix: \\ 
        \texttt{Minv = glm::inverse(matrix);}
    \item To transpose a matrix: \\ 
        \texttt{Mtran = glm::transpose(matrix);}
    \item To perform algebraic operations between matrices and vectors: \\ 
        \texttt{Msum = matrix + matrix;} \\
        \texttt{Msub = matrix - matrix;} 
\end{itemize}

\paragraph*{Transposition}
The transposition of a matrix can be done with the following command: 
\begin{verbatim}
glm::mat4 T = glm::translate(glm::mat4(1), glm::vec3(dx, dy, dz));
\end{verbatim}
This command creates a $4 \times 4$ translation matrix (\texttt{T}) with displacements \texttt{dx}, \texttt{dy}, and \texttt{dz}.

\paragraph*{Scaling}
The scaling of a matrix can be done with the following command:
\begin{verbatim}
glm::mat4 S = glm::scale(glm::mat4(1), glm::vec3(sx, sy, sz)); 
\end{verbatim}
This command generates a $4 \times 4$ scaling matrix (\texttt{S}) with scaling factors \texttt{sx}, \texttt{sy}, and \texttt{sz}. 
A shortcut for proportional scaling is:
\begin{verbatim}
glm::mat4 Sp = glm::scale(glm::mat4(1), glm::vec3(s)); 
\end{verbatim}

\paragraph*{Rotation}
The rotation of a matrix can be done with the following command:
\begin{verbatim}
glm::mat4 R = glm::rotate(glm::mat4(1), ang, glm::vec3(ax, ay, az));
\end{verbatim}
This command produces a $4 \times 4$ rotation matrix (\texttt{R}) of an angle \texttt{ang} along an axis specified by vector \texttt{ax}, \texttt{ay}, and \texttt{az}. 
Angles can be specified in radians using \texttt{glm::radians()} function. 
For rotations along the $x$, $y$, and $z$ axes:
\begin{verbatim}
glm::mat4 Rx = glm::rotate(glm::mat4(1), ang, glm::vec3(1, 0, 0));
glm::mat4 Ry = glm::rotate(glm::mat4(1), ang, glm::vec3(0, 1, 0)); 
glm::mat4 Rz = glm::rotate(glm::mat4(1), ang, glm::vec3(0, 0, 1));
\end{verbatim}

\paragraph*{Shear}
The shear of a matrix can be done with the following commands:
\begin{verbatim}
glm::mat4 Rx = glm::shearX3D(glm::mat4(1), hy, hz);
glm::mat4 Ry = glm::shearY3D(glm::mat4(1), hx, hz); 
glm::mat4 Rz = glm::shearZ3D(glm::mat4(1), hx, hy);
\end{verbatim}
These commands create $4 \times 4$ shear matrices along the $x$, $y$, and $z$ axes with shear factors \texttt{hx}, \texttt{hy}, and \texttt{hz}.