\section{Mesh}

Natural objects exhibit a blend of glossy, bumpy, linear, and curved surfaces. 
In the digital realm, 3D assets serve as virtual renditions of these objects, encoded digitally. 
While we've discussed techniques for determining on-screen positions of points in 3D space, objects typically aren't represented as disjointed point clouds due to the immense resources such a representation would demand to create an illusion of solidity.

Instead, solid objects are initially stored solely by their boundaries, with their internal content often disregarded. 
This initial step simplifies the storage and processing requirements for digital representations of objects.

The encoding of object geometry relies on mathematical models that articulate surfaces using a series of parameters. 
Computational geometry delves into the optimal methods for mathematically articulating these surfaces. 
Numerous methodologies have been outlined in scholarly literature, with the most prevalent being: meshes (polygonal surfaces), hermite surfaces, NURBS (Non-Uniform Rational B-Splines), HSS (Hierarchical Subdivision surfaces), and metaballs. 
3D authoring tools such as Blender typically offer users the flexibility to choose from various techniques for encoding the models they create. 
Each technique necessitates distinct sets of tools and modeling proficiencies.
Every mathematical model possesses unique characteristics and constraints. 
Nonetheless, when it comes to rendering, all models are ultimately converted into meshes, or polygonal surfaces. 
Therefore, our focus will be primarily on meshes.

\paragraph*{Polygonal surfaces}
Polygonal surfaces represent objects described by a series of connected polygons. 
With specialized rendering features, these surfaces can effectively approximate curved shapes. 
Each polygon describing a planar section of the object's surface is termed a face, while the edges denote the sides of the polygons, typically where two faces intersect. 
Vertices mark the beginning and end points of edges, with each edge being delimited by exactly two vertices. 
In a proper solid, at least three faces intersect at a vertex.

\paragraph*{Two-manyfold}
In the context of topology, surfaces where every edge is adjacent to precisely two faces exhibit a unique structure known as a 2-manyfold. 
Surfaces that deviate from this pattern usually depict non-physical objects, and if utilized, necessitate careful attention to ensure accurate rendering.

At times, non-2-manifold objects are employed to minimize the polygon count required for encoding extremely thin objects or to achieve specific visual effects.
However, algorithms such as backface-culling are incompatible with non-2-manifold objects and may not function as intended.

\paragraph*{Triangles and meshes}
Each polygon can be subdivided into a collection of triangles that share certain edges. 
This assemblage of adjacent triangles forms what is known as a mesh.

Given that three non-collinear points define a unique plane in space, and likewise three non-collinear points define a triangle, it follows that polygons with more than three vertices may not necessarily represent a single planar surface. 
Consequently, there exist various possible arrangements for connecting more than three points to delineate a surface in space. 
This necessitates the conversion of every polygon, whether planar or not, into a collection of triangles through a process known as polygon tessellation. 
Notably, polygon tessellations are not singular; multiple tessellations can be generated for each polygon with more than three sides.

In a mesh representation of an object, its surfaces are stored using the collection of polygons that form its boundaries. 
These boundary polygons are subsequently transformed into a series of interconnected triangles that share certain edges.

\subsection{Mesh encoding}
Mesh encoding relies on sets of vertices, which serve as the building blocks for defining the geometry. 
The rendering engine utilizes these vertices to establish the endpoints of the triangles composing the mesh. 
Typically, vertex coordinates are stored as Cartesian coordinates to optimize memory usage. 
Before applying transformations using the world view projection matrix, the rendering engine adds a fourth component set to one to ensure homogeneous coordinates.

It's evident that many triangles within a mesh share a significant number of vertices. 
Leveraging this characteristic is crucial for minimizing the memory footprint required to encode an object.

Various types of mesh encoding have been proposed in the literature, but only two are standard in Vulkan: 
\begin{itemize}
    \item \textit{Triangle lists}: each triangle is encoded as a trio of distinct coordinates, without reusing any vertices. 
        They are suitable for encoding disconnected triangles. 
        Encoding $N$ triangles necessitates $3N$ vertices.
    \item \textit{Triangle strips}: A series of contiguous triangles forming a band-like surface. 
        The encoding starts with the first two vertices, with each subsequent vertex connected to the preceding two. 
        To encode $N$ triangles, $N+2$ vertices are required.
\end{itemize}

\paragraph*{Properties}
In some cases, triangle strips may not be applicable even when the topology appears suitable for this type of encoding. 
This limitation arises because a vertex is typically defined by more parameters than just its local coordinates. 
For triangle strip encoding to be viable, shared vertices must be identical across all parameters.

\subsection{Index primitives}
While triangle strips can offer significant savings, often up to two-thirds compared to triangle lists, many scenarios still entail repeated vertices. 
Due to the inability to encode certain primitives with a single triangle strip, vertices may be shared among different strips. 
Indexed primitives mitigate this issue by reducing the overhead of duplicating vertices across lists or strips.

Consider a sphere, typically composed of multiple strips where each vertex is shared by at least four triangles. 
Although triangle strips can decrease the space needed for each band, the same vertex is reiterated across various bands.

Indexed primitives employ two arrays: the vertex array containing vertex definitions (positions), and the index array specifying triangles indirectly. 
Triangles are drawn based on their indices, with vertex coordinates retrieved from the vertex list according to the index's position.

Indexing achieves substantial byte savings without the complexity of determining correct ordering. 
Consequently, many file interchange formats exclusively support meshes encoded with indexed triangle lists to streamline their architecture.

\paragraph*{Restart}
In Vulkan, the restart feature enables additional space reduction in band-like structures. 
Specifically, a negative index restarts the strip, optimizing the encoding process.

\subsection{Lines}
\paragraph*{Two-dimensional plots}
When creating 2D plots and charts, lines are typically employed instead of triangles.

\paragraph*{Wireframe}
Lines are also utilized to generate Wireframe views, showcasing only the outlines of objects by connecting their vertices with lines. 
These views are valuable in numerous scenarios, particularly for debugging 3D applications.

The two primary types of wireframe mesh encoding are:
\begin{itemize}
    \item \textit{Line lists}: each segment is encoded as a pair of separate vertices. 
        Encoding $N$ segments necessitates $2N$ vertices.
    \item \textit{Line strips}: a path of connected vertices is encoded. 
        To represent $N$ segments, $N+1$ vertices are required.
\end{itemize}
Wireframe primitives can also be indexed. 
Additionally, Vulkan supports drawing standard objects solely using the contour of their triangles. 
However, this approach is simply a means to simplify creating a wireframe object corresponding to the mesh's wireframe.