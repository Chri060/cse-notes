\section{Introduction}

\section{Introduction}

Modern computer architectures exhibit a multitude of components, including:
\begin{itemize}
    \item Multiple CPU cores.
    \item One or more distinct GPUs.
    \item Diverse memory configurations, encompassing both CPU and GPU memory.
    \item Concurrent utilization by various applications or virtual machines, necessitating simultaneous access to CPUs and GPUs.
\end{itemize}

Vulkan emerges as a solution to optimize resource utilization, allowing users to harness available capabilities to their fullest potential. 
However, this advancement comes with a significant caveat: the complexity of setup is immense.
Vulkan is designed to operate across a wide spectrum of systems, encompassing:
\begin{itemize}
    \item Desktop computers (PCs, Macs, Linux-based systems, etc.).
    \item Mobile devices (Smartphones, Tablets, VR Headsets, etc.).
    \item Gaming consoles (e.g., Nintendo Switch).
    \item Embedded systems (such as map displays in automobiles).
\end{itemize}
Each system boasts its unique characteristics, and Vulkan strives to provide comprehensive support across this diversity.

\subsection{Starter library}
Exploiting all of Vulkan's features in an application typically involves numerous steps. 
However, in many cases, users rely on the same foundational startup sequence.
The \texttt{Starter.hpp} file, utilized across all assignments, serves the purpose of defining a standardized initialization procedure. 
This approach alleviates the need for users to explicitly repeat all the "normal startup steps" within their projects.
A typical Vulkan application follows this structure:
\begin{verbatim}
void run() {
    initWindow();   // Create the operating system window
    initVulkan();   // Set up Vulkan resources
    initApp();      // Load and set up application elements
    mainLoop();     // Execute the update/render cycle of the application
    cleanup();      // Release all resources
}
\end{verbatim}

\subsection{Presentation surface}
The designated screen area where the host operating system permits Vulkan to render images is referred to as the presentation surface.

For a Vulkan application to function correctly, it must acquire an appropriate presentation surface from the operating system. 
This particular step is contingent upon the system in use, and we will delve deeper into it later.

\paragraph*{Application window creation}
In desktop environments like MS Windows, MacOS, or Linux, the presentation surface is typically encapsulated within a window. 
For the purposes of this course, we'll focus solely on desktop applications.

GLFW provides a platform-independent method to create windows. Before opening a window with GLFW, initialization of GLFW is necessary. 
Various parameters can be utilized to specify the characteristics of the window created. 
In GLFW, this is achieved using the \texttt{glfwWindowHint(prop, val)} command, assigning the value \texttt{val} to the property \texttt{prop}. 
Since GLFW's default mode is geared towards OpenGL, setting the \texttt{GLFW\_CLIENT\_API} property to \texttt{GLFW\_NO\_API} is imperative for Vulkan usage. 
Numerous other options can also be configured.
The \texttt{glfwCreateWindow()} function is employed to generate the operating system window and returns its identifier. 
This procedure accepts the window's width and height (specified in pixels as \texttt{WIDTH} and \texttt{HEIGHT}) along with a string to display in the title bar.
In applications utilizing \texttt{Starter.hpp}, this process is encapsulated within a specific procedure callback named \texttt{setWindowParameters()}:
\begin{verbatim}
void initWindow() {
    glfwInit();
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); 
    window = glfwCreateWindow(WIDTH, HEIGHT, 'Vulkan', nullptr, nullptr);
}
\end{verbatim}