\section{Clipping}

When triangles from a mesh intersect screen boundaries, they may only be partially visible. 
Clipping addresses this by truncating and removing portions of graphics primitives to ensure they are fully contained within the screen.

Clipping occurs after the projection transform but before normalization (division by $w$). 
Consequently, it operates within a space known as Clipping Coordinates.
In 3D, clipping is conducted against the viewing frustum, the space that defines what is visible to the viewer within the scene.

\subsection{Half spaces}
Let's revisit the equation of a plane:
\[n_x x+n_y y+n_z z+d=0\]
Here, $n_x, n_y,n_z$ represent the components of the normal vector to the plane and the constant term $d$ defines the distance from the origin (zero if the plane passes through it).
When expressed as an inequality, the equation divides space into two regions known as half-spaces:
\[n_x x+n_y y+n_z z+d>0\]
Using homogeneous coordinates, a plane can be identified with a four-component vector $n$. 
Thus, the plane equation becomes a scalar product between the homogeneous coordinates of the point and the vector representing the plane:
\[\begin{cases}
    n=\left(n_x,x_y,n_z,d\right) \\
    p=\left(x,y,z,1\right) \\
    n \cdot p = 0
\end{cases}\]
A point $p$ lies in either of the two half-spaces depending on the sign of the scalar product between $p$ and $n$. 
Additionally, the result of the product is the signed distance of the point from the plane dividing the two half-spaces.

As a frustum is a convex solid, it can be defined as the intersection of the six half-spaces corresponding to its six faces.

Clipping is performed in clipping space, where coordinates are considered to be inside the frustum if they fall within certain ranges: between $-1$ and $1$ for $x$ and $y$, and between $0$ and $1$ for $z$. 
The six vectors representing the six faces of the frustum are as follows:
\[\begin{cases}
    n_l=\begin{bmatrix} 1 & 0 & 0 & 1 \end{bmatrix} \\ 
    n_r=\begin{bmatrix} -1 & 0 & 0 & 1 \end{bmatrix} \\
    n_b=\begin{bmatrix} 0 & 1 & 0 & 1 \end{bmatrix} \\
    n_t=\begin{bmatrix} 0 & -1 & 0 & 1 \end{bmatrix} \\ 
    n_n=\begin{bmatrix} 0 & 0 & 1 & 0 \end{bmatrix} \\ 
    n_f=\begin{bmatrix} 0 & 0 & -1 & 1 \end{bmatrix}
\end{cases}\]

\subsection{Points}
To ascertain whether a point lies within the frustum, we conduct scalar products between its homogeneous coordinates and the six normal vectors. 
Specifically, the point resides inside the frustum if all these products yield positive results.
A clipping algorithm can then eliminate a point $p$ if the product with at least one of the normal vectors to the frustum is negative:
\[p\cdot n_v>0\]

\subsection{Triangles}
Dealing with triangles adds complexity to the clipping process. Let's focus on a side of the frustum with a normal vector $n_v$. 
We compute the distances from the plane ($d_1,d_2$, and $d_3$) by performing scalar products of the three coordinates of vertices $p_1,p_2$, and $p_3$ with the normal vector $n_v$.

We classify a side as either trivial reject or trivial accept based on the signs of the three distances. 
If all distances have the same sign, we either reject or accept the side. 
In case of rejection (all negative distances), the algorithm stops as the triangle lies entirely outside the frustum. 
For acceptance (all positive distances), the iteration continues with the next plane:
\[\begin{cases}
    d_1=p_1\cdot n_v>0 \\
    d_2=p_2\cdot n_v>0 \\
    d_3=p_3\cdot n_v>0 
\end{cases}\]
If two points are outside the frustum, e.g., $p_2$ and $p_3$, we compute two intersections $p_2^\prime$ and $p_3^\prime$ of the segments connecting them to $p_1$ with the plane using interpolation. 
The distances from the plane $d_2$ and $d_3$ are used as interpolation coefficients, and the two vertices $p_2$ and $p_3$ are replaced by $p_2^\prime$ and $p_3^\prime$: 
\[\begin{cases}
    d_1=p_1\cdot n_v>0 \\
    d_2=p_2\cdot n_v<0 \\
    d_3=p_3\cdot n_v<0 
\end{cases}\]
If just one point is outside, e.g., $p_3$, we compute two intersections $p_3^\prime$ and $p_3^{\prime\prime}$ on the segments that connect it to $p_1$ and $p_2$. 
In this case, two triangles are produced, and usually, the choice is arbitrary.
\[\begin{cases}
    d_1=p_1\cdot n_v>0 \\
    d_2=p_2\cdot n_v>0 \\
    d_3=p_3\cdot n_v<0 
\end{cases}\]
If the triangle is not rejected, it is clipped against the next plane. 
If two triangles have been produced, they are considered separately.

The algorithm continues until all triangles have been checked with all sides of the frustum, or when all triangles have been rejected.
While the algorithm is simple, it can generate numerous triangles since they can potentially double at every check. 
This has implications on the required data structure to store the triangles, as it must accommodate a variable number of figures.
Additionally, computing intersections is complex as it must consider all parameters assigned to vertices, such as normal vectors, colors, and UV coordinates.

\subsection{Remarks}
Understanding the process of clipping, although typically handled transparently by drivers, provides insight into an important step in rendering graphics on screen. 
Furthermore, the techniques discussed can be adapted to address various intersection problems that may arise in an application.

While clipping is usually automated, advanced users can manipulate the clipping distance of triangles to achieve intriguing effects. 
However, delving into such advanced capabilities is beyond the scope of this course.