\section{Screen synchronization update}

The CPU, GPU, and screen update process operate at varying and independent speeds. 
If a program is not properly written, this discrepancy can lead to flickering in animations.

Monitors and display devices construct images by sequentially updating their pixels in a predetermined order, typically scanning horizontally from left to right and top to bottom. 
Flickering manifests as breaks in the animation, known as tearing, occurring because the graphics adapter reads video memory while the program is still in the process of composing the image.

Each graphics adapter issues an interrupt signal, often referred to as Vsync, to the processor upon completing the screen tracing.
Applications can intercept this interrupt and initiate background updates only upon receiving the Vsync signal. 
This synchronization ensures smoother animation rendering and reduces flickering issues.

\subsection{Double buffering}
In double buffering, the video memory consists of two frame buffers: the front buffer and the back buffer. 
While the video adapter displays the content of one buffer, the application can simultaneously compose the image in the other.

Initially, the application operates on one buffer (the back buffer), while the video adapter displays the other one (the front buffer).

Once the new frame is composed, the application awaits the Vsync signal from the monitor. Upon receiving the signal, it swaps the front buffer with the back buffer. 
Subsequently, the application begins composing the new frame while the monitor displays the just-finished one. 
This process ensures smoother animation rendering by synchronizing the buffer swapping with the monitor's refresh cycle.

\subsection{Triple buffering}
While double buffering effectively addresses certain issues, it also presents drawbacks.
For instance, the application must halt image composition upon completing a screen and wait for the Vsync interrupt to resume. 
This synchronization with the monitor's refresh rate limits the frame rate and can lead to application locks, reducing CPU and GPU utilization.

Triple Buffering resolves these limitations by introducing complete independence between the application and presentation processes. 
Initially, the application operates on one frame buffer while the system displays another. 
Upon finishing composing a screen, the application immediately begins working on the next one in the buffer currently not used by the presentation.

Upon receiving the next Vsync signal, the presentation displays the last fully composed frame (the one where the application is currently not working). 
The application can switch between the two back buffers not currently shown as many times as necessary while awaiting the Vsync. 
If a frame is completed before the Vsync is received, the previously generated screen is skipped and never displayed. 
This process, known as frame skipping, enables achieving frame rates higher than the display's rate by automatically discarding unused frames.

Triple buffering ensures smooth animations and prevents the tearing effect by swapping buffers at the Vsync. 
However, it has drawbacks, including increased memory requirements (at least three frame buffers are needed) and potentially wasteful resource utilization by both the CPU and GPU on frames that will be discarded.