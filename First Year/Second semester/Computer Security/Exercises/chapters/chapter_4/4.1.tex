\section{Exercise 1}

Watson Files is a new system that lets you store files in the cloud. 
Customers complain that old links often return a “404 File not found” error. 
Sherlock decides to fix this problem modifying how the web server responds to requests for missing files. 
The Python-like pseudocode that generates the “missing file” page is the following:
\begin{verbnobox}[\verbarg]
def missing_file(cookie, reqpath):
print "HTTP/1.0 200 OK"
    print "Content-Type: text/html"
    print ""
    user = check_cookie(cookie)
    if user is None:
        print "Please log in first"
        return

    print "<p>We are sorry, but the server could not locate file" + reqpath
    print "<br>Try using the search function.</p>"
\end{verbnobox}
where \texttt{reqpath} is the requested path (e.g., if the user visits https://www.watsonfiles.com/dir/file.txt, the variable \texttt{reqpath} contains dir/file.txt). 
The function \texttt{check\_cookie} returns the username of the authenticated user checking the session cookie (this function is securely implemented and does not have vulnerabilities).
To download the files stored in Watson Files, users visit the page /download, which is processed by the following server-side pseudocode:
\begin{verbnobox}[\verbarg]
def download_file(cookie, params):
    # code to initialize the HTTP response
    user_id = check_cookie(cookie)
    if user is None:
        print "Please log in first"
        return
    filename = params['filename']
    query = "SELECT file_id, data FROM files WHERE FILENAME = '" + filename + "';"
    result = db.execute(query)
    # code to print result['data']
\end{verbnobox}
where params is a dictionary containing the GET parameters (e.g., if a user visits /download?filename=holmes.txt, then params['filename'] will contain 'holmes.txt').
The database queries are executed against the following tables:
\begin{itemize}
    \item UserID, Username, Password. 
    \item FileId, Filename, Data.
\end{itemize}
\begin{enumerate}
    \item Check if there are cross-site scripting or cross-site request forgery in the \texttt{missing\_file} function. 
        If there is a vulnerability, explain the simplest procedure to remove it. 
    \item Identify the class of the vulnerability and briefly explain how it works in general.
    \item Write an exploit for the vulnerability just identified to get the password of user John.
\end{enumerate}

\subsection*{Solution}
\begin{enumerate}
    \item There is an XSS because an attacker can supply a filename containing
\begin{verbatim}
<script>alert(document.cookie)</script> 
\end{verbatim}
        and the web server would print that script tag to the browser, and the browser will run the code from the URL.
        The simplest procedure to prevent this vulnerability is to apply escaping/filtering to the reqpath variable.

        There are no cross site request forgery because there is no state-changing action in the page that needs to be protected against CSRF.
    \item SQL Injection. 
        There must be a data flow from a user-controlled HTTP variable (e.g., parameter, cookie, or other header fields) to a SQL query, without appropriate filtering and validation. 
        If this happens, the SQL structure of the query can be modified.
    \item The SQL injection exploit is: 
\begin{verbatim}
' UNION SELECT user_id, password FROM users WHERE name = 'John';--
\end{verbatim}
        Note that we assume that password must be of the same type of data.  
\end{enumerate}