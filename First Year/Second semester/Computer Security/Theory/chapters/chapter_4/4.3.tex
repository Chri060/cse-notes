\section{Format string bugs}

\begin{definition}[\textit{Format string}]
    A format string provides a solution for crafting output strings that incorporate variables formatted as desired by the programmer.
\end{definition}
\begin{definition}[\textit{Variable placeholder}]
    Variable placeholders dictate how data is formatted into a string.
\end{definition}
Placeholders serve to specify the formatting type for data inclusion in a string:
\begin{itemize}
    \item \texttt{\%d} or \texttt{\%i}: decimal. 
    \item \texttt{\%u}: unsigned decimal.
    \item \texttt{\%o}: unsigned octal.
    \item \texttt{\%X} or \texttt{\%x}: unsigned hexadecimal.
    \item \texttt{\%c}: character.
    \item \texttt{\%s}: string (char*), printing characters until the null terminator \texttt{/0} is encountered.
\end{itemize}
Examples of format print functions include: \texttt{printf}, \texttt{fprintf}, \texttt{vfprintf}, \texttt{sprintf}, \texttt{vsprintf}, \texttt{snprintf}, and \texttt{vsnprintf}.

\paragraph*{snprintf()}
Consider the following call: 
\begin{verbatim}
snprintf(buf, 250, "%x %x %x");
\end{verbatim}
When \texttt{snprintf()} parses the format string, it anticipates three additional parameters from the caller to substitute for the three \texttt{\%x} placeholders. 
As per the calling convention, these parameters should be pushed onto the stack by the caller. 
Consequently, \texttt{snprintf()} assumes they are on the stack prior to the preceding arguments. 
This situation enables the possibility of unintentionally reading up to fifteen bytes from the stack. 

When examining the stack in reverse, we typically encounter a portion of our format string. 
This is logical since the format string is commonly stored on the stack. 
Consequently, we can retrieve what we've placed on the stack.
To inspect the stack, we employ the \texttt{\%N\$x} syntax, indicating the $N$-th parameter, coupled with straightforward shell scripting.
This method can also be utilized to search for valuable data in memory, representing a vulnerability known as information leakage.

\subsection{Stack writing}
The placeholder \texttt{\%n} allows us to write the number of characters (bytes) printed so far into the memory address pointed to by the argument.
Stack writing can be implemented as follows:
\begin{enumerate}
    \item Place the address (addr) of the memory cell (target) to be modified onto the stack.
    \item Utilize \texttt{\%x} to locate it on the stack (\texttt{\%N\$x}).
    \item Replace \texttt{\%x} with \texttt{\%n} to write a number into the cell pointed to by addr, i.e., target.
\end{enumerate}
To ascertain the number of bytes printed thus far, the placeholder \texttt{\%c} can be employed. 
This placeholder specifies the precision of the printed number and can also be applied to strings.
If you prepend a \texttt{0} before the number, it inserts zero padding before the first character.

To write an arbitrary number (0x6028) to the target address (0xBFFFF6CC), we can proceed as follows:
\begin{enumerate}
    \item Include the target address as part of the format string, pushing it onto the stack.
    \item Use \texttt{\%x} to locate the target address on the stack (\texttt{\%N\$x}). 
        Let's denote the displacement as pos.
    \item Employ \texttt{\%c} and \texttt{\%n} to write 0x6028 into the cell pointed to by the target address. 
        Remember to consider the parameter of \texttt{\%c} along with the length of the printed characters.
\end{enumerate}

\paragraph*{32 bit addresses}
To facilitate efficient writing and avoid processing excessive data, we'll split each DWORD (32 bits, up to 4GB) into two WORDs (16 bits, up to 64KB) and execute two writing rounds.

Keep in mind that once we commence counting upwards with \texttt{\%c}, we cannot count downwards. 
Our progression must remain in an upward direction, necessitating some mathematical calculations.
We first insert the word with the lower absolute value, followed by the word with the higher absolute value.

We must execute this writing procedure twice within the same format string.
We need the following: 
\begin{itemize}
    \item Identify the target addresses for the two writes, which are 2 bytes apart.
    \item Determine the displacements of the two targets.
    \item Perform mathematical computations to derive the arbitrary numbers to write. 
        These numbers, when summed, should yield the 32-bit address.
\end{itemize}
Here's the general procedure for performing the writing operation:
\begin{enumerate}
    \item Place the two target addresses of the memory cells to be modified onto the stack as part of the format string.
    \item  Utilize \texttt{\%x} to locate \texttt{<target\_1>} on the stack (\texttt{\%N\$x}). 
        Let's denote the displacement as pos. 
        For instance, \texttt{<target\_2>} will be located at pos+1 (i.e., it's positioned one DWORD up).
    \item Employ \texttt{\%c} and \texttt{\%n} to:
        \begin{itemize}
            \item Write the lower absolute value into the cell pointed to by \texttt{<target\_1>}.
            \item Write the higher decimal value into the cell pointed to by \texttt{<target\_2>}.
        \end{itemize}
\end{enumerate}

\paragraph*{Target addresses}
The TARGET address can vary depending on the specific context of the exploit. 
Here are some common locations where the TARGET address might be found:
\begin{itemize}
    \item \textit{Saved return address} (saved EIP): this is typical in scenarios resembling a basic stack overflow.
        You must locate the address on the stack, often by overflowing a buffer and overwriting the return address of a function.
    \item \textit{Global offset table (GOT)}: used for dynamic relocations of functions in shared libraries.
        Overwriting entries in the GOT can redirect the execution flow to attacker-controlled code.
    \item \textit{C library hooks}: functions such as \texttt{malloc}, \texttt{free}, \texttt{printf}, may have hooks that allow customization or interception of their behavior.
        Overwriting these hooks can alter program behavior.
    \item \textit{Exception handlers}: overwriting exception handlers can allow control of program execution when exceptions occur.
    \item \textit{Other structures and function pointers}: depending on the application, there may be other structures or function pointers stored in memory that can be manipulated to redirect program flow.
\end{itemize}

\subsection{Countermeasure}
Here's an overview of countermeasures against format string vulnerabilities:
\begin{itemize}
    \item Memory error countermeasures, as discussed earlier, play a significant role in preventing exploitation by introducing safeguards like stack canaries, ASLR, and DEP.
    \item Modern compilers aid in vulnerability mitigation by issuing warnings upon detecting risky calls to printf-like functions during code compilation.
    \item Patched versions of \texttt{libc} (C standard library) are developed to mitigate format string vulnerabilities. 
        For example, some versions count the expected arguments and verify their alignment with the number of placeholders in the format string.
\end{itemize}

\subsection{Generalization}
The core issue with format string vulnerabilities extends beyond printing functions. 
Essentially, any function with specific characteristics is at risk:
\begin{itemize}
    \item Known as variadic functions, they accept a variable number of parameters.
    \item Parameters are dynamically resolved at runtime by retrieving them from the stack.
    \item These functions incorporate a mechanism, like placeholders, enabling direct or indirect read/write access to arbitrary memory locations.
    \item Users have control over these functions, influencing their behavior.
\end{itemize}
C-like format string interpreters (e.g., printf, sprintf) operate based on a user-specified string. This string can express various functionalities:
\begin{itemize}
    \item Counters, tracking the number of characters printed.
    \item Conditional writes to arbitrary memory locations.
    \item Read operations and arithmetic computations.
\end{itemize}
These capabilities are sufficient to implement conditional jumps and loops, making the behavior of printf and similar functions Turing complete.