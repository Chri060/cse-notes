\section{Buffer overflow}

Stack smashing, commonly seen in C programming, occurs due to unsafe practices when a buffer is filled with data exceeding its allocated size, leading to a buffer overflow vulnerability. 
Several standard C library functions are prone to causing stack smashing if not used carefully, including: \texttt{strcpy}, \texttt{strcat}, \texttt{fgets}, \texttt{gets}, \texttt{sprintf}, \texttt{scanf}.

Improper handling of these functions can result in stack smashing vulnerabilities, allowing attackers to execute arbitrary code, crash the program, or gain unauthorized access to sensitive information. 
Therefore, it's essential for programmers to use safer alternatives or apply proper input validation and buffer size checks to mitigate these risks.

\subsection{Buffer address}
Guessing the buffer address for executing arbitrary machine code in the overflowed buffer can be challenging due to several factors:
\begin{itemize}
    \item \textit{Proximity to ESP}: one common approach is to guess that the overflowed buffer is near the stack pointer (ESP).
        Debugging tools like gdb can help determine the approximate location of ESP at runtime.
    \item \textit{Variability}: the exact address of the buffer may change with each execution or across different machines, making it difficult to predict reliably.
    \item \textit{CPU precision}: CPUs are not designed to handle imprecise memory accesses gracefully.
\end{itemize}
The problem of precision arises because executing arbitrary machine code relies on accurately predicting the memory location of the buffer. 
However, due to the dynamic nature of memory allocation and the lack of precision in CPU operations, achieving reliable execution of arbitrary code in a stack overflow scenario is challenging. 
Security measures such as Address Space Layout Randomization (ASLR) further complicate this task by introducing additional randomness to memory addresses, making it even harder to predict the buffer's location.

In practical scenarios, obtaining the ESP value can be done using a debugger or reading from the process directly. 
However, it's important to note that certain debuggers, like gdb, may introduce an offset to the allocated process memory. 
Consequently, the ESP value obtained from gdb might differ slightly from the ESP value obtained by reading directly within the process.

Despite these methods, precision issues persist. Even with accurate ESP values, precisely determining the buffer's location remains challenging. 
This lack of precision can impede the reliable execution of arbitrary code in a stack overflow scenario.

\paragraph*{nop sled}
To address the precision issue, we can utilize a nop sled. A nop sled is a sequence of nop (no operation) instructions, represented by the hexadecimal value \texttt{0x90} on x86 architecture.
These instructions do nothing when executed and serve as a landing strip for the program's execution flow.

At the beginning of the buffer, we place a sequence of nop instructions, creating the nop sled. 
This sled acts as a safe landing zone for the program's execution flow. 
By jumping to anywhere within the nop sled range, we ensure that even if the precise location of the buffer is not accurately determined, the program will still land on valid instructions within the nop sled and continue execution until it reaches the desired executable code.

\subsection{Process selection}
Historically, attackers have often aimed to spawn a privileged shell on a local or remote machine.
\begin{definition}[\textit{Shell code}]
    Shell code refers to a sequence of machine instructions designed to open a shell, typically a privileged one.
\end{definition}
While shell code can perform various actions, spawning a shell has been a common objective due to the elevated privileges it provides.
To achieve this, attackers typically invoke the \texttt{execve} system call, which executes a program specified by its path name.

In Linux systems, invoking a system call involves executing a software interrupt using the \texttt{int} instruction with the value \texttt{0x80}. 

\paragraph*{Shell code}
Creating shell code usually starts with high-level code and involves translating it into machine instructions, often using assembly language. 
An alternative approach is to write the code in C and then extract the relevant instructions to compose the shell code. 
The process can be outlined as follows:
\begin{enumerate}
    \item \textit{Write high-level code}: begin by writing the desired functionality in high-level C code.
    \item \textit{Compile and disassembly}: compile the C code and then disassemble the resulting binary to obtain its assembly instructions.
    \item \textit{Analyze assembly}: analyze the disassembled code to identify and extract only the relevant instructions needed to achieve the desired functionality.
    \item \textit{Extract opcode}: identify the operation code for each relevant instruction.
    \item \textit{Create the shell code}: finally, assemble the extracted opcodes into a sequence of bytes to form the shell code.
\end{enumerate}

\subsection{Countermeasures}
A layered defense strategy is effective in mitigating buffer overflow vulnerabilities:
\begin{enumerate}
    \item \textit{Source code level defenses}: address vulnerabilities within the source code to prevent buffer overflows.
        This involves educating developers on secure coding practices, conducting targeted testing, and using source code analyzers.
        Additionally, adopting safer libraries and programming languages with dynamic memory management, such as Java, can provide inherent protection against these vulnerabilities.
    \item \textit{Compiler level defenses}: utilize compiler-level techniques to make vulnerabilities harder to exploit.
        Compiler warnings can alert developers to potential issues before the code is executed. 
        Techniques such as randomizing the order of stack variables can introduce variability that complicates exploitation.
        Incorporating stack protection mechanisms during compilation further enhances security.
    \item \textit{Operating system level defenses}: implement operating system-level measures to obstruct or complicate attacks.
        Non-executable stack configurations help prevent stack smashing attacks by distinguishing data from executable code.
        Despite non-executable stack defenses, attackers may bypass them by redirecting the return address to existing machine instructions, a technique known as code-reuse attacks. 
        Despite these defenses, attackers may use techniques like code-reuse attacks to bypass protections.
        Address Space Layout Randomization (ASLR) adds further security by randomizing memory locations, including the stack, making it difficult for attackers to predict return addresses.
\end{enumerate}

\paragraph*{Stack canary}
The stack canary mechanism involves placing a sentinel value between local variables and control values to detect tampering.
The integrity of this canary is checked during the function's epilogue, and if tampering is detected, the program is terminated. 
Various types of canaries enhance security:
\begin{itemize}
    \item \textit{Terminator canaries}: use terminator characters, such as \texttt{/0}, which are not copied by string-copy functions, making them resistant to overwriting during attacks.
    \item \textit{Random canaries}: generated as random sequences of bytes at program execution.
    \item \textit{Random XOR canaries}: randomly generated canaries that are XORed with a portion of the protected structure. 
        This XOR operation adds complexity, making the canary harder to manipulate even if the buffer overflow does not occur.
\end{itemize}