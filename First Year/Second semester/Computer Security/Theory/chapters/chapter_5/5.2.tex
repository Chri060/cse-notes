\section{Cross site scripting}
Imagine a basic blog application where anyone can post comments. 
Users enter their comments into a text field, which is then displayed to other visitors.

Without any filtering mechanism, an attacker could input malicious code like:
\begin{verbatim}
<script>
    alert('JavaScript Executed');
</script>
\end{verbatim}
If this input isn't filtered, the malicious script would execute on subsequent visitors' screens. 
This type of attack is called Cross-Site Scripting (XSS).

XSS is a vulnerability where client-side code can be injected into a page.
There are three types:
\begin{enumerate}
    \item \textit{Stored XSS}: the attacker's input is stored on the target server in a database. 
        When a victim retrieves the stored malicious code from the web application, it's not made safe to render in the browser.
    \item \textit{Reflected XSS}: client input (i.e., request payload) is returned to the client by the web application in a response (e.g., error message, search result). 
        The response includes some or all of the input provided in the request without being stored and made safe to render in the browser.
    \item \textit{DOM-based XSS}: user input never leaves the victim's browser. 
        The malicious payload is directly executed by client-side script (e.g., script that modifies/updates the DOM in-memory representation of a page including forms).
\end{enumerate}
With XSS, it's possible to:
\begin{itemize}
    \item Steal cookies or hijack sessions.
    \item Manipulate sessions and execute fraudulent transactions.
    \item Eavesdrop on private information.
    \item Initiate drive-by downloads.
    \item Effectively bypass the same-origin policy.
\end{itemize}
For added security, consider browsing with \texttt{noscript} enabled.

\paragraph*{Same-Origin Policy}
The Same-Origin Policy is a standard implemented by all web clients. 
SOP dictates that all client-side code (such as JavaScript) loaded from one origin, A, should only access data from the same origin, A. 
However, the modern web often blurs these boundaries with mechanisms like Cross-Origin Resource Sharing (CORS) and client-side extensions.

\subsection{Content security policy}
Content Security Policy is a W3C specification designed to instruct the browser about what content should be trusted and what should not. 
Think of it as an extension of the same-origin policy, offering more flexibility and expressiveness in defining policies. 
Technically, CSP consists of a set of directives transmitted from the server to the client via HTTP response headers.

\paragraph*{Directives}
Numerous directives are available in Content Security Policy (CSP), including:
\begin{itemize}
    \item \texttt{script-src}: specifies origins from which client code can be loaded.
    \item \texttt{form-action}: lists valid endpoints for form submission.
    \item \texttt{frame-ancestors}: lists sources permitted to embed the current page as frames and applets.
    \item \texttt{img-src}: defines origins from which images can be loaded.
    \item \texttt{style-src}: similar to script-src, but for stylesheets.
\end{itemize}
It's important to note that while these directives are specified, their implementation ultimately depends on the browser.

CSP is gradually gaining popularity, but faces challenges due to its potential to disrupt functionality with strict policies and susceptibility to bypassing with relaxed policies.

Practical barriers and challenges include:
\begin{itemize}
    \item Determining who writes the policies.
    \item The predominantly manual process of policy creation.
    \item Limited automation possibilities, leaving some aspects manual.
    \item Maintenance of policies over time, particularly challenging as modern pages load content from numerous resources, and both pages and resources can evolve dynamically.
\end{itemize}