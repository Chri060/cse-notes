\section{Pseudo-Random number generators}

To expand the key for use in a Vernam cipher with a finite-length key, we require a Pseudo-Random Number Generators (PRNG).
We assume that the attacker's computational capability is limited to polynomial computations. 
\begin{definition}[\textit{Cryptographically Safe Pseudo-Random Number Generators}]
    A Cryptographically Safe Pseudo-Random Number Generator (CSPRNG) is a deterministic function:
    \[\text{PRNG}:\left\{ 0,1 \right\}^\lambda \rightarrow \left\{ 0,1 \right\}^{\lambda+I}\] 
    where $I$ is an expansion factor, such that the output of the PRNG cannot be distinguished from a uniformly random sample $ \left\{ 0,1 \right\}^{\lambda+I}$ with computational complexity $\mathcal{O} (\text{poly}(\lambda))$. 
\end{definition}
In practice, CSPRNG are considered as candidates because there is no conclusive evidence supporting the existence of a definitive PRNG function.
Demonstrating the existence of a CSPRNG would imply $\mathcal{P} \neq \mathcal{NP}$.

Developing a CSPRNG from scratch is feasible but not the usual approach due to inefficiency. 
Typically, they are constructed using another fundamental element called Pseudo-Random Permutations (PRP), which are derived from Pseudo-Random Functions (PRF).

To randomly select a function, we start by considering the set:
\[F=\left\{ f:\{0,1\}^{in}\rightarrow\{0,1\}^{out}, in,out \in \mathbb{N}  \right\}\]
A uniformly randomly sampled $f \overset{\$}{\leftarrow}F$  can be represented by a table with $2^{in}$ entries, each entry being $out$ bits wide: 
\[\left\lvert F \right\rvert = \left( 2^{out} \right)^{2^{in}}\]
\begin{example}
    For instance, if $in=2$ and $out = 2$, the function set $F=\left\{ f:\{0,1\}^{2}\rightarrow\{0,1\}^{1} \right\}$ consists of the 16 Boolean functions with two inputs.
    Each function is represented by a 4-entry truth table.
    The total number of functions is 16, corresponding to the $2^4=16=\left( 2^1 \right)^{2^2}$ tables.
\end{example}

\subsection{Pseudo-Random function}
\begin{definition}[\textit{Pseudo-Random Function}]
    A Pseudo-Random Function (PRF) is denoted as: 
    \[prf_{seed}:\left\{ 0,1 \right\}^{in} \rightarrow \left\{ 0,1 \right\}^{out}\]
    Where it takes an input and a $\lambda$-bit seed.
\end{definition}
Consequently, $prf_{seed}$ is entirely determined by the seed value.
It cannot be distinguished from a random function: 
\[ f \in \left\{ f:\{ 0,1 \}^{in} \rightarrow \{ 0,1 \}^{out}\right\}\]
within polynomial time in $\lambda$.
In other words, given $a \in \left\{ f:\{ 0,1 \}^{in} \rightarrow \{ 0,1 \}^{out}\right\}$, it is computationally infeasible to determine which of the following is true:
\begin{itemize}
    \item $a=prf_{seed}(\cdot)$ with $\text{seed}\overset{\$}{\leftarrow}\{0,1\}^\lambda$. 
    \item $b\overset{\$}{\leftarrow}F$, where $F=\left\{ f:\{ 0,1 \}^{in} \rightarrow \{ 0,1 \}^{out}\right\}$.
\end{itemize}

\subsection{Pseudo-Random Permutation}
\begin{definition}[\textit{Pseudo-Random Permutation}]
    A Pseudo-Random Permutation (PRP) is a bijective PRF defined as:
    \[prf_{seed}:\left\{ 0,1 \right\}^{len}\rightarrow\left\{ 0,1 \right\}^{len}\]
\end{definition}
It is characterized solely by its seed value and cannot be distinguished from a random function within polynomial time.
This permutation represents a rearrangement of all possible strings of length $len$.
In practical terms:
\begin{itemize}
    \item It operates on a block of bits and yields another block of equal size.
    \item The output appears unrelated to the input.
    \item Its behavior is entirely determined by the seed, akin to a key in conventional cryptography.
\end{itemize}

However, there is no formally proven PRP because its existence would imply $\mathcal{P} \neq \mathcal{NP}$. 
Construction of such a PRP typically involves three steps:
\begin{enumerate}
    \item Compute a small bijective Boolean function $f$ with input and key.
    \item Compute $f$ again between the previous output and the key.
    \item Repeat the second step until satisfaction.
\end{enumerate}

\paragraph*{PRP selection}
Modern PRP often emerge from public competitions, where cryptanalytic techniques help identify and eliminate biases in their outputs, ensuring robust designs.

These PRPs are commonly known as block ciphers.
A block cipher is considered broken if it can be distinguished from a PRP with less than $2^\lambda$ operations.
The key length $\lambda$ is chosen to be sufficiently large to render computing $2^\lambda$ guesses impractical.
For different security levels:
\begin{itemize}
    \item Legacy-level security typically employs $\lambda$ around 80.
    \item For a security duration of five to ten years, $\lambda$ is set to 128.
    \item Long-term security requires $\lambda$ of 256.
\end{itemize}

\subsection{Standard block ciphers}
The Advanced Encryption Standard (AES) operates on a 128-bit block size and offers three key lengths: 128, 192, and 256 bits.
Chosen as a result of a three-year public competition by NIST on February 2, 2000, AES emerged as the preferred standard out of 15 candidates and has since been standardized by ISO.

The predecessor to AES, known as the Data Encryption Standard (DES), was established by NIST in 1977. 
DES operated with a relatively short 56-bit key length, leading to security concerns. 
It was bolstered through triple encryption, effectively achieving an equivalent security level of $\lambda=112$. 
Although still present in some legacy systems, DES has been officially deprecated.