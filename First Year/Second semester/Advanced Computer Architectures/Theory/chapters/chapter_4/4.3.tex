\section{Dependency}

To achieve higher performance within a given technology, it is crucial to extract more parallelism from the program. 
This involves detecting and resolving dependencies and scheduling instructions to maximize execution parallelism with the available resources.

Dependencies among instructions are key to determining the level of parallelism in a program. 
If two instructions are dependent on each other, they cannot execute simultaneously and must be executed sequentially or with limited overlap. 
There are three types of dependencies: name, data, and control dependencies.

\subsection{Name dependency}
A name dependency occurs when two instructions use the same register or memory location without any data flow between them.
There are two types of name dependencies between an instruction $i$ preceding instruction $j$:
\begin{itemize}
    \item \textit{Anti-dependence} (WAR): occurs when $j$ writes to a register or memory location that instruction $i$ reads. 
    \item \textit{Output dependence} (WAW): arises when both $i$ and $j$ write to the same register or memory location. 
\end{itemize}
Name dependencies differ from true data dependencies as there is no data flow between the instructions.

\paragraph*{Register Renaming}
If the names used in the instructions can be altered, the instructions do not conflict. 
Detecting dependencies through memory locations is more challenging since two addresses might refer to the same location but appear different. 
Register renaming is easier to implement and can be accomplished statically by the compiler or dynamically by the hardware.

\subsection{Data dependency}
Data dependencies can potentially create data hazards, but the actual hazard and the number of stalls required to eliminate it depend on the pipeline. 
There are three types of data hazards:
\begin{itemize}
    \item \textit{RAW hazards}: true data dependence.
    \item \textit{WAW hazards}: output dependence
    \item \textit{WAR hazards}: anti-dependence.
\end{itemize}
It is important to note that data dependencies are inherent to the program, while hazards are specific to the pipeline.

\subsection{Control dependency}
Control dependencies dictate the order of instruction execution, preserved by:
\begin{itemize}
    \item Executing instructions in program order to ensure that an instruction before a branch executes before the branch.
    \item Detecting control hazards to ensure that an instruction dependent on a branch is not executed until the branch direction is known.
\end{itemize}
While preserving control dependence is a simple way to maintain program order, it is not the most critical property that must be preserved for execution.