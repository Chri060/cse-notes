\section{Static branch prediction}

Static branch prediction is employed in processors where branch behavior is expected to remain predictable at compile time.
It can also complement dynamic predictors by providing a baseline prediction strategy.

\subsection{Branch always not taken}
Branch always not taken assumes that every branch instruction will not be taken.
In the pipeline, if the branch condition is evaluated to false during the ID stage, the sequential instruction flow proceeds without any penalties. 
If the branch condition is true (an incorrect prediction), the pipeline must be flushed. 
This involves discarding the fetched instructions after the branch and fetching the correct instructions from the branch target address, incurring a one-cycle penalty.

\subsection{Branch always taken}
Branch always taken predicts that every branch will be taken.
Once the branch is decoded and its target address computed, the processor immediately begins fetching and executing instructions from the target address. 
This approach is advantageous in pipelines where the branch target address is known early enough to initiate fetching without waiting for the branch outcome.
However, in some pipelines like MIPS, where the branch target address isn't determined before the branch outcome, this approach offers no benefit.

\subsection{Backward taken forward not taken}
Backward taken forward not taken prediction strategy categorizes branches based on their direction. 
Backward-going branches, such as loops, are predicted as taken, while forward-going branches, like conditional jumps to subsequent code, are predicted as not taken.

\subsection{Profile-driven prediction}
Profile-driven prediction utilizes profiling information gathered from previous executions to improve branch prediction accuracy. 
This approach leverages data on branch behavior collected during runtime to predict future branch outcomes more effectively. 
Additionally, compilers can provide hints to further refine these predictions based on the program's characteristics and execution patterns.

\subsection{Delayed branch}
In a delayed branch scenario, the compiler strategically places an independent instruction into a designated branch delay slot.
This instruction executes regardless of whether the branch is taken or not.
Typically, processors like MIPS have a single-cycle delay slot, while more complex pipelines may feature longer delays, though filling multiple slots can be challenging for compilers.
For MIPS, the compiler routinely schedules an independent instruction immediately following the branch. 
The behavior of the delayed branch is consistent:
\begin{itemize}
    \item If the branch is not taken, the processor proceeds with the instruction following the branch.
    \item If the branch is taken, execution continues at the branch target.
\end{itemize}
The compiler's task is to ensure that the instruction placed in the delay slot is both valid and beneficial. 
There are three primary strategies for scheduling the delay slot:

\begin{enumerate}
    \item \textit{From before}: an independent instruction preceding the branch is placed in the delay slot.
        This instruction always executes, irrespective of the branch outcome.
    \item \textit{From target}: the delay slot is filled with an instruction from the branch target. 
        To prevent certain instructions from being moved after the branch, a register in the branch condition may be used. 
        This strategy is effective for branches likely to be taken, such as loop branches.
    \item \textit{From fall-through}: qn instruction from the fall-through path, where the branch is not taken, occupies the delay slot. 
        Similar to the from target strategy, this may involve using a register in the branch condition to control instruction placement. 
        It's favored for branches unlikely to be taken, such as forward branches.
\end{enumerate}
In deeply pipelined processors with multi-cycle delays, fully populating delay slots with useful instructions becomes more challenging.
The primary challenges in scheduling delayed branches include: constraints on which instructions can occupy the delay slot, and the compiler's ability to accurately predict branch outcomes statically. 

To mitigate these challenges, some processors employ a canceling or nullifying branch instruction. 
This approach indicates the predicted branch direction:
\begin{itemize}
    \item When the prediction is correct, the instruction in the delay slot executes normally.
    \item If the prediction is incorrect, the instruction is replaced with a nop.
\end{itemize}