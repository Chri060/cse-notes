\section{Grammar normal forms and transformations}

Grammars in normal forms impose constraints on the rules without diminishing the family of generated languages. 
They serve utility in both proving properties and language design.

\subsection{Nonterminal expansion}
The expansion of a nonterminal is employed to eliminate it from the rules where it appears.
\begin{example}
    Consider the grammar: 
    \[\begin{cases}
        A \rightarrow \alpha B \gamma \\
        B \rightarrow \beta_1\mid \beta_2\mid \dots\mid \beta_n
    \end{cases}\]
    By expanding the nonterminal $B$, we obtain:
    \[A \rightarrow \alpha\beta_1\gamma\mid \alpha\beta_2\gamma\mid \dots\mid \alpha\beta_n\gamma\]
\end{example}

\subsection{Elimination of the axiom from right parts}
It is always possible to obtain the right part of rules as strings by introducing a new axiom $S_0$ and the rule $S_0 \rightarrow S$.

\subsection{Normal form without nullable nonterminals}
A non-terminal $A$ is nullable if it can derive the empty string. 
Consider the set $\text{Null} \subseteq V$ of nullable non-terminals. 
The set is composed of the following logical clauses, applied until a fixed point is reached:
\[A \in \textnormal{Null} \implies\begin{cases}
    (A \rightarrow \varepsilon) \in P\\
    (A \rightarrow A_1A_2\dots A_n) \in P \qquad\:\: \textnormal{with } A_i \in V \setminus \{A\} \\
    \forall 1 \leq i \leq n \qquad\qquad\qquad\qquad \textnormal{with } A_i \in \textnormal{Null}
\end{cases}\]
The construction of the non-nullable form consists of:
\begin{enumerate}
    \item Compute the Null set. 
    \item For each rule within $P$, add as alternatives those obtained by deleting the nullable non-terminals from the right part.
    \item Remove all empty rules, except for $A=S$.
    \item Clean the grammar and remove any circularity.
\end{enumerate}
The normal form without nullable nonterminals requires that no nonterminal other than the axiom is nullable. 
In that case, the axiom is nullable only if the empty string $\varepsilon$ is in the language.

\subsection{Copy rules and their elimination}
Copy rules are utilized to factorize common parts, reducing the size of the grammar.
However, eliminating copy rules shortens derivations and reduces the height of syntax trees.
The typical trade-off involves defining the $\text{Copy}(A)\subseteq V$ set, representing nonterminals into which the nonterminal $A$ can be copied, possibly transitively:
\[\textnormal{Copy}(A)=\{B \in V \mid  \textnormal{there exists a derivation } A \implies B\}\]
To eliminate copy rules, the following steps are undertaken:
\begin{enumerate}
    \item Compute $\text{Copy}$ (assuming a grammar with non-empty rules) by applying logical clauses until a fixed point is reached. 
        This involves determining the reflexive transitive closure of the copy relation defined by the copy rules:
        \[C \in \textnormal{Copy}(A) \textnormal{ if } (B \in \textnormal{Copy}(A)) \land (B \rightarrow C \in P)\]
    \item  Define the rules of a grammar $G'$, equivalent to $G$ but without copy rules. 
        Remove the copy rules:
        \[P^{\prime}=P \setminus \{A \rightarrow B\mid A,B \in V\}\]
        Add compensating rules:
        \[P^{\prime}=P^{\prime}\cup\{A \rightarrow \alpha\mid\exists B (B \in \textnormal{Copy}(A) \land (B \rightarrow \alpha) \in P)\}\]
        The set of rule may increase considerably in size. 
\end{enumerate}

\subsection{Conversion of left recursion to right recursion}
Grammars without left recursion are necessary for designing top-down parsers. 
To convert from left recursion to right recursion, there are multiple possibilities. 
The main case involves the conversion of immediate left recursion:
\[\begin{cases}
    A \rightarrow A\beta_1\mid A\beta_2\mid \dots\mid A\beta_n \\
    A \rightarrow \gamma_1\mid \gamma_2\mid \dots\mid \gamma_k
\end{cases}\]
Here, $\beta_i \neq \varepsilon \: \forall i$. 
This grammar can be transformed into:
\[\begin{cases}
    A \rightarrow A^{\prime}\gamma_1\mid A^{\prime}\gamma_2\mid \dots\mid A^{\prime}\gamma_k\mid \gamma_1\mid \gamma_2\mid \dots\mid \gamma_k  \\
    A^{\prime} \rightarrow A^{\prime}\beta_1\mid A^{\prime}\beta_2\mid \dots\mid A^{\prime}\beta_h\mid \beta_1\mid \beta_2\mid \dots\mid \beta_h
\end{cases}\]
In this grammar, right recursion is achieved since the string is generated from the left.

\subsection{Chomsky normal form}
The Chomsky normal form consists of two types of rules:
\begin{enumerate}
    \item \textit{Homogeneous binary rules}: $A \rightarrow BC$ with $B,C \in V$.
    \item \textit{Terminal rules with a singleton right part}: $A \rightarrow a$ with $a \in \Sigma$.
\end{enumerate}
Syntax trees of this form have internal nodes of degree two and leaf parent nodes of degree one. 
The procedure to obtain the Chomsky normal form from a grammar $G$ is as follows:
\begin{itemize}
    \item If the language contains the empty string, add the rule: $S \rightarrow \varepsilon$.
    \item  Apply iteratively the following process:
        \begin{itemize}
            \item For each rule type $A_0 \rightarrow A_1A_2\dots A_n$.
            \item Add the rule type $A \rightarrow \left\langle A_1 \right\rangle\left\langle A_2\dots A_n\right\rangle$.
            \item Also, add another rule $\left\langle A_2\dots A_n\right\rangle \rightarrow A_2\dots A_n$.
        \end{itemize}
        After some iterations, $A$ will be terminal, resulting in $\left\langle A_1 \right\rangle \rightarrow A_1$.
\end{itemize}

\subsection{Real-time normal form}
In the real-time normal form, the right part of any rule has a terminal symbol as a prefix:
\[A \rightarrow a \alpha \textnormal{ with } a \in \Sigma, \alpha \in \{\Sigma \cup V\}^{\ast}\]
The name of this form derives from a property of syntax analysis: every step reads and consumes one terminal symbol. 
With this normal form, the number of steps for the analysis is proportional to the length of the string.

\subsection{Greibach normal form}
In the Greibach normal form, every right part consists of a terminal followed by zero or more nonterminals:
\[A \rightarrow a \alpha \textnormal{ with } a \in \Sigma, \alpha \in V^{\ast}\]