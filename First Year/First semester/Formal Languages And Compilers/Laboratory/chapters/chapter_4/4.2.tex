\section{Advanced compiler system for education}

ACSE is a basic compiler that takes in a source language similar to C, called LANCE, and generates an assembly language resembling RISC, named MACE.

The ACSE package includes two additional auxiliary tools, completing the entire toolchain:
\begin{itemize}
    \item Asm: an Assembler that converts assembly code into machine code.
    \item Mace: a Simulator for the fictional MACE processor.
\end{itemize}

The core elements of ACSE compiler are:
\begin{itemize}
    \item Scanner: FLEX source in \texttt{Acse.lex}
    \item Parser: BISON source in \texttt{Acse.y}
    \item Codegen: instruction generation functions \texttt{axe$\_$gencode.h}.
\end{itemize}
ACSE functions as a syntax-directed translator, meaning it generates instructions directly while parsing the source code. 
The sequence of compiled instructions is inherently determined by the syntax of the language. 
Unlike traditional compilers that initially build a syntactic tree (AST) before generating instructions, ACSE operates differently. 

Its main file, \texttt{Acse.y}, houses the BISON-syntax grammar of LANCE. 
Within this file, semantic actions are pivotal as they handle the actual translation process from LANCE source code to assembly instructions.

\subsection{Intermediate representation}
The intermediate representation is the data representation used in a compiler to represent the program.
In ACSE it is composed of two main parts: the instruction list, and the variable table. 

ACSE utilizes a RISC-like intermediate assembly language that closely resembles the final output, known as the MACE assembly language. 
This intermediate language comprises various instructions, including:
\begin{itemize}
    \item Arithmetic and logic instructions (e.g. \texttt{ADD}, \texttt{SUB}).
    \item Memory access instructions (e.g. \texttt{LOAD}, \texttt{STORE}).
    \item Conditional and unconditional branch instructions (e.g. \texttt{BEQ}, \texttt{BT}).
    \item Special I/O instructions (e.g. \texttt{READ}, \texttt{WRITE}).
\end{itemize}
Data storage in this assembly language can be achieved using either unbounded registers or unbounded memory locations.

\paragraph*{Registers}
In the context of ACSE, a register identifier is represented by an integer value that denotes a specific register within an infinite bank of registers. 
The value of the register identifier corresponds to the number of the register it represents. 
\begin{example}
    For instance:
    \begin{itemize}
        \item Register R0 has the register identifier 0.
        \item Register R10 has the register identifier 10.
    \end{itemize}
\end{example}
It's crucial to emphasize that performing any arithmetic or comparison operations directly on register identifiers is incorrect.

In ACSE, there are two special registers:
\begin{itemize}
    \item The zero register (R0) contains the constant value 0, and any writes to it are ignored.
    \item The status word or PSW (Program Status Word) is implicitly read from or written to by arithmetic instructions.
        The PSW register contains four single-bit flags, that are exploited mainly by conditional jump instructions:
        \begin{itemize}
            \item \texttt{N}: negative. 
            \item \texttt{Z}: zero. 
            \item \texttt{V}: overflow. 
            \item \texttt{C}: carry. 
        \end{itemize}
\end{itemize}

In ACSE, there exist fifteen conditional jump instructions, including:
\begin{itemize}
    \item \texttt{BT}: represents an unconditional branch.
    \item \texttt{BEQ}: indicates a branch if the last result was zero.
    \item \texttt{BNE}: signifies a branch if the last result was not zero.
\end{itemize}
Each arithmetic instruction in ACSE alters the Program Status Word (PSW) based on the outcome of the computation.
When encountering a branch instruction, the PSW is examined to determine whether branching should occur or not.