\section{Introduction}

\begin{definition}[\textit{Algorithm}]
    An algorithm is a step-by-step sequence of instructions designed to solve any given instance of a problem.
\end{definition}
\begin{definition}[\textit{Instance}]
    An instance, denoted as $I$, pertaining to a problem $P$, is a specific and unique case derived from the problem $P$.
\end{definition}

The runtime of an algorithm is contingent on both the specific instance and the computer it runs on. 
To assess the algorithm's complexity while abstracting from hardware variations, we focus on evaluating its performance as a function of the instance's size, independently of the underlying hardware. 
For this purpose, we consider the count of elementary operations, presuming that each operation carries an equivalent cost. 
Since determining the precise count of elementary operations is often a formidable task, we resort to considering the asymptotic count of elementary operations in the worst-case scenario.
\begin{definition}[\textit{Order of a function}]
    A function $f$ is denoted as being order of $g$ and expressed as:
    \[f(n)=\mathcal{O}(g(n))\]
    If there exists a positive constant $c$ such that $f(n)$ is less than or equal to $c \cdot g(n)$ for sufficiently large values of $n$.
\end{definition}
We can categorize algorithms into two primary classes based on their worst-case complexity:
\begin{itemize}
    \item \textit{Polynomial}: characterized by a complexity of $\mathcal{O}(n^d)$, where $d$ is a constant.
    \item \textit{Exponential}: demonstrating a complexity of $\mathcal{O}(2^n)$. 
\end{itemize}
Algorithms with a high-order polynomial complexity are generally considered inefficient in practical applications.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{images/complexity.png}
    \caption{Plot of various algorithm's complexity}
\end{figure}
\begin{definition}[\textit{Instance}]
    The size of an instance denoted as $\left\lvert I \right\rvert$ represents the number of bits required to represent that instance.
\end{definition}
\begin{definition}[\textit{Polynomially solvable}]
    A problem $P$ is considered polynomially solvable if there exists a polynomial time algorithm that can provide an optimal solution for any given instance.
\end{definition}
For many discrete optimization problems, the most efficient algorithm available today demands a number of elementary operations that, in the worst-case scenario, grows exponentially with the size of the instance.
\begin{definition}[\textit{$\mathcal{NP}$-hard}]
    $\mathcal{NP}$-hard computational problems are, at the very least, as challenging as a broad spectrum of exceptionally difficult problems for which no polynomial time algorithm has been identified to date.
\end{definition}
The $\mathcal{N}\mathcal{P}$-hardness of a problem is a very strong evidence that is inherently difficult. 
However, this doesn't imply that it cannot potentially be solved using a polynomial time algorithm.

\begin{definition}[\textit{Exact algorithm}]
    An algorithm is considered exact when it is capable of delivering an optimal solution for every single instance.
\end{definition}
\begin{definition}[\textit{Heuristic algorithm}]
    In contrast, an algorithm is deemed heuristic when it is not guaranteed to provide an optimal solution for all instances.
\end{definition}
\begin{definition}[\textit{Greedy algorithm}]
    A greedy algorithm progressively builds a feasible solution by consistently making locally optimal choices at each step, without revisiting or reevaluating prior selections.
\end{definition}

\subsection{Dynamic programming}
Dynamic programming, introduced by Richard Bellman in 1953, is a versatile method employed to find optimal solutions consisting of a sequence of elementary decisions.
This is achieved by resolving a series of recursive equations.

Dynamic programming is well-suited for a wide range of sequential decision problems as long as they adhere to the optimality property.

In contemporary applications, dynamic programming finds utility across various domains, including optimal control, equipment maintenance and replacement, and the selection of inspection points along a production line.