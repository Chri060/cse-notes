\section{Testing}

Consider the following function \texttt{foo2}, written in a C-like language:
\begin{lstlisting}[style=C]
0: void foo2(int a, int b) {
1:      int x = 1;
2:      if (a>b && a>0 && b>1) {
3:          for (int i=0; i<b; i++)
4:              x = x*a;
5:      if (x < rand(1,10))
6:          print("Log message");
7:      } 
8: }
\end{lstlisting}
\begin{enumerate}
    \item Run concolic execution to explore all possible branches. 
    \item Write the pseudocode of a possible generational fuzzer that should test \texttt{foo2}.
    \item Given the fuzzer defined in the previous point, what is the chance of executing a path that includes location six?
    \item How much time do you have to wait on average assuming that a single execution takes $\approx 1$ ms?
    \item Consider an SBST procedure with the objective of executing paths that reach location six. 
        Define proper search space, neighborhood relation, and fitness function to use such approach. 
\end{enumerate}

\paragraph*{Solution}
\begin{enumerate}
    \item For the concolic execution we have to run the following test cases to cover all paths: 
        \begin{itemize}
            \item Test case $\{a = 1, b = 2\}$ executes the false branch of condition two.
            \item Test case $\{a = 4, b = 2\}$ executes the true branch of condition two. 
            \item In this case, the test case $\{a=3, b=2\}$ executes true branch for both conditions two and five. 
        \end{itemize}
        In all this cases we assumed that the \texttt{rand()} function returns always ten. 
    \item A possible generational fuzzer is as follows: 
        \begin{lstlisting}[style=C]
0: int[] fuzzer() {
1:      int b = rand();
2:      int a = rand();
3:      return [a,b]; 
4: }
        \end{lstlisting}
    \item Assume that \texttt{rand()} returns a random integer without constraints. 
        To execute location six, we need to generate inputs that satisfy the following conditions: 
        \[A>B \land B=2 \land A*A<rand(1,10)\]
        The only possible solution is $\{a=3,b=2\}$. 
        Assuming 32-bit encoding for integers, the range is $[-2147483648, 2147483647]$. 
        The total chance is: 
        \[P(a=3 \land b=2 \land \texttt{rand}(1,10)=10)=\left(\dfrac{1}{4,3\cdot 10^9}\right)\cdot\left(\dfrac{1}{4,3\cdot 10^9}\right)\cdot\left(\dfrac{1}{10}\right)=5,4\cdot 10^{-21}\]
        The average number of runs is given by the inverse of the probability, that is: 
        \[\# \text{runs}= \dfrac{1}{P(a=3 \land b=2 \land \texttt{rand}(1,10)=10)}=\dfrac{1}{5,4\cdot 10^{-21}}=1,8 \cdot 10^{20}\]
    \item The execution time is given by the runs multiplied by the execution of each run, that is: 
        \[\text{execution time}=\# \text{runs} \cdot \text{time}= 10^{20} \cdot 0,001 =5.7\cdot 10^{9}  \text{ years}\]
    \item By looking at the source code we need to generate values for \texttt{a} and \texttt{b} such that both conditions two and five are true. 
        We can now define
        \begin{itemize}
            \item Search space: all possible pairs of integer values. 
            \item Neighborhood relation: given a pair, we possibly modify each element of the pair by one.
                In this case for each pair we have eight pairs in total. 
                For example we may have $\left\langle 1,1 \right\rangle \rightarrow \left\langle 0,0 \right\rangle, \left\langle 0,1 \right\rangle, \left\langle 0,2 \right\rangle, \left\langle 1,0 \right\rangle, \left\langle 1,2 \right\rangle, \left\langle 2,0 \right\rangle, \left\langle 2,1 \right\rangle, \left\langle 2,2 \right\rangle$.
            \item Fitness function: consider the distance from the branches we want to execute. 
                For the \texttt{if} in line two the total distance is the sum of all distances from the three conditions. 
                Each distance should be normalized to avoid biased search (some distances may depend on very large values, some other distances on very small values): 
                \begin{lstlisting}[style=C]
0: int dist1(int a, int b) {
1:      return norm(dist_subb1(a,b))+ norm(dist_subb2(a)) + norm(dist_subb3(b));
2: }
                \end{lstlisting}
                We have to do the same for the \texttt{if} in the fifth line: 
                \begin{lstlisting}[style=C]
0: int dist2(int x, int rand(1,10)) { 
1:      return norm(dist_subb1(rand(1,10),x)); 
2: }
                \end{lstlisting}
                Now we have that the fitness can be defined as the sum of \texttt{dist1} and \texttt{dist2}. 
                When the sum is zero it means we execute the true branch of both conditions. 
                The test case generation shall minimize the sum. 
        \end{itemize}
\end{enumerate}