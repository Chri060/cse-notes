\section{Locks}

The prevalent method in commercial systems is the use of locking. 
A transaction is considered well-formed concerning locking if:
\begin{itemize}
    \item Read operations are preceded by r\_lock (shared) and followed by unlock. 
    \item Write operations are preceded by w\_lock (exclusive) and followed by unlock. 
\end{itemize}
In both cases, unlocking can be delayed with respect to the completion of the operations. 
Consequently, every object can be in one of three states: free, r\_locked, or w\_locked.
Transactions that first read and then write an object may acquire a w\_lock already when reading or acquire a r\_lock first and then upgrade it into a w\_lock (escalation).

\paragraph*{Conflict table}
The lock manager receives requests from transactions and allocates resources based on the conflict table:
\begin{table}[H]
    \centering
    \begin{tabular}{cccc}
    \textbf{}                              & \multicolumn{3}{c}{\textbf{Resource status}}                                                                                                                                                                                                                               \\ \cline{2-4} 
    \multicolumn{1}{c|}{\textbf{Request}}  & \multicolumn{1}{c}{\textit{FREE}}                                                      & \multicolumn{1}{c}{\textit{R\_LOCKED}}                                                    & \multicolumn{1}{c|}{\textit{W\_LOCKED}}                                               \\ \hline
    \multicolumn{1}{|c|}{\textit{r\_lock}} & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}\checkmark\\ R\_LOCKED\end{tabular}}     & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}\checkmark\\ R\_LOCKED($n++$)\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\tikzxmark\\ W\_LOCKED\end{tabular}}   \\ 
    \multicolumn{1}{|c|}{\textit{w\_lock}} & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}\checkmark\\ W\_LOCKED\end{tabular}}     & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}\tikzxmark\\ R\_LOCKED\end{tabular}}        & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\tikzxmark\\ W\_LOCKED\end{tabular}}   \\ 
    \multicolumn{1}{|c|}{\textit{unlock}}  & \multicolumn{1}{c}{ERROR}                                                              & \multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}\checkmark\\ $n--$\end{tabular}}            & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\checkmark\\ FREE\end{tabular}}        \\ \hline
    \end{tabular}
\end{table}

\paragraph*{Lock tables}
The locking system is implemented via lock tables, which are hash tables indexing lockable items via hashing. 
Each locked item has an associated linked list, with each node representing the transaction that requested the lock, the lock mode, and the current status. 
Each new lock request for the data item is appended to the list.

\subsection{Two-phase locking}
The previously presented locking mechanism does not eliminate anomalies caused by non-repeatable reads. 
To address this issue, a two-phase rule can be employed, requiring that a transaction cannot acquire any other lock after releasing one. 
This approach involves three phases: acquiring all locks, executing operations, and finally, unlocking.
\begin{definition}[\textit{Two-phase locking}]
    The class of two-phase locking is the set of all schedules generated by a scheduler that: only processes well-formed transactions, grant locks according to the conflict table, and checks that all transactions apply the two-phase rule.             
\end{definition}
\begin{property}
    2PL is a strict subset of CSR. 
\end{property}
\begin{proof}
    We assume that a schedule $S$ is 2PL. Consider, for each transaction, the moment in which it holds all locks and is going to release the first one. 
    We sort the transactions by this temporal value and consider the corresponding serial schedule $S^\prime$. 
    We want to prove by contradiction that $S$ is C to $S^\prime$: 
    \[S^\prime\approx_CS,\dots\]
    Consider a generic conflict $o_i \rightarrow o_j$ in $S^\prime$ with $o_i \in T_i$, $0_j \in T_j$, and $i<j$. 
    By definition of conflict, $o_i$ and $o_j$ address the same resource $r$, and at least one of them is write. 
    The two operations cannot occur in reverse order of $S$. 
    This proves that all 2PL schedules are VSR. 
\end{proof}
\begin{property}
    2PL implies CSR.
\end{property}
In this state, the remaining anomalies are limited to phantom inserts (requiring predicate locks) and dirty reads.

\subsection{Strict two-phase locking}
\begin{definition}[\textit{Strict two-phase locking}]
    In strict two-phase locking (or long duration locks) we also have that locks held by a transaction can be released only after commit or rollback.
\end{definition}
This locking variant is employed in many commercial DBMS when a high level of isolation is necessary.

\paragraph*{Predicate locking}
To counteract phantom inserts, a lock should also be applied to future data using predicate locks. 
When a predicate lock is placed on a resource, other transactions are restricted from inserting, deleting, or updating any tuple that satisfies this predicate.