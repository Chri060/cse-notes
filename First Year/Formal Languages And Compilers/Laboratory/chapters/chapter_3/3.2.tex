\section{File format}

A BISON file is divided into four sections delineated by $\%\%$:
\begin{enumerate}
    \item \textit{Prologue}: this is a convenient section to include header file inclusions and declare variables.
    \item \textit{Definitions}: this section encompasses the definition of tokens, operator precedence, and non-terminal types.
    \item \textit{Rules}: this section comprises the grammar rules.
    \item \textit{User code}: typically containing C code, including helper functions.
\end{enumerate}

\subsection{Definitions}
The most important part of the definitions sections are the token declarations: \\
\texttt{$\%$token IF ELSE WHILE DO FOR} \\
BISON also generates a header file which defines a code for each token. 
This allows the scanner to know these codes.

\subsection{Rules}
Grammar rules are specified in Backus Normal Form notation.
If not specified, the left-hand side of the first rule is the axiom.
\begin{example}
    An example of BNF grammar is as follows:  \\
    \begin{lstlisting}[style=C]
sections : sections section
          | /* empty */
          ;
section : LSQUARE ID RSQUARE options
         ;
options : options option
         | option
         ;
option : ID EQUALS NUMBER
        ID EQUALS STRING
        ;
    \end{lstlisting}
\end{example}

Similar to FLEX, BISON permits the specification of semantic actions within grammar rules. 
A semantic action is a standard C code block that can be designated at the conclusion of each rule alternative.
Semantic actions are executed when the rule they are associated with has been completely recognized. 
The consequence is that the order of execution of the actions is bottom-up with respect to the syntactic tree. 
You can also place semantic actions in the middle of a rule.
In this case BISON normalizes the grammar in order to have only end-of-rule actions. 

\paragraph*{Semantic values}
The concept of semantic values operates as follows:
\begin{itemize}
    \item Each parsed token or non-terminal is associated with a variable.
    \item For tokens, their value is assigned in the lexer.
    \item For non-terminals, their value is assigned in the semantic action(s) of that non-terminal.
    \item The value of these variables is then accessed in the rules that utilize the corresponding token or non-terminal.
\end{itemize}

The types of each semantic value are outlined in the definition section as follows:
\begin{itemize}
    \item The \texttt{$\%$union} declaration specifies the complete range of potential data types.
    \item Type specifications for terminals (tokens) are delineated in the token declaration.
    \item Type specifications for non-terminals are defined through special \texttt{$\%$type} declarations.
\end{itemize}
\begin{example}
    \begin{lstlisting}[style=C]
%union {
    int int_val;                    %token <str_value > ID
    const char *str_val;            %token <str_value > STRING
    option_t option_val;            %token <int_val > NUMBER
}                                   %type <option_val > option
    \end{lstlisting}
\end{example}
In a production, the semantic value of each grammar symbol is represented by a variable called \$i, where i denotes the position of the symbol.
\begin{itemize}
    \item \$\$ corresponds to the semantic value of the rule itself. 
    \item Mid-rule actions are included in the numbering.
    \item However, mid-rule actions are subject to additional constraints:
        \begin{itemize}
            \item Accessing values of symbols that appear later is prohibited.
            \item Using \$\$* is not allowed.
        \end{itemize}
\end{itemize}
\begin{example}
    Consider the following grammar: 
    \begin{lstlisting}[style=C]
section : LSQUARE
           ID
           RSQUARE
           { printf("%s", $2); }
           options
           { $$ = create_section($2, $5); }
           ;
    \end{lstlisting}
    We have the following semantic values: 
    \begin{itemize}
        \item \$\$ to \texttt{section}. 
        \item \$1 to \texttt{LSQUARE}. 
        \item \$2 to \texttt{ID}. 
        \item \$3 to \texttt{RSQUARE}. 
        \item \$4 to \texttt{{ printf("\%s", \$2); }}. 
        \item \$5 to \texttt{options}. 
    \end{itemize}
\end{example}
In the generated code, BISON declares the global variable \texttt{yylval}, which serves the following purpose:
\begin{itemize}
    \item It stores the semantic value of the most recent token returned by \texttt{yylex()}.
    \item Its type is a union of the types declared in the BISON source.
\end{itemize}
This setup enables the scanner to assign the semantic value of a token: before returning the token value, the flex semantic action sets yylval accordingly.