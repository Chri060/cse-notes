\section{Static analysis}

Static analysis is a methodology employed by compilers to examine certain properties of the source code prior to the compilation phase.
Various analyses can be classified based on their intended objectives, including:
\begin{itemize}
    \item \textit{Verification}: this involves examining the correctness of the program.
    \item \textit{Optimization}: the goal is to enhance the efficiency of the program.
    \item \textit{Scheduling and parallelizing}: this aims to alter the program's execution order to exploit parallelism.
\end{itemize}
In these scenarios, a control-flow graph is employed, which is a directed graph resembling a program flowchart. 
This graph can be conveniently interpreted as representing the state-transition function of a finite automaton. 
Static analysis involves scrutinizing this graph using various techniques.
It is crucial to note that the control-flow graph only reflects the source code of an individual program, not the entire source language. 
Static flow analysis should not be conflated with syntax-driven translation.

\subsection{Program as an automaton}
The control-flow graph serves as an abstraction of a program and can be likened to a Finite State Automaton (FSA). Its key components are detailed below:
\begin{itemize}
    \item Each node represent an instruction. 
        Instructions are simplified compared to those in the source language.
        Typical instructions include assignments, jumps, arithmetic operations, and more.
        Operands consist solely of simple variables and constants.
    \item Each arc signifies a possible control flow. 
        If an instruction $p$ is followed by $q$, a directed arc is present from $p$ to $q$.
        Unconditional instructions have at most one successor.
        Conditional instructions have two (or more) successors.
        An instruction with two or more predecessors creates a confluence of arcs in the graph.
    \item The first instruction of the program serves as the entry point, corresponding to the initial node.
    \item The last instruction of the program serves as the exit point, corresponding to the final node.
\end{itemize}
While a control-flow graph is a valuable representation, it lacks certain details of the program:
\begin{itemize}
  \item The \texttt{true}/\texttt{false} value determining the successor of a conditional instruction.
  \item The node representing a \texttt{goto} instruction is absent, as it is simplified to an arc to the successor instruction.
  \item Any operations executed by an instruction are abstracted. 
    A value assignment is considered to define a variable.
    If a variable appears in the Right-Hand Part (RHP) of an expression or boolean condition, it is deemed used.
    A node representing a statement $p$ in the graph is associated with set $\text{def}(p)$ of defined variables and set $\text{use}(p)$ of used variables. 
\end{itemize}
\begin{definition}[\textit{Language of the control-flow graph}]
    Consider a finite state automaton $A$, depicted as a control-flow graph.
     Its terminal alphabet is the set $I$ of program instructions, with each instruction represented by a $3$-tuple:
    \[ \left\langle \texttt{label}, \texttt{defined variables}, \texttt{used variables} \right\rangle \]
    The language $L(A)$ recognized by the automaton comprises strings over the alphabet $I$. 
    These strings label the paths from the initial node (the entry point) to the final node (the exit point).
    Each string in $L(A)$ signifies a sequence of program instructions that the machine can execute when the program runs.
\end{definition}
Furthermore, language $L$ is local.

\paragraph*{Conservative approximation}
The automaton provides only an approximation of the valid execution paths of a program. 
It does not guarantee that all paths specified are executable, as it does not perform syntax analysis on the conditions governing the selection of successor nodes in conditional instructions.
\begin{example}
    Consider the following code snippet: 
    \begin{verbatim}
        1: if x^2 >= 0 then
        2: instruction_2 else
        3: instruction_3
    \end{verbatim}
    The formal language accepted by the automaton contains two paths:
    \[ \left\{ 1 \: 2,  1 \: 3 \right\} \]
    However, the second path is not executable, as the condition is always true.
\end{example}
As a result, static analysis can sometimes lead to pessimistic conclusions (discovering never-executed code paths). 
Determining whether a path in a control-flow graph will ever be executed by the program is undecidable, reducing the problem to the halting problem.

Analyzing all recognized paths is a conservative approximation to a program. 
While it may identify non-existing errors or erroneously assign resources, it ensures that real errors will never be missed. 
Despite its potential inefficiency, this method is deemed \textbf{error safe}.

A common assumption in static analysis is that the automaton is clean, meaning every instruction is on a path from the entry point to the exit point. 
Deviations from this assumption can lead to anomalies:
\begin{itemize}
    \item Some executions may not reach the exit point.
    \item Some instructions may remain unexecuted (dead code).
\end{itemize}

\subsection{Liveness of a variable}
A professional compiler undergoes multiple analysis passes to optimize code, with one of the most crucial being the analysis of variable liveness, determining the duration for which the value of a variable is required.

\paragraph*{Variable liveness}

A variable $a$ is considered live upon exiting a program node $p$  if there exists a path from $p$ to another node $q$ (not necessarily distinct from $p$) in the program's control-flow graph. 
This path must satisfy the following conditions:
\begin{itemize}
    \item The path does not traverse an instruction $r \neq q$ that defines $a$. 
        If $r$ defines $a$, then $a \in \text{def}\left(r\right)$.
    \item The instruction $q$ uses $a$. 
        If $q$ uses $a$, then $a \in \text{use}\left(q\right)$.
\end{itemize}
In simpler terms, a variable is considered live out of a particular node if some instruction that could be subsequently executed utilizes the value that the variable held in the former node. 
If the variable is reassigned before its next use, it is not live out of the node. 
More precisely, a variable is live-out for a node if it is live on any outgoing arc from that node. 
Similarly, a variable is live-in for a node if it is live on some incoming arc to the node.

\paragraph*{Computing liveness intervals}
Let $I$ denote the instruction set, and let $D(a)(I) \subseteq I$ and $U(a)(I) \subseteq I$ represent the sets of instructions defining and using variable $a$, respectively.
Variable $a$ is considered live out of an instruction $p$ if and only if, for the language $L(A)$ accepted by the automaton, condition is satisfied:
the language $L(A)$ contains a sentence $x = u p v q w$, where:
\begin{itemize}
    \item $u, w$ are arbitrary sequences of instructions (possibly empty). 
    \item $p$ is any instruction. 
    \item $v$ is a possibly empty instruction sequence not containing a definition of $a$. 
    \item $q$ is an instruction that uses $a$. 
\end{itemize}
These conditions are formalized by the equation:
\[ u, w \in I^{*} \land p \in I \land v \in \left( I \setminus D\left( a \right) \right) \land q \in U\left( a \right) \]
Here, the set difference contains all instructions that do not define $a$, while $q$ uses $a$.
The set of all strings $x$ satisfying this condition, denoted as $L_p$ is a subset of the language $L(A)$ recognized by the automaton.
$L_p$  is regular because it can be defined by the intersection:
\[ L_p = L(A) \cap R_p \]
where $R_p$ is the regular language defined by the regular expression:
\[ R_p = I^{*} p \left( I \setminus D \left( a \right) \right)^{*} U \left( a \right) I^{*} \]
The definition of $R_p$ and $L_p$ specifies that the symbol $p$ must be followed by a symbol $q$ from the set $U\left( a \right)$, and all symbols between $p$ and $q$ must not be in set $D\left( a \right)$.
To check if a variable is live out of node $p$, it is sufficient to verify if $L_p \neq \emptyset$. 
This can be achieved by building the recognizer as the product of machine $A$ and the recognizer of $R_p$.
If no path connects the input node to the final node, then $L_p$ is empty.

However, this procedure is not efficient given the large number of variables and instructions in real-world programs. 
A more efficient technique is data-flow analysis, which examines all paths from any instruction to another instruction using the same variable.

\paragraph*{Data-Flow equations}
The computation of liveness is articulated through a system of data-flow equations. 
Let's consider a node $p$ in a program $A$.
The equations establish the relationship between variables that are live out (denoted $\text{live}_\text{out}\left( p \right)$) and those live in (denoted by $\text{live}_\text{in}\left( p \right)$) for the node. 
Additionally, they express the connection between variables live out of a node and those live in for its successors.
Here, $\text{succ}\left( p \right)$ denotes the set of (eventually immediate) successors of node $p$ and $\text{var}(A)$ is the set of all variables in program $A$.
\begin{definition}[\textit{Data-flow equations}]
      For each final node $p$:
      \[ \text{live}_\text{out}\left( p \right) = \emptyset \]
      For any other node $p$:
      \[ \text{live}_\text{in}\left( p \right) = \text{use}\left( p \right) \cup \left( \text{live}_\text{out} \left( p \right) \setminus \text{def}\left( p \right) \right) \]
      \[ \text{live}_\text{out}\left( p \right) = \bigcup_{q \in \text{succ}\left( p \right)} \text{live}_\text{in}\left( q \right) \]
\end{definition}

\paragraph*{Solution of data-flow equations}
In the context of a control-flow graph with a total of $|I| = n \geq 1$ nodes, the resulting system gives rise to $2 \cdot n$ equations involving $2 \cdot n$ unknown variables: $\text{live}_\text{in}\left( p \right)$ and $\text{live}_\text{out}\left( p \right)$ for each node $p \in I$.
Each unknown is a set of variables, and the solution sought is a pair of vectors, each containing $n$ sets.

To solve the system of equations, an iterative approach is employed, starting with the empty set as the initial approximation ($i=0$) for every unknown:
\[ \forall \: p \in I \quad \text{live}_\text{in}\left( p \right) = \emptyset \quad \text{live}_\text{out} \left( p \right) = \emptyset \]
At each iteration $i$, for each equation in the system defined, the unknowns on the right-hand side are replaced with the values computed in the previous iteration.
The new iteration $i + 1$ is then calculated.
The iteration process halts when the values computed in the last iteration are equal to those computed in the previous iteration (a fixed point is reached). 
This solution is termed the least fixed point solution of the transformation that computes a new vector from one of the preceding iterations.

A finite number of iterations is always sufficient to compute the least fixed point solution because:
\begin{itemize}
  \item Every set $\text{live}_\text{in}\left( p \right)$ and $\text{live}_\text{out}\left( p \right)$ is finite, given the finite number of variables.
  \item Each iteration either increases the cardinality of the aforementioned sets of variables or leaves them unchanged, as the equation is monotonic.
  \item When the solution ceases to change, the algorithm terminates.
\end{itemize}

\subsection{Application of Liveness Analysis}
\paragraph*{Memory allocation}
Liveness Analysis is particularly valuable for determining whether two variables can share the same memory cell. 
If two variables are live-in at the same program instruction, then they must be stored in different memory cells. 
This is indicative of the two variables interfering with each other. 
Conversely, if two variables do not interfere, it implies that they can be stored in the same memory cell.

\paragraph*{Useless instructions}
An instruction that defines a variable is deemed useless if the assigned value to the variable is never utilized by any subsequent instruction; in other words, the value is not live-out for the defining instruction. 
To ascertain the uselessness of the definition of a variable $a$ by instruction $p$, it suffices to check if $\text{live}_\text{out}\left( p \right) \not\subseteq \left\{ a \right\}$.

\subsection{Reaching definition analysis}
Another fundamental type of static analysis involves the search for a variable definition that reaches a specified instruction. 
In particular, this is crucial when an instruction assigns a constant value to a variable. 
The compiler examines the program to determine if this constant can replace the variable in subsequent instructions using it. 
This transformation offers two advantages:
\begin{enumerate}
    \item \textit{Reduced memory access and increased speed}: by replacing the variable with a constant value, the number of memory accesses is reduced, potentially leading to a faster program.
    \item \textit{Compile-time evaluation}: obtaining an expression where all operands are constants allows for compile-time evaluation.
\end{enumerate}
The second transformation is termed constant propagation. 
\begin{definition}[\textit{Reaching definition}]
    The definition of a variable $a$ at instruction $q$ \textit{(denoted as $a_q$)} reaches the input of an instruction $p$ (not necessarily different from $q$) if there exists a path from $q$ to $p$ that does not contain any redefinition of $a$.
\end{definition}
This implies that instruction $p$ can access and use the value of the variable $a$ defined in instruction $q$.

\paragraph*{Reaching definition and regular expressions}
The definition $a_q$ reaches instruction $p$ if language $L(A)$ contains a sentence of the form $x = u q v p w$, where:
\begin{itemize}
    \item $u, w$ are arbitrary sequences of instructions (possibly empty). 
    \item $p$ is any instruction.
    \item $v$ is a sequence of instructions that do not contain any definition of $a$ (possibly empty).
    \item $q$ is an instruction that defines $a$.
\end{itemize}
The condition is represented by the following regular expression:
\[ u, w \in I^{*} \land q \in D\left( a \right) \land v \in \left( I \setminus D \left( a \right)\right)^{*} \land p \in I \]
where $p, q$ may coincide.

\paragraph*{Reaching definition and data-flow equations}
If node $p$ defines variable $a$, any other definition $a_q$ of the same variable in another node $q$, with $q \neq p$ is suppressed by $p$.
The set of definitions suppressed by instruction $p$ is given by:
\[
\begin{cases}
    \text{sup}(p) = \emptyset \quad                                                                                             & \text{if} \ \text{def}(p) = \emptyset    \\
    \text{sup}(p) = \left\{ a_q \mid q \in I \land q \neq p \land a \in \text{def} (q) \land a \in \text{def}(p) \right\} \quad & \text{if} \ \text{def}(p) \neq \emptyset
\end{cases}
\]

\paragraph*{Data-flow equations}
For the initial node $1$:
\[\text{in}(1) = \emptyset\]
For any other node $p \in I$:
\[\text{out}(p) = \text{def}(p) \cup \left( \text{in}(p) \setminus \text{sup}(p) \right)\]
\[\text{in}(p) = \bigcup_{\forall q \in  \text{pred}(p)} \text{out}(q)\]
Similar to the liveness equations, the reaching definition system can be solved through iteration until the computed solution converges to a fixed point; initially, all sets are empty. 
The set $\text{out}^{'}$ represents the elements of $\text{out}$ reaching the exit node starting from node $q$, but with their subscripts deleted.

\paragraph*{Explanation}
\begin{itemize}
    \item The initial data flow equations presuppose the absence of variables passed as input parameters to the subprogram.
        If there are input parameters, $\text{in}(1)$ would then comprise the set of these 
    \item The subsequent data flow equations incorporate into the exit from node $p$ all local definitions of $p$ and the definitions reaching the entrance to $p$, unless the latter are overridden by $p$.
    \item The final data flow equations assert that any definition reaching the exit of a predecessor node also reaches the entrance to node $p$.
\end{itemize}

\paragraph*{Constant propagation}
The constant propagation problem is the search for constant expressions that can be evaluated at compile time.
In the instruction $p$, it is safe to replace with a constant $k$ any variable $a$ used in $p$ if the following conditions hold:
\begin{enumerate}
    \item There exists and instruction $q : a := k$, such that $a_q$ reaches $p$
    \item No other definition $a_r$ of variable $a$ reaches the entrance of $p$, with $r \neq q$
\end{enumerate}

\paragraph*{Availability of variables and initialization}
A basic correctness check performed by a compiler is to verify that all the variables are initialized before their first use;
more generally, a variable used in some instruction must be available at the entrance of that instruction.
\begin{definition}[\textit{Variable availability}]
  A variable $a$ is available at the entrance of instruction $p$ (just before its execution) if in the program control-flow graph every path from the initial node $1$ to the entrance of $p$ contains a statement that defines variable $a$.
\end{definition}
\begin{definition}[\textit{Badly initialized variables}]
    An instruction $p$ is not well initialized if the following predicate holds:
    \[ \exists q \in \text{pred}(p) \textnormal{ such that } use(p) \nsubseteq \text{out}^{'}(q) \]
\end{definition}
The condition says that there exists a node $q$ predecessor of $p$ such that the definition of reaching its exit does not include all the variables used in $p$.
Therefore, when the program execution runs on a path through $q$, one or more variables used in $p$ don't have a value.