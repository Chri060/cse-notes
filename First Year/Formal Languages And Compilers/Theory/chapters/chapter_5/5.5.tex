\section{Syntax analysis of nondeterministic grammars}

The Earley method, also known as the tabular method, is versatile and applicable to grammars of any type, including those that are ambiguous and non-deterministic. 
This approach simultaneously constructs all potential derivations of the scanned string prefix, eliminating the need for explicit look-ahead implementation.
Moreover, it operates without a stack, instead utilizing a vector of sets to manage the current parsing state.
When analyzing a string $x = x_1 x_2, \dots, x_n$ or $x = \varepsilon$ with a length $|x| = n \geq 0$, the algorithm employs a vector $E\left[ 0, \dots, n \right]$ consisting of $n+1$ elements.
Every element $E[i]$ is a set of pairs $\langle q_\oplus, j\rangle$, where:
\begin{itemize}
    \item $q_\oplus$ is a state of machine $M_\oplus$. 
    \item $j$ is an integer pointer indicating the element $E[i]$ (with $0 \leq i \leq j \leq n$) that precedes or corresponds to $E[j]$. 
        It contains a pair $\langle 0_\oplus, j \rangle$: 
        \begin{itemize}
            \item $0_\oplus$ belongs to the same machine as $q_\oplus$.
            \item $j$ marks the position in the input string $x$ from which the current derivation of $\oplus$ started, represented by $\uparrow$. 
            \item If $j = i$, the string is empty $\varepsilon$. 
        \end{itemize}
\end{itemize}
A pair $\langle q_\oplus, j \rangle$ is categorized as:
\begin{itemize}
    \item \textit{Initial} if $q_\oplus = 0_\oplus$.
    \item \textit{Final} if $q_\oplus \in F_\oplus$.
    \item \textit{Axiomatic} if $\oplus = S$.
\end{itemize}

\subsection{Earley's Method}
The Earley method commences with the initialization of the Earley vector. 
Here, all elements $E[1],\dots, E[n]$ are set to the empty set ($E[i] = \emptyset \, \forall 1 \leq i < n$), and the first element $E[0]$ is assigned the set containing the initial pair $\langle 0_S, 0 \rangle$. 
In this pair, the state $0_S$ corresponds to the initial state of the machine $M_S$ associated with the start symbol $S$, and the integer pointer $0$ denotes the position in the input string from which the current derivation of $S$ originates.
As parsing progresses, with the current character being $x_i$, the current element $E[i]$ becomes populated with one or more pairs. 
The final Earley vector encompasses all possible derivations of the input string.
Three distinct operations are applicable to the current element of the vector $E[i]$: closure, terminal shift, and nonterminal shift.
These operations mirror those of the analogous ELR(1) parser.

\paragraph*{Closure}
This operation is applicable to a pair originating from a state with an arc labeled with a nonterminal $\oplus$.
Let $\langle p, j \rangle$ be a pair in the element $E[i]$, and suppose there exists an arc $p \xrightarrow{\oplus} q$ with a nonterminal label $\oplus$ and a (non-relevant) destination state $q$.
The operation adds a new pair $\langle 0_\oplus, i \rangle$ to the same element $E[i]$: the state of this pair is the initial one $0_\oplus$ of machine $M_\oplus$ of that nonterminal $\oplus$, and the pointer has value $i$, which means that the pair is created at step $i$ starting from a pair already in the element $E[i]$. 
The effect of this operation is to add the current element $E[i]$ to all the pairs with the initial states of the machines that can recognize a substring starting from the next character $x_{i+1}$ and ending at the current character $x_i$.

\paragraph*{Terminal shift}
This operation applies to a pair with a state from where a terminal shift arc originates.
Suppose that arc $\langle p, j \rangle$ is in element $E[i-1]$ and that the net has arc $p \xrightarrow{x_i} q$ labelled by the current token $x_i$.
The operation writes into element $E[i]$ the pair $\langle q, j \rangle$, where the state is the destination of the arc and the point equals that of the pair in $E[i-1]$, to which the terminal shift arc is attached.
The next token will be $x_{i+1}$ (the first one after the current).

\paragraph*{Nonterminal shift}
This operation is triggered by the presence of a final pair $\langle f_\oplus, j \rangle$ in the current element $E[i]$, where $f_\oplus \in F_\oplus$ is a final state of machine $M_\oplus$ of nonterminal $\oplus$;
such a pair is called enabling.
In order to shift, it's necessary to locate the element $E[j]$ and shift the corresponding nonterminal:
the parser searches for a pair $\langle p, l \rangle$ such that the net contains an arc $p \xrightarrow{\oplus} q$, with a label that matches the machine of state $f_\oplus$ in the enabling pair.
The pointer $l$ is in the interval $\left[ 0, j \right]$.
The operation will certainly find at least one such pair and the nonterminal shift applies to it.
Then the operation writes the pair $\langle q, l\rangle$ into $E[i]$; if more than one pair is found, the operation is applied to all of them.

\paragraph*{Earley's algorithm}
The algorithm designed for EBNF grammars incorporates two procedures known as \texttt{completion} and \texttt{terminalshift}.
The input string is represented as $x = x_1 x_2 \,\ldots\, x_n$, where $|x| = n \geq 0$ (if $n = 0$, then $x = \varepsilon$).
\begin{algorithm}[H]
  \caption{completion(E, i)}
      \begin{algorithmic}[1]
          \While {some pair has been added}
              \For {each pair $\left\langle p,j \right\rangle \in E[i]$ and $X,q \in V$ such that $p \overset{X}{\rightarrow}q$}
                  \State add pair $\left\langle 0_X,i \right\rangle$ to element $E[i]$
              \EndFor
              \For {each pair $\left\langle f,j \right\rangle \in E[i]$ and $X \in V$ such that $f \in F_X$}
                  \For {each pair $\left\langle p,l \right\rangle \in E[j]$ and $q \in Q$ such that $p \overset{X}{\rightarrow}q$}
                      \State add pair $\left\langle q,l \right\rangle$ to element $E[i]$
                  \EndFor
              \EndFor
          \EndWhile 
      \end{algorithmic}
\end{algorithm}
The completion procedure extends the current vector element $E[i]$ by incorporating new pairs through the application of closure and nonterminal shifts, iteratively adding pairs as long as new ones emerge.
The outer loop (\texttt{do-while}) ensures at least one execution, given that the closure operation is consistently applied.
It is important to emphasize that this operation handles nullable nonterminals by employing a combination of closures and nonterminal shifts.
\begin{algorithm}[H]
  \caption{terminalshift(E, i)}
      \begin{algorithmic}[1]
          \For {each pair $\left\langle p,j \right\rangle \in E[i-1]$ and $q \in Q$ such that $p \overset{x_i}{\rightarrow}q$}
              \State add pair $\left\langle q,j \right\rangle$ to element $E[i]$
          \EndFor
      \end{algorithmic}
\end{algorithm}
The \texttt{terminalshift} procedure augments the current vector element $E[i]$ by incorporating all pairs reachable from the pairs in $E[i-1]$ through a terminal shift, scanning token $x_i$, where $1 \leq i \leq n$.
It is possible that no pairs are added to the element, and it remains empty. 
A nonterminal exclusively generating the empty string $\varepsilon$ does not undergo a terminal shift.
Importantly, the procedure functions correctly even when the element $E[i]$ or its predecessor $E[i-1]$ is empty.
\begin{algorithm}[H]
  \caption{Early method algorithm}
      \begin{algorithmic}[1]
          \State $E[0] \leftarrow \{\left\langle 0_S,0 \right\rangle \}$
          \For {$i=1 \textnormal{ to } n$}
              \State $E[i] \leftarrow \varnothing$
          \EndFor
          \State $Completion(E,0)$
          \State $i \leftarrow 1$
          \While {$i \leq n \land E[i-1] \neq \varnothing$}
              \State $TerminalShift(E,i)$
              \State $Completion(E,i)$
              \State $i++$
          \EndWhile 
      \end{algorithmic}
\end{algorithm}

The algorithm can be summarized through the following steps:
\begin{enumerate}
    \item Introduce the initial pair $\langle 0_S, 0 \rangle$ into the first element $E[0]$ of the vector.
    \item Initialize elements $E[1]$ to $E[n]$ (if applicable) to the empty set.
    \item Complete $E[0]$.
    \item If $n \geq 1$ (indicating a non-empty string $x$), the algorithm populates pairs in the current element $E[i]$ through \texttt{terminalshift} and finalizes $E[i]$ via \texttt{completion}. 
        If \texttt{terminalshift} fails to add any pair to $E[i]$, the element 
    \item The loop continues up to the last element $E[n]$, concluding when the vector is processed or the preceding element $E[i-1]$ is empty.
\end{enumerate}
\begin{property}[Acceptance condition]
    Upon the completion of the Earley algorithm, the string $x$ is deemed accepted if and only if the last element $E[n]$ of the vector $E$ incorporates a final axiomatic pair $\langle f_S, 0 \rangle$, where $f_S \in F_S$.
\end{property}

\paragraph*{Complexity of Earley's algorithm}
Given that each basic operation has a constant cost of $O(1)$, and assuming a fixed grammar with the string $x$, the overall complexity of the Earley algorithm can be analyzed by considering the following contributions:
\begin{enumerate}
    \item A vector element $E[i]$ contains pairs $\langle q, j \rangle$ linearly limited by $i$where the number of states in the machine net is constant, and $j \leq i$.
        Therefore, the number of pairs in $E[i]$ is bounded by $n$:
        \[ |E(i)| = O(n) \]
    \item For a pair $\langle p, j \rangle$ checked in the element $E[i-1]$, the \texttt{terminalshift} operation adds one pair to $E[i]$.
        Consequently, for the entire $E[i-1]$, the \texttt{terminalshift} operation requires no more than $n$ steps:
        \[ \texttt{terminalshift} = O(n) \]
    \item The \texttt{completion} procedure involves iterations of closure and nonterminal shift operations as long as they add new pairs. 
        The two operations performed on the entire set $E[i]$ are:
        \begin{enumerate}
            \item For a pair $\langle q, j\rangle$ checked in $E[i]$, the closure adds a number of pairs limited by the constant number $|Q|$ of states in the machine net or $O(1)$. 
                Therefore, for the entire $E[i]$, the closure operation requires no more than $n$ steps:
                \[ \texttt{closure} = O(n) \times O(1) = O(n) \]
            \item For a final pair $\langle f, j \rangle$ checked in $E[i]$, the nonterminal shift first searches pairs $\langle p, l \rangle$ for a certain $p$ through $E[j]$, with size $O(n)$, and then adds to $E[i]$ as many pairs as it found, which is no more than $E[j] = O(n)$. For the entire set $E[i]$, the \texttt{completion} procedure requires no more than $O(n^2)$ steps:
                \[ \texttt{completion} = O(n) + O(n^2) = O(n^2) \]
        \end{enumerate}
    \item Summing up the numbers of basic operations performed in the outer loop for $i = 1 \dots n$, the overall complexity of the algorithm is:
        \[ \texttt{terminalshift} \times n + \texttt{completion} \times (n+1) = O(n) \times n + O(n^2) \times (n + 1) = O(n^3) \]
\end{enumerate}
As a result, the Earley algorithm exhibits an asymptotic time complexity of $O(n^3)$ in the worst case, where $n$ represents the length of the analyzed string.

\subsection{Syntax tree construction}
The subsequent procedure, \texttt{buildtree}, is responsible for constructing the syntax tree of an accepted string $x$ using the Earley vector $E$ as a guide, assuming the grammar is unambiguous.
The representation of the tree is done through a parenthesized string, where paired parentheses delineate a subtree rooted at a nonterminal node.
Given an EBNF grammar $G = \left( V, \Sigma, P, S \right)$, machine net $\mathcal{M}$, and a string $x$ of length $n \geq 0$ belonging to language $L(G)$, suppose the Earley vector $E$ with $n+1$ elements is available.
The recursive function \texttt{buildtree} has four formal parameters:
\begin{itemize}
    \item Nonterminal $\oplus \in V$, serving as the root of the tree to be constructed.
    \item State $f$, representing the final state for the machine $M_\oplus \in \mathcal{M}$. 
        The state $f$ marks the conclusion of the computation path in $M_\oplus$ corresponding to the analysis of the substring generated by $\oplus$.
    \item Two non-negative integers $i$ and $j$, satisfying the condition $0 \leq i \leq j \leq n$. 
        These integers denote the start and end of the substring generated by $\oplus$:
        \[\begin{cases}
            \oplus \overset{+}{\underset{G}{\Rightarrow}} x_{j+1} \,\ldots\, x_i \quad & \text{if} \ j < i \\[1.5ex]
            \oplus \overset{+}{\underset{G}{\Rightarrow}} \varepsilon \quad            & \text{if} \ j = i \\
        \end{cases}\]
\end{itemize}
The grammar $G$ allows derivations $S \overset{+}{\Rightarrow} x_1, \dots, x_2$ or $S \overset{+}{\rightarrow} \varepsilon$, and the Earley algorithm accepts $E$. 
Therefore, the element $E[n]$ of the vector $E$ contains a final axiomatic pair $\langle f_S, 0 \rangle$, where $f_S \in F_S$.

To construct the tree of string $x$ with the root node $S$, the \texttt{buildtree} procedure is initiated with parameters $(S, f_S, 0, n)$. 
Subsequently, it recursively builds all the subtrees and assembles them into the final tree.
\begin{algorithm}[H]
  \caption{buildtree($\oplus, f, i, j$)}
      \begin{algorithmic}[1]
          \State $C := \varepsilon$
          \State $q := f$
          \State $k := i$
          \While {$q \neq 0_\oplus$}
              \If {$\exists$ $h = k - 1$ and $\exists$ p $\in$ $Q_\oplus$ such that $\langle p, j \rangle \in E[h]$ and net has p $\smash{\xrightarrow{x_k}}$ q}
                  \State{$C := C \cup x_k$}
              \EndIf 
              \If {$\exists Y \in V$ and $\exists e \in F_Y$ and $\exists h, j (j \leq h \leq k \leq i)$ and $\exists p \in Q_\oplus$ such that ($\langle p, j \rangle \in E[k]$ and $\langle e, h \rangle \in E[h]$ and net has $p \overset{Y}{\rightarrow} q$)}
                  \State $C := C \cup$ buildtree($Y, q, k, j$)
              \EndIf 
              \State $q := p$ 
              \State $k := h $
          \EndWhile
          \State \Return $C(x)$
      \end{algorithmic}
\end{algorithm}
In essence, the \texttt{buildtree} function retraces a computation path in machine $M_\oplus$ and simultaneously traverses the Earley vector $E$ from $E[n]$ to $E[0]$.
During this traversal, it reconstructs the terminal and nonterminal shift operations to identify the children of the same node $\oplus$. 
Consequently, the procedure reverses the shift operations performed by the Earley parser.
The \texttt{while} loop iterates zero or more times, recovering one shift per iteration. 
The first condition in the loop retrieves a terminal shift, appending the corresponding leaf to the tree.
On the other hand, the second condition recovers a nonterminal shift, leading to a recursive call to build the subtree of the associated nonterminal node. 
The state \texttt{e} is final for the machine $M_Y$, and the inequality $0 \leq h \leq k \leq i$ is guaranteed by the definition of the Earley vector $E$. If the parent nonterminal $\oplus$ immediately generates the empty string (as indicated by the existence of a rule $\oplus \rightarrow \varepsilon$), the leaf $\varepsilon$ becomes the only child, and the loop does not repeat.
The \texttt{buildtree} function utilizes two local variables in the \texttt{while} loop: the current state $q$ of machine $M_\oplus$ and the current index \texttt{k} of the Earley vector element $E[k]$, both updated at each iteration. Initially, $q$ is set to final, and at the end of the algorithm, $q$ represents the initial state $0_\oplus$ of machine $M_\oplus$. 
In each iteration, the current state $q$ is shifted to the previous state $p$, and the current index $k$ is shifted from $i$ to $j$, involving jumps of varying lengths. There are instances where $k$ remains in the same position; this occurs only when the function processes a sequence of nonterminals that collectively generate the empty string $\varepsilon$.
The two \texttt{if} conditions are mutually exclusive under the assumption that the grammar is not ambiguous: the first condition holds true if the child is a leaf, while the second condition is true if the child has its subtree.

\paragraph*{Computation complexity of buildtree}
Assuming an unambiguous, clean, and circular derivation-free grammar for a string of length $n$, the number of tree nodes is linearly bounded by $n$. 
The basic operations, involving checking the state or pointer of a pair and concatenating a leaf or a node to the tree, are executed in constant time.
The total complexity can be estimated as follows:
\begin{enumerate}
    \item A vector element $E[k]$ contains a number of pairs with a magnitude of $O(n)$.
    \item There are between $0$ and $k$ elements in $E$.
    \item Checking the condition of the first \texttt{if} statement requires constant time \textit{($O(1)$)}. 
        The potential addition of one leaf also takes constant time \textit{($O(1)$)}. 
        Processing the entire $E[k-1]$ takes time of magnitude:
        \[ O(n) \times O(1) + O(1) = O(n) \]
    \item Checking the condition of the second \texttt{if} statement requires linear time \textit{($O(n)$)}, due to the search process. 
        The potential addition of one node takes constant time \textit{($O(1)$)}. 
        Processing the entire $E[k]$ takes time of magnitude: 
        \[ O(n) \times O(n) + O(1) = O\left( n^2 \right)  \]
\end{enumerate}
Finally, since the total number of terminal plus nonterminal shifts to be recovered is linearly bounded by the number of nodes to be built, the overall complexity of the algorithm is given by:
\[\left( O(n) + O\left( n^2 \right) \right) \times O(n) = O\left( n^3 \right) \]

\paragraph*{Computational complexity reduction via Earley vector ordering}
By reordering the vector $E$ based on the value of its pointer in the \texttt{buildtree} procedure, it's possible to reduce its complexity, as the \texttt{while} loop will run fewer times. 
Let's suppose that each element $E[k]$ is ranked according to the value of its pointer. This operation can be achieved in $(n+1) O\left( n \log{(n)} \right) = O\left( n^2 \log{(n)} \right)$ time.
Now, the second \texttt{if} statement requires $O(n)$ time to find a pair with a final state $e$ and pointer $h$ in the stack, while searching for the related pair with a fixed pointer $j$ takes $O(n)$ time. 
Similarly, the first \texttt{if} statement will only require $O\left( \log{(n)} \right)$ time.
The total time complexity of the algorithm, after reordering the vector $E$, becomes:
\[ O\left( n^2 \log{(n)} \right)\]

\paragraph*{Optimization via look-ahead}
The items within the sets $E[k]$ of the Earley vector can be expanded by incorporating a look-ahead, computed in a manner similar to ELR(1) parsers. 
By including a look-ahead at each step, the Earley algorithm steers clear of populating each set with items corresponding to choices that are destined to fail.
It's worth noting that while this technique can enhance parsing efficiency in certain cases, it may also lead to an augmentation in the number of items within the vector itself for certain grammars. 
Therefore, its application is not universally advantageous and should be considered judiciously based on the specific characteristics of the grammar in question.

\paragraph*{Application of the algorithm to ambiguous grammars}
Ambiguous grammars are noteworthy in the context of natural language processing. 
The challenging aspect lies in representing all potential syntax trees associated with a string, a number that can grow exponentially relative to the string's length. 
To address this, one approach is to employ a Shared Packed Parse Forest (SPPF), a more general graph structure than a tree. 
Despite its generality, constructing an SPPF still entails a worst-case cubic time complexity.