\section{Ambiguity}

\begin{definition}
    A sentence $x$ defined by grammar $G$ is \emph{ambiguous} if it admits several distinct syntax trees. 
    In such cases, we say that the grammar $G$ is ambiguous.

    The \emph{degree of ambiguity} of a sentence $x$ of a language $L(G)$ is the number of distinct syntax trees compatible with $G$. 
    For a grammar the degree of ambiguity is the maximum among the degree of ambiguity of its sentences.
\end{definition}
The problem of determining whether a grammar is ambiguous or not is undecidable because there is no general algorithm that, for any context-free grammar, can guarantee a termination with the correct answer in a finite number of steps.
As a result, proving the absence of ambiguity in a specific grammar typically requires a case-by-case analysis, often done manually through inductive reasoning, which involves analyzing a finite number of cases.
To demonstrate that a grammar is ambiguous, one can provide a witness, which is an example of an ambiguous sentence generated by the grammar. 
Therefore, it is advisable to strive for unambiguous grammar designs from the outset to avoid potential issues related to ambiguity. 

Ambiguity can be categorized into various classes as outlined below.

\subsection*{Ambiguity from bilateral recursion}
A non-terminal symbol $A$ exhibits bilateral recursion when it displays both left and right recursion.
\begin{example}
    Consider grammar $G_1$:
    \[G_1= E \rightarrow E+E|i\]
    This grammar can generate the string $i+i+i$ in two distinct ways.
    It's worth noting that the language generated by $L(G_1)=i(+i)^{*}$ is regular.
    Hence, it's possible to create simpler, unambiguous grammars, such as:
    \begin{itemize}
        \item A right-recursive grammar, which is $E \rightarrow i+E|i$.
        \item A left-recursive grammar, which is $E \rightarrow E+i|i$
    \end{itemize}
\end{example}
\begin{example}
    Let's examine grammar $G_2$:
    \[G_2= A \rightarrow aA|Ab|c\]
    The language generated by $G_2$, $L(G_2) = a^{*}cb^{*}$, is regular. 
    However, grammar $G_2$ allows derivations where the $a$ and $b$ characters in a sentence can be obtained in any order.
    This implies that the grammar is ambiguous.
    To resolve this ambiguity, two nonambiguous grammars can be constructed in the following ways:
    \begin{enumerate}
        \item Generate $a$'s and $b$'s separately using distinct rules:
            \[G_2=
            \begin{cases}
                S \rightarrow AcB               \\
                A \rightarrow aA|\varepsilon    \\
                B \rightarrow bB|\varepsilon 
            \end{cases}    
            \]
        \item First generate the $a$'s then the $b$'s:
            \[G_2=
            \begin{cases}
                S \rightarrow aS|X              \\
                X \rightarrow Xb|c   
            \end{cases}    
            \]
    \end{enumerate} 
\end{example}

\subsection*{Ambiguity from language union}
If $L_1=L(G_1)$ and $L_2=L(G_2)$ share some sentences, and if a grammar $G$ is constructed for their union language, it becomes ambiguous.

For any sentence $x \in L_1 \cap L_2$, it allows two distinct derivations: one following the rules of $G_1$ and the other following the rules of $G_2$. 
This ambiguity persists when using a single grammar $G$ that includes all the rules.

However, for sentences belonging exclusively to $L_1 \setminus L_2$ and $L_2 \setminus L_1$, they are nonambiguous. 
To resolve this ambiguity, a solution is to provide separate sets of rules for $L_1 \cap L_2$, $L_1 \backslash L_2$ and $L_2 \backslash L_1$. 

\subsection*{Inherent ambiguity}
A language is considered inherently ambiguous when all of its grammars are ambiguous.
\begin{example}
    Let's consider the language $L=\{a^ib^jc^k|i=j \lor j=k\}=\{a^ib^ic^{*}|i \geq 0\} \cup \{a^{*}b^ic^i|i \geq 0\}$. 
    This language is defined by two grammars:
    \[
    G_1=
    \begin{cases}
        S_1 \rightarrow XC \\
        X \rightarrow aXb|\varepsilon \\
        C \rightarrow cC|\varepsilon
    \end{cases}    
    G_2=
    \begin{cases}
        S_2 \rightarrow AY \\
        Y \rightarrow bYc|\varepsilon \\
        A \rightarrow aA|\varepsilon
    \end{cases}  
    \]
    The union grammar of these two grammars is ambiguous.
    This observation leads to the intuitive conclusion that any grammar for the language $L$ is also ambiguous due to the ambiguity of the language itself.
\end{example}

\subsection*{Ambiguity from concatenation of languages}
Ambiguity arises in the concatenation of languages when there exists a situation where a suffix of a sentence in the first language also serves as a prefix of a sentence in the second language.

To eliminate this ambiguity, one must avoid situations where a substring from the end of a sentence in the first language is seamlessly connected to the beginning of a sentence in the second language.
An effective solution to this problem is to introduce a new terminal symbol acting as a separator, which does not belong to either of the two alphabets.
\begin{example}
    Given two languages, $L_1$ and $L_2$, if the concatenation introduces ambiguity, we can resolve it by adding a new terminal symbol, denoted as $\#$.
    The axiomatic rule can then be transformed as follows:
    \[S \rightarrow S_1 \# S_2\]
    However, it's essential to note that this modification also alters the language itself.
\end{example}

\subsection*{Other cases of ambiguity}
There are other, less significant cases of ambiguity, including:
\begin{itemize}
    \item Ambiguity in regular expressions: to resolve this, eliminate redundant productions from the rule.
    \item Lack of order in derivations: address this problem by introducing a new rule that enforces the desired order.
\end{itemize}