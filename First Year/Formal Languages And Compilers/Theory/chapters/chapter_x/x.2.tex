\section{Flex}

A lexical analysis must recognize tokens in a stream of characters and possibly decorate tokens with additional info. Flex is a scanner generators based on regular 
expression description. A scanner is just a big finite state automaton. In a compiler, instead, the scanner prepares the input for the parser:
\begin{itemize}
    \item Detects the tokens of the language. 
    \item Cleans the input. 
    \item Adds information to the tokens. 
\end{itemize}
The input of the lexical analyzer generator called flex is a specification file of the scanner, while the output is a C source code file that implements the scanner. 
A flex file is structured in three sections separated by $\%\%$:
\begin{itemize}
    \item Definitions: declare useful regular expressions. The definition associates a name to a set of characters using regular expressions, and are usually employed 
        to define simple concepts. They are recalled by putting their name in curly braces
    \item Rules: bind regular expressions combinations to actions. A rule represents a full token to be recognized, and it is defined with a regular expression. They 
        define a semantic action to be made at each match. The semantic actions are executed every time the rule is matched, and can access matched textual data. 
        Simple applications put the business logic directly inside semantic actions. More complex applications that also use a separate parser instead assign a value 
        to the recognized token, and return the token type. 
    \item User code: C code (generally helper functions). This code is copied to the generated scanner as is. It usually contains the main function and any other 
        routine called by actions. 
\end{itemize}
The scanner generated by flex is called "lex.yy.c". The yylex() function parses the file yyin until a semantic action returns or the file ends (return value 0). 

Flex requires you to implement a single function "int yywrap(void)" that is called when the file ends. It gives the opportunity to open another file and continue 
scanning from there. It must return 0 if the parsing should continue or 1 if the parsing should stop. If you donâ€™t want this, you must put the following line
in the scanner source: "$\%$option noyywrap"

Some last important rules to remember:
\begin{itemize}
    \item Longest matching rule: if more than one matching string is found, the rule that generates the longest one is selected. 
    \item First rule: if more than one string with the same length is matched, the rule listed first will be triggered. 
    \item Default action: if no rules are found, the next character in input is considered matched implicitly and printed to the output stream as is.
\end{itemize}

The generated parser implements a non-deterministic finite state automaton that tries to match all possible tokens at the same time, and as soon as one is recognized:
\begin{enumerate}
    \item The semantic action is executed. 
    \item The stream skips past the end of the token. 
    \item The automaton reboots
\end{enumerate}
Actually, the NFA is translated into a deterministic automaton using a modified version of the Berry-Sethi algorithm. 

\subsection*{Multiple scanners}
Sometimes is useful to have more than one scanner together. In order to support multiple scanners: rules should be marked with the name of the associated scanner (start 
condition), and we need to have special actions to switch between scanners. A start condition S: is used to mark rules with as a prefix 
$\left\langle S \right\rangle$ RULE, and it marks rules as active when the scanner is running the $S$ scanner. Moreover:
\begin{itemize}
    \item The * start condition matches every start condition. 
    \item The initial start condition is INITIAL. 
    \item Start conditions are stored as integers.
    \item The current start condition is stored in the YY$\_$START variable.
\end{itemize}
Start conditions can be: 
\begin{itemize}
    \item Exclusive: declared with $\%x \: S$; disables unmarked rules when the scanner is in the $S$ start condition. 
    \item Inclusive: declared with $\%s \: S$; unmarked rules active when scanner is in the S start condition. 
\end{itemize}
The INITIAL condition is inclusive. Other special actions are: 
\begin{itemize}
    \item BEGIN($S$): place scanner in start condition $S$. 
    \item ECHO: copies yytext to output.
\end{itemize}