\subsection{\texttt{BISON}}

The purpose of the \textbf{Syntactic Analysis} is:

\begin{enumerate}
  \item \textbf{identify} the grammar structures of the input
  \item \textbf{verify} the syntactic correctness of the input
  \item \textbf{build} a derivation tree of the input
\end{enumerate}

It's important to notice that syntactic analysis does not determine the meaning of the input \textit{(that is the task of semantic analysis)}.
The syntactic analysis is performed over a stream of terminal symbols \textit{(tokens)} generated by the lexical analysis;
nonterminal symbols are only generated through the reduction of grammar rules.

\paragraph*{\bison}

\bison is the standard tool used to generate \textit{LR} parsers and is designed to work with \textit{flex};
the generated parsers use the \textit{LALR\((1)\)} algorithm, a variant of \textit{LR\((1)\)}.

Features of the parser:

\begin{itemize}
  \item the pilot automaton is described by a FSA.
  \item the parsing stack is used to keep the parsers state at runtime
  \item it acts as a typical shift-reduce parser
\end{itemize}

\subsection{Specification File}

A \bison file is structured in four sections, separated by the \texttt{\%\%} token:

\begin{itemize}
  \item the \textbf{prologue}: include headers, global variables, and function definitions
  \item the \textbf{definitions}: declare tokens, operator precedence, nonterminal types
  \item the \textbf{rules}: declare the grammar rules
  \item the \textbf{user code}: \clang code
\end{itemize}

\paragraph*{Definitions}
Different syntactic elements can be defined inside the definitions section:
\begin{itemize}
  \item \textbf{tokens}, via the \texttt{\%token} keyword
        \begin{itemize}
          \item each token is assigned a numbers
          \item the lexer uses said numbers to identify tokens
        \end{itemize}
  \item \textbf{grammar} rules, in the \textit{BNF} notation
        \begin{itemize}
          \item if not specified, the \LP of the first rule is the \textbf{axiom}
          \item rules are specified via the \textbf{syntax}
        \end{itemize}
\end{itemize}

Just like \textit{flex}, \bison allows specifying semantic actions in grammar rules;
semantic action is expressed in \clang instructions are can be specified at the end of each rule alternative.
They are executed when the rule they are associated with has been completely recognized:
the order of execution of the actions is bottom-up with respect to the syntactic tree.

\begin{onepage}
  \begin{lstlisting}[caption={Definition section of a \bison file}, label={lst:bison-definition-section}]
[ RULE_LP ] : [ RULE_RP ] [ ... ]
              [ { SEMANTIC_ACTION } ]
            | [ ... ]
            ;
\end{lstlisting}
\end{onepage}

Semantic actions can also be placed in the middle of a rule;
however, \bison normalizes the grammar in order to have only actions only at the end of each rule.

\paragraph*{Semantic values}

By associating a variable to each token \textit{(or non-terminal)} parsed, it is possible to keep track of what each of them represents.

\begin{itemize}
  \item \textbf{tokens}: the value is assigned in the lexer
  \item \textbf{nonterminals}: the value is assigned in the semantic action
\end{itemize}

The \textbf{\texttt{\%union}} declarator specifies the entire collection of possible data types:

\begin{itemize}
  \item type specification for \textbf{terminals} \textit{(tokens)} is done in the \textbf{token declaration}
  \item type specification for \textbf{non-terminals} is done in the special \textbf{\texttt{\%type} instruction}
\end{itemize}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Semantic value declaration}, label={lst:bison-semantic-value-declaration}]
%union {
  [ c_type ] [ VARIABLE_NAME ];
  [ ... ]
}

[ %token <c_type> TOKEN_NAME ]
[ ... ]

[ %type <c_type> NON_TERMINAL_NAME ]
[ ... ]
\end{lstlisting}
\end{onepage}

\paragraph*{About the \texttt{union} type}
\texttt{union} is a type of compound data defined by \clang, not by \bison;
the latter uses this data structure to associate multiple types with semantic values.

Unions are like the \texttt{struct} type, but assigning a value to one item invalidates all the others:
that's because unlike \texttt{struct} \textit{(that allocate their items sequentially)}, unions allocate their items in the same memory location.

\paragraph*{Accessing semantic values}
The semantic value of each grammar symbol in a production is stored in a variable called \texttt{\$i}, where \texttt{i} is the position of the symbol in the production.

\begin{itemize}
  \item \texttt{\$\$} corresponds to the \textbf{semantic value} of the rule itself
  \item Mid-rule actions count in the numbering
  \item Mid-rule actions have additional restrictions:
        \begin{itemize}
          \item the variable \texttt{\$\$} cannot be used since it points to the semantic value of the action itself
          \item it's not possible to access values of symbols that come later
        \end{itemize}
\end{itemize}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Semantic value usage}, label={lst:bison-semantic-value-usage}]
section : LSQUARE // $1
        | ID // $2
        | RSQUARE // $3
        | { printf("section: %s", $2); } // $4
        | options // $5
        | { $$ = create_sections($2, $5); } // $6
        ;
// the variable $$ contains the value of section
\end{lstlisting}
\end{onepage}

\paragraph*{Interface}

The generated parser is a \clang file ending with the \texttt{.tab.c} extension, as well as a header file ending with the \texttt{.tab.h} extension.
The main parsing instruction is \texttt{\textbf{int} yyparse(\textbf{void})}, the same as the \texttt{yyparse} function in \textit{flex};
however, compared to the latter, \bison provides a \texttt{yylval} global variable containing the semantic value of the last token returned by the lexer:
its type is the one specified in the \texttt{\%union} declaration.

\subsection{Integration of \textit{flex} and \bison}

Steps to integrate \textit{flex} and \bison:

\begin{itemize}
  \item In the \textbf{\textit{flex} source}:
        \begin{enumerate}[series=flex-bison-enum, label=step \arabic*., ref=(step \arabic*), leftmargin=*, labelindent=2em, widest*=6]
          \item include the \texttt{.tab.h} header file
          \item assign the semantic value of the token to the correct member of the \texttt{yylval} variable
          \item return the token identifiers declared in the \bison file
        \end{enumerate}
  \item In the \textbf{\bison source}:
        \begin{enumerate}[resume*=flex-bison-enum]
          \item declare and implement the \texttt{main()} function
        \end{enumerate}
  \item When \textbf{compiling}:
        \begin{enumerate}[resume*=flex-bison-enum]
          \item\label{enum:flex-bison-command-1} generate the \textit{flex} scanner by invoking \textit{flex}
          \item\label{enum:flex-bison-command-2} generate the \bison parser by invoking \bison
          \item\label{enum:flex-bison-command-3} compile the \clang file produced by bison and flex together
        \end{enumerate}
\end{itemize}

The command lines to execute \ref{enum:flex-bison-command-1} to \ref{enum:flex-bison-command-3} are shown in \ref{lst:flex-bison-command-lines}; an illustration of the workflow is shown in \ref{fig:flex-bison-workflow}.

\begin{onepage}
  \begin{lstlisting}[language=bash, caption={Command lines to execute \ref{enum:flex-bison-command-1} to \ref{enum:flex-bison-command-3}}, label={lst:flex-bison-command-lines}]
flex scanner.l
bison parser.y
cc -o out lex.yy.c parser.tab.c
\end{lstlisting}
\end{onepage}

\begin{figure}[htbp]
  \centering
  \bigskip
  \tikzfig{figure-19.tikz}
  \caption{Workflow of \textit{flex} and \bison}
  \label{fig:flex-bison-workflow}
  \bigskip
\end{figure}

\paragraph{Precedence and Associativity Declarations in \bison}

\paragraph*{Precedence}
\bison allows specifying the precedence of operators in a grammar, via the \texttt{\%precedence} instruction in the \textbf{definitions} section of the file.
It lists the tokens in order of \textbf{growing precedence}, grouping them by line:

\begin{itemize}
  \item[\(\downarrow\)] tokens that come \textbf{first} have the \textbf{lowest precedence}
  \item[\(\uparrow\)] tokens that come \textbf{last} have the \textbf{highest precedence}
  \item[\(\leftrightarrow\)] tokens listed in the \textbf{same line} have the \textbf{same precedence}.
\end{itemize}

\paragraph*{Associativity}
The associativity of an operator can be expressed by replacing the \texttt{\%precedence} instruction with one of the following:

\begin{itemize}[label=\textbf{\texttt{>}}]
  \item \textbf{\texttt{\%left}} for left associativity
  \item \textbf{\texttt{\%right}} for right associativity
  \item \textbf{\texttt{\%nonassoc}} for non-associativity
\end{itemize}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Precedence and Associativity declaration}, label={lst:bison-precedence-associativity-declaration}]
[ %precedence | %left | %right | %nonassoc ] TOKEN [ TOKEN ... ] // lowest
[ ... ]
[ %precedence | %left | %right | %nonassoc ] TOKEN [ TOKEN ... ] // highest
\end{lstlisting}
\end{onepage}

\subsection{Notes}

It's important to notice that the produced program does not compute the value of the expressions in the input file;
it just produces \clang code that computes the value of the expressions.
The computation happens when the \clang code is compiled and executed:
since \texttt{cc} is only a compiler, no computation happens in this stage.

In an \textbf{interpreter}, execution of the analysed parsed commands happens immediately after the parsing phase;
in a \textbf{compiler}, commands are rewritten in another language without being executed.
The definitions of parse time and compile time are shown in \ref{def:compile-time} and \ref{def:run-time}.

\begin{definition}[Compile Time]
  \label{def:compile-time}
  Compile time computation is the computation performed in the compiler to produce the compiled output
\end{definition}

\begin{definition}[Run Time]
  \label{def:run-time}
  Run time computation is the computation performed by the compiled output when executed
\end{definition}