\subsection{\texttt{ACSE}}

\texttt{ACSE} is a simple compiler that:

\begin{itemize}
  \item[\(\rightarrow\)] as \textbf{input} accepts a \clang like \textbf{source language} called \lance
  \item[\(\leftarrow\)] as \textbf{output} emits a \texttt{RISC}-like \textbf{assembly language} called \mace
\end{itemize}

It's bundled with two tools:

\begin{enumerate}
  \item \texttt{asm}, an \textbf{assembler} \textit{(from assembly to machine code)}
  \item \mace, a \textbf{simulator} for the machine code
        \begin{itemize}
          \item it \textbf{emulates} a fictional machine called \mace
          \item it won't be used in this course
        \end{itemize}
\end{enumerate}

\subsection{\lance}

\lance is the source language recognized by \texttt{ACSE}.
It offers a very small subset of \texttt{C99} instructions, including:

\begin{itemize}[label=\textbf{\texttt{>}}]
  \item standard set of \textbf{arithmetic/logic/comparison operators}
  \item reduced set of \textbf{control flow} statements \textit{(only \texttt{while}, \texttt{do-while}, \texttt{if})}
  \item only one \textbf{scalar} type \textit{(\texttt{int})}
  \item only one \textbf{aggregate} type \textit{(arrays of \texttt{int})}
  \item \textbf{no functions}
  \item \textbf{reading} and \textbf{writing} to standard input/output via the functions:
        \begin{itemize}
          \item \texttt{read(var)} to \textbf{read an integer} from \textbf{standard input} and store it in \texttt{var}
          \item \texttt{write(var)} to \textbf{write} the value of \texttt{var} to \textbf{standard output}
        \end{itemize}
\end{itemize}

A \lance source file is composed of two sections:

\begin{enumerate}
  \item \textbf{variable} declarations
  \item \textbf{program} body as a list of statements
\end{enumerate}

\subsection{Compilation Process}

\texttt{ACSE} compilation is performed in steps:

\paragraph*{Front-end}
\begin{enumerate}
  \item the source code is \textbf{tokenized} by a \textit{flex}-generated scanner
  \item the stream of tokens is \textbf{parsed} by a \bison-generated parser
  \item the code is \textbf{translated} to a temporary intermediate representation by the semantic actions of the parser
\end{enumerate}

\paragraph*{Middle-end}
There's no middle-end in \texttt{ACSE}; the intermediate representation is directly piped to the back end without any optimization.

\paragraph*{Back-end}
\begin{enumerate}
  \item the \textbf{intermediate representation} is normalized to account for physical limitations of the \mace machine
  \item each instruction is printed out producing the \mace assembly code
\end{enumerate}

\paragraph{Intermediate Representation}

The \textbf{Intermediate Representation} \texttt{(IR)} is the data representation used in a compiler to represent the program.
In \texttt{ACSE} it is composed of two main parts:

\begin{enumerate}
  \item the \textbf{instruction list}
        \begin{itemize}[label=\textbf{\texttt{>}}]
          \item instructions are \texttt{RISC}-like assembly
          \item all the syntactic details are abstracted
          \item latter analysis of the program is simpler
        \end{itemize}
  \item the \textbf{variable table}
\end{enumerate}

The data is stored in an unbounded number of registers in an unbounded number of memory locations.

\paragraph*{Registers}
Registers are the variables of intermediate language.
All registers have the same type \textit{(32-bit signed integer)}; the instruction using the register is responsible for the interpretation of the value as a pointer.

There are two special registers:
\begin{enumerate}[label=\textbf{\texttt{>}}]
  \item \textbf{zero} \textit{(\texttt{R0})} always containing the value \texttt{0}
        \begin{itemize}[label=\textbf{\texttt{>}}]
          \item each write to \texttt{R0} is \textbf{ignored}
        \end{itemize}
  \item \textbf{\texttt{PSW}}, also called \textbf{status word}, implicitly read and written by the arithmetic instructions; contains flags that are used by other instructions:
        \begin{itemize}[label=\textbf{\texttt{>}}]
          \item\texttt{N}, set if the result of the last arithmetic operation is \textbf{negative}
          \item\texttt{Z}, set if the result of the last arithmetic operation is \textbf{zero}
          \item\texttt{C}, set if the last arithmetic operation needed a \textbf{carry}
          \item\texttt{V}, set if the last arithmetic operation \textbf{overflowed}
        \end{itemize}
\end{enumerate}

\paragraph*{Immediates}
Immediates are constant values encoded directly in the instruction.

\paragraph*{Labels}
Labels are constant pointers to a given memory location.
They are used both for conditional jumps and for pointing to the location of statically allocated data;
the actual address is computed by the assembler.

\subsection{Instructions}

\textbf{Instruction formats} and \textbf{Addressing modes} are shown respectively in Tables~\ref{tab:instructions-format} and~\ref{tab:addressing-modes}.

The \textbf{conditional jump instructions} are shown in Table~\ref{tab:jump-instructions}. All the flags checked are part of the \texttt{PSW} register;
Table~\ref{tab:numerical-branch-instructions} shows the j\textbf{ump instructions that allow direct numerical comparison}.
The instructions displayed in the latter need a \texttt{SUB} operation before the branch; refer to Code~\ref{code:conditional-jump} for an example.

\begin{table}[htbp]
  \bigskip
  \centering
  \begin{tblr}{colspec={c|l|l}, row{1}={font=\itshape}, column{1}={font=\itshape}, cell{2-5}{3}={font=\ttfamily}}
    type    & operands                                                  & example        \\ \hline
    ternary & 1 destination and 2 source registers                      & ADD R3, R1, R2 \\
    binary  & 1 destination and 1 source registers, 1 immediate operand & ADD R3 R1 \#4  \\
    unary   & 1 destination register, 1 address operand                 & LOAD R1 L0     \\
    jump    & 1 address operand                                         & BEQ L0         \\
  \end{tblr}
  \caption{Instructions Format}
  \label{tab:instructions-format}
  \bigskip
\end{table}

\begin{table}[htbp]
  \bigskip
  \centering
  \begin{tblr}{colspec={l|c|l}, row{1}={font=\itshape}, column{1}={font=\itshape}, cell{2-6}{2}={font=\ttfamily}}
    type              & syntax     & notes                                            \\ \hline
    register direct   & R<n>       & \texttt{n} is a register number                  \\
    register indirect & (R<n>)     & the data contained in the \texttt{n}-th register \\
    symbolic address  & L<n>       & \texttt{n} is a label number                     \\
                      & <label id> & the name of the label is explicitly used         \\
    immediate         & \#<value>  & \texttt{value} is a constant integer             \\
  \end{tblr}
  \caption{Addressing Modes}
  \label{tab:addressing-modes}
  \bigskip
\end{table}

\begin{table}
  \bigskip
  \centering
  \begin{tblr}{colspec={c|c|c}, column{1,3}={font=\ttfamily}, row{1}={font=\itshape}}
    instruction & branch condition & test \\
    \hline
    BT          & always           & -    \\
    BF          & never            & -    \\
    BPL         & if positive      & !N   \\
    BMI         & if negative      & N    \\
    BNE         & if not zero      & !Z   \\
    BEQ         & if zero          & Z    \\
    BVC         & if no overflow   & !V   \\
    BVS         & if overflow      & V    \\
    BCC         & if no carry      & !C   \\
    BCS         & if carry         & C    \\
  \end{tblr}
  \caption{Conditional jump instructions}
  \label{tab:jump-instructions}
  \bigskip
\end{table}

\begin{table}
  \bigskip
  \centering
  \begin{tblr}{colspec={c|c|c}, column{1,3}={font=\ttfamily}, row{1}={font=\itshape}}
    instruction & branch condition    & test                                 \\
    \hline
    BNE         & if not equal        & !Z                                   \\
    BEQ         & if equal            & Z                                    \\
    BGE         & if greater or equal & (N \&\& V) || (!N \&\& !V)           \\
    BLT         & if less than        & (N \&\& !V) || (!N \&\& V)           \\
    BGT         & if greater than     & (!Z \&\& (N \&\& V) || (!N \&\& !V)) \\
    BLE         & if less or equal    & (Z || (N \&\& !V) || (!N \&\& V))    \\
  \end{tblr}
  \caption{Numerical branch instructions}
  \label{tab:numerical-branch-instructions}
  \bigskip
\end{table}

\begin{onepage}
  \begin{lstlisting}[caption={Conditional jump example}, label={code:conditional-jump}]
SUBI R0 R2 #3 // the value is saved in R0 to be discarded
BGT L0 // branches if R2 < 3
\end{lstlisting}
\end{onepage}

\subsection{Variable Table}

The \textbf{variable table} contains the list of all the variables declared in the program.
A variable can be a scalar or an \textbf{array}:

\begin{itemize}
  \item \textbf{scalars} have a register containing where they are \textbf{stored} and an initial \textbf{value}
  \item \textbf{arrays} have a \textbf{size} and a \textbf{label} to a memory location where they will be \textbf{stored}
\end{itemize}

Each variable has a unique identifier equal to the name of the variable itself.

\subsection{\lance grammar}

A \lance source file is split into two sections:

\begin{enumerate}
  \item \textbf{variable declarations}, where the root-nonterminal is called \texttt{var\_declarations}
  \item \textbf{list of statements}, where the root-nonterminal is called \texttt{statements}
\end{enumerate}

A statement is a syntactic unit of an imperative programming language that expresses some actions to be carried out.
They can be classified as:

\begin{itemize}
  \item \textbf{Simple} statements, which are the basic statements of the language and cannot be further decomposed
  \item \textbf{Compound} statements, which are statements that can be decomposed into simpler statements
\end{itemize}

The basic grammar rules expressed in \textit{BNF} are shown in Code~\ref{code:lance-bnf-grammar}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={\lance grammar in BNF}, label={code:lance-bnf-grammar}]
program : var_declarations statements
var_declarations : var_declaration var_declarations
                 | empty
statements : statement statement
           | empty
code_block : statement
           | LBRACKET statements RBRACKET
var_declaration : ...
statement : ...
\end{lstlisting}
\end{onepage}

The simplest statement is \texttt{return}: it exists the program.
In \texttt{asm} is translated into a \texttt{HALT} instruction;
a \bison example is shown in Code~\ref{code:bison-return}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={\bison return}, label={code:bison-return}]
statement : /* ... */
          | control_statement
          | /* ... */
;

control_statement : /* ... */
                  | return_statement SEMI
;

return_statement : RETURN
                 {
                    /* insert an HALT instruction */
                    gen_halt_instruction(program);
                 }
;
\end{lstlisting}
\end{onepage}

The function \texttt{gen\_halt\_instruction} is a standard \clang function.
It's defined in \texttt{axe\_gencode.h} and it's implemented in \texttt{axe\_gencode.c};
it generates an \texttt{HALT} instruction and inserts it into a linked list called \textbf{program list} placed inside the global \texttt{program} structure.

The implementation of said function in \clang is shown in Code~\ref{code:asm-return}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={\texttt{asm} return in \clang}, label={code:asm-return}]
void gen_halt_instruction(t_program_infos *program) {
  t_axe_instruction *inst = malloc(sizeof(t_axe_instruction));
  inst->opcode = HALT;
  program->instructions = addLast(program->instructions, inst);
}
\end{lstlisting}
\end{onepage}

\subsection{The Program instance}

The instruction list is contained in a \textbf{global structure} called \textbf{\texttt{program}}.
Its declaration happens at the top of the \texttt{Acse.y} file;
it contains the intermediate representation of the program being compiled as well as other contextual informations.

Its definition is shown in Code~\ref{code:program-struct}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={\texttt{program} structure}, label={code:program-struct}]
typedef struct t_program_infos {
  t_list *variables;
  t_list *instructions;
  /* ... */
  int current_register;
} t_program_infos;
\end{lstlisting}
\end{onepage}

\subsection{The Variable instance}

The syntax of variable declarations is similar to the \clang one; its grammar is shown in Code~\ref{code:variable-grammar}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Variable grammar}, label={code:variable-grammar}]
variable_declaration : TYPE declarator_list SEMI
declarator_list : declarator
                | declarator COMMA declarator_list
declarator : IDENTIFIER
           | IDENTIFIER LBRACKET expression RBRACKET
           | IDENTIFIER ASSIGN NUMBER
\end{lstlisting}
\end{onepage}

\paragraph*{Variable identifiers}

The token for variable identifiers is called \texttt{IDENTIFIER}:
its semantic value is a \clang string with the name of the variable.
Such string is dynamically allocated by the lexer: it must be freed in the semantic actions.

Code~\ref{code:variable-identifiers-Acse-y} shows the \texttt{Acse.y} file where the token is defined and Code~\ref{code:variable-identifiers-Acse-lex} shows the \texttt{Acse.lex} file where the token is recognized.
Code~\ref{code:strdup} shows the implementation of the \clang \texttt{strdup()} function.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Content of \texttt{Acse.y} file}, label={code:variable-identifiers-Acse-y}]
%union {
  ...
  char *string;
  ...
}

%token <string> IDENTIFIER
\end{lstlisting}
\end{onepage}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Content of \texttt{Acse.lex} file}, label={code:variable-identifiers-Acse-lex}]
ID [a-zA-Z_][a-zA-Z0-9_]*
%%
{ID} {
  yylval.string = strdup(yytext);
  return IDENTIFIER;
}
\end{lstlisting}
\end{onepage}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={\texttt{stdrup()} function}, label={code:strdup}]
char *strdup(const char *s) {
  char *d = malloc(strlen(s) + 1);   // Space for length plus nul
  if (d == NULL) return NULL;        // No memory
  strcpy(d,s);                       // Copy the characters
  return d;                          // Return the new string
}
\end{lstlisting}
\end{onepage}

\paragraph{Variable creation}

Each declared variable must be added to the \texttt{variable} list: it associates the register or memory location where the variable or array \textit{(respectively)} is stored with its name.
The function to add a variable to the list is shown in Code~\ref{code:add-variable}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Add variable to the list}, label={code:add-variable}]
void createVariable(
  t_program_infos *program,
  char *id, // the variable identifier
  int type, // type (always INTEGER_TYPE)
  int isArray, // 1 if the variable is an array, 0 otherwise
  int arraySize, // the size of the array (if isArray == 1)
  int init_value // the initial value of the variable (if isArray == 0)
);
// the identifier is freed by the function
\end{lstlisting}
\end{onepage}

\paragraph{Variable access}

Creating a variable only tells \texttt{ACSE} that it exists;
no space is reserved for it in the memory.
The compiler knows where its value will be found at runtime.

In \texttt{ACSE} all every \textbf{variable} is stored in a \textbf{register}.
The signature of the function used is shown in Code~\ref{code:get-variable};
it returns the identifier of the register where the variable is stored.

The register identifier is the number of the register: register \texttt{R<n>} is identified by the number \texttt{n}.
Make sure to never do arithmetic on the register identifier: it is not a pointer to the register.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Get variable from the list}, label={code:get-variable}]
int get_symbol_location(
  t_program_infos *program,
  char *id // the variable identifier
  int genLoad // always 0
);
// returns the identifier of the register containing the variable
// the identifier is not freed by the function
\end{lstlisting}
\end{onepage}

\paragraph{Variable assignment}

To assign a value to a variable, the compiler must first load the value in a register;
an instruction to assign a value to that register is then generated.

The \texttt{read} statement assigns a value to a variable:
at runtime, the value will be read from the standard input via the \texttt{READ} instruction.
The variable identifier is then freed.

The grammar of the \texttt{read} statement is shown in Code~\ref{code:read-grammar}.
the family of functions \texttt{gen\_xxx\_instruction()} allows to generate ternary instructions.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Read grammar}, label={code:read-grammar}]
statement : /* ... */
          | read_write_statement SEMI
          | /* ... */
;
read_write_statement : read_statement
                     | write_statement
                     | /* ... */
;
read_statement : READ LPAREN IDENTIFIER RPAREN
               {
                int location;
                location = get_symbol_location(program, $3, 0);
                gen_read_instruction(program, location);
                free($3);
               }
;
\end{lstlisting}
\end{onepage}

\paragraph{Sharing variables between semantic actions}

Generally speaking, sometimes it's necessary to declare a variable that is accessible to multiple sematic actions.
There are several way to achieve this goal:

\begin{enumerate}
  \item Use a \textbf{global variable}
        \begin{itemize}
          \item[\cmarkthin] Easy to implement
          \item[\xmarkthin] Doesn't work when the semantic actions are nested
        \end{itemize}
  \item Use a \textbf{global stack}
        \begin{itemize}
          \item[\cmarkthin] Works with nested semantic actions
          \item[\xmarkthin] Requires a lot of boilerplate code
        \end{itemize}
  \item Re purpose a symbol's \textbf{semantic value} as a variable
        \begin{itemize}
          \item[\cmarkthin] Works with nested semantic actions
          \item[\cmarkthin] Fairly easy to implement
          \item[\xmarkthin] Does not work when the variable must be accessed from multiple rules \textit{(in this case, fall back to the global stack)}
        \end{itemize}
\end{enumerate}

\subsection{Constant}

The token for constant integers is called \texttt{NUMBER}:
its semantic value is the integer value that appears in the \lance source code.

Code~\ref{code:variable-constant-integers-Acse-y} shows the \texttt{Acse.y} file where the token is defined and Code~\ref{code:variable-constant-integers-Acse-lex} shows the \texttt{Acse.lex} file where the token is recognized.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Content of \texttt{Acse.y} file}, label={code:variable-constant-integers-Acse-y}]
%union {
  ...
  int number;
  ...
}

%token <number> NUMBER
\end{lstlisting}
\end{onepage}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Content of \texttt{Acse.lex} file}, label={code:variable-constant-integers-Acse-lex}]
DIGIT [0-9]+
%%
{DIGIT}+ {
  yylval.number = atoi(yytext); // atoi() is a standard C function converting ASCII to INTEGER
  return NUMBER;
}
\end{lstlisting}
\end{onepage}

\subsection{Expressions}

In \lance, expressions appear in:

\begin{itemize}
  \item Right-hand-side \textit{(RHS)} of assignments
  \item Array indices
  \item Conditions in control statements
\end{itemize}

Almost all \clang operators are supported in \lance:

\begin{itemize}
  \item basic \textbf{arithmetic} operators: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}
  \item \textbf{bitwise} operators: \texttt{\&}, \texttt{|}, \texttt{<<}, \texttt{>>}
  \item \textbf{logical} operators: \texttt{\&\&}, \texttt{||}, \texttt{!}
  \item comparison operators: \texttt{==}, \texttt{!=}, \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}
\end{itemize}

The grammar of expressions is shown in Code~\ref{code:expression-grammar}, and the operator precedence is shown in Code~\ref{code:expression-precedence}.
Note that:

\begin{itemize}
  \item operators \texttt{\&} and \texttt{|} have \textbf{lower precedence} than comparisons
  \item unary \texttt{MINUS} does not work well since it is left associative and has the same priority as \texttt{PLUS}
        \begin{itemize}
          \item to fix this behaviour, additional parentheses around the expression are required
          \item \texttt{- 1 * 2} must be written as \texttt{(- 1) * 2}
        \end{itemize}
\end{itemize}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Expression grammar}, label={code:expression-grammar}]
exp : NUMBER
    | IDENTIFIER
    | NOT_OP exp // NOT_OP !
    | exp AND_OP exp // AND_OP &
    | exp OR_OP exp // OR_OP ||
    | exp PLUS exp // PLUS +
    | exp MINUS exp // MINUS -
    | exp MUL_OP exp // MUL_OP *
    | exp DIV_OP exp // DIV_OP /
    | exp LT exp // LT <
    | exp GT exp // GT >
    | exp EQ exp // EQ ==
    | exp NOTEQ exp // NOTEQ !=
    | exp LTEQ exp // LTEQ <=
    | exp GTEQ exp // GTEQ >=
    | exp SHL_OP exp // SHL_OP <<
    | exp SHR_OP exp // SHR_OP >>
    | exp ANDAND exp // ANDAND &&
    | LPAR exp RPAR // LPAR (, RPAR )
    | MINUS exp // the ambiguity of MINUS arises here
;
\end{lstlisting}
\end{onepage}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Expression precedence}, label={code:expression-precedence}]
%left OROR
%left ANDAND
%left OR_OP
%left AND_OP
%left EQ NOTEQ
%left LT GT LTEQ GTEQ
%left SHL_OP SHR_OP
%left PLUS MINUS
%left MUL_OP DIV_OP
%right NOT_OP
\end{lstlisting}
\end{onepage}

\subsection{Semantic Actions}

\paragraph{Temporary Registers}

The intermediate language can only represent operations between \(2\) registers at most;
for more complex expressions, \textbf{temporary registers} are used.
Those are not associated with variables and are used to store \textbf{intermediate results}.

\texttt{ACSE} provides a function to retrieve a register identifier never seen before in the translated intermediate representation;
it will be used as a temporary register.
The implementation of said function is shown in Code~\ref{code:register-identifier}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Register identifier}, label={code:register-identifier}]
int getNewRegister(t_program_infos *program) {
  int result;
  result = program->current_register;
  program->current_register++;
  return result;
}
// nothing is added to the list of instructions
\end{lstlisting}
\end{onepage}

Retrieving a new temporary register does not generate any instruction in the intermediate representation:
book-keeping of register identifiers is done by the \texttt{ACSE} compiler \textit{(at compile time)}.
In theory, all infinite registers exist \textit{a priori} in the intermediate representation;
the only executed operation is deciding which register identifier is used for a given expression.

\paragraph{Constant assignment}

The instructions to put a constant in a register are:

\begin{itemize}[label=\textbf{\texttt{>}}]
  \item \texttt{gen\_load\_immediate()}, which creates a new register and puts the constant in it
  \item \texttt{gen\_move\_immediate()}, which puts the constant in any register
\end{itemize}

Both their implementations are shown in Code~\ref{code:constant-assignment}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Constant assignment}, label={code:constant-assignment}]
// put a constant in a new register
int gen_load_immediate(t_program_infos *program, int imm) {
  int imm_register;
  imm_register = getNewRegister(program);
  gen_move_immediate(program, imm_register, imm);

  return imm_register;
}
// put a constant in any register
void gen_move_immediate(t_program_infos *program, int dest, int imm) {
  gen_addi_instruction(program, dest, 0, imm);
}
\end{lstlisting}
\end{onepage}

\paragraph{Code Generation}

\paragraph*{Basic code generation for Expressions}

The code generation for expressions is shown in Code~\ref{code:expression-code-generation-grammar}:
\begin{itemize}
  \item constants are placed in new temporary registers
  \item registers associated with variables are used directly
  \item the register identifier of the subexpressions is used for the parentheses
\end{itemize}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Expression code generation grammar}, label={code:expression-code-generation-grammar}]
exp : NUMBER
    {
      $$ = getNewRegister(program);
      gen_addi_instruction(program, $$, REG_0, $1);
    }
    | IDENTIFIER
    {
      $$ = get_symbol_location(program, $1, 0);
      free($1);
    }
    | LPAR exp RPAR
    {
      $$ = $2;
    }
    | /* ... */
\end{lstlisting}
\end{onepage}

\paragraph*{Basic code generation for Operators}

Many operators directly translate into a single \mace instruction;
Code~\ref{code:operator-code-generation} shows the code generation for some of them.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Operator code generation}, label={code:operator-code-generation}]
exp : /* ... */
    | exp PLUS exp
    {
      $$ = getNewRegister(program);
      gen_add_instruction(program, $$, $1, $3, CG_DIRECT_ALL);
    }
    | exp AND_OP exp
    {
      $$ = getNewRegister(program);
      gen_andb_instruction(program, $$, $1, $3, CG_DIRECT_ALL);
    }
    | exp OROR exp
    {
      $$ = getNewRegister(program);
      gen_orl_instruction(program, $$, $1, $3, CG_DIRECT_ALL);
    }
\end{lstlisting}
\end{onepage}

\paragraph*{Code generation for Comparison Operators}

Comparison operators require more complex code sequences using the set instructions:
\texttt{SLT}, \texttt{SGT}, \texttt{SLE}, \texttt{SGE} and \texttt{SEQ}.
They implement the same logic as branching, but instead of jumping they set a register to \texttt{1} or \texttt{0}.

Code~\ref{code:comparison-operator-code-generation} shows the code generation for some comparison operators.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Comparison operator code generation}, label={code:comparison-operator-code-generation}]
exp : /* ... */
    | exp LT exp
    {
      $$ = getNewRegister(program);
      gen_sub_instruction(program, REG_0, $1, $3, CG_DIRECT_ALL);
      gen_slt_instruction(program, $$);
    }
    | exp GT exp
    {
      $$ = getNewRegister(program);
      gen_sub_instruction(program, REG_0, $1, $3, CG_DIRECT_ALL);
      gen_sgt_instruction(program, $$);
    }
    | /* ... */
\end{lstlisting}
\end{onepage}

\subsection{Constant Folding}

\texttt{ACSE} implements a \textbf{constant folding} optimization:
instead of computing constant expressions at runtime, it computes them at compile time.
This makes the execution of the program faster at the expense of a longer compilation time.

For example, the expression:
\begin{center}
  \texttt{a + 3 * 4 - 2 + c}
\end{center}
Is evaluated at compile time and replaced by the constant:
\begin{center}
  \texttt{a + 10 + c}
\end{center}

Running code at compile time is permitted only when the result does not change the behaviour of the program in any observable circumstance;
the process of computing an expression value is invisible to the programmer and the compiled program will work in the same way.

\paragraph{Implementation of Constant Folding}

The idea is to have a double meaning for the semantic value of \texttt{exp}:
\begin{itemize}
  \item the \textbf{register identifier} of the expression
  \item the \textbf{constant value} of the expression
\end{itemize}

In each action, the operands are checked:

\begin{itemize}
  \item if \textbf{both} are constant
        \begin{enumerate}
          \item the result is computed at \textbf{compile time}
          \item the result expression is \textbf{replaced} by the constant
        \end{enumerate}
  \item if at least \textbf{one of them} is not a constant
        \begin{enumerate}
          \item if there's a constant, it is moved to a register
          \item the code that will compute the result at runtime is generated
          \item the result expression is replaced by the register identifier which will contain the result
        \end{enumerate}
\end{itemize}

The double meaning is implemented via a new type of semantic value, called \texttt{t\_axe\_expression};
Code~\ref{code:constant-expression-struct} shows the definition of the new type in the \texttt{acse\_struct.h} header file, and Code~\ref{code:constant-expression-grammar} shows the grammar rules that use it, as defined in the \texttt{acse.y} file.

Code~\ref{code:create-expression} shows the use of the helper function \texttt{create\_expression} to create a new expression.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Constant expression struct in \texttt{acse\_struct.h}}, label={code:constant-expression-struct}]
typedef struct t_axe_expression {
  int value;
  int expression_type; // IMMEDIATE (constant) or REGISTER (variable)
} axe_expression;
\end{lstlisting}
\end{onepage}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Constant expression grammar rules in \texttt{acse.y}}, label={code:constant-expression-grammar}]
%union {
  /* ... */
  t_axe_expression expr;
  /* ... */
}

%type <expr> exp
\end{lstlisting}
\end{onepage}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Helper function to create a new expression in \texttt{acse\_struct.h}}, label={code:create-expression}]
t_axe_expression create_expression(int value, int expression_type) {
  t_axe_expression expr;
  expr.value = value;
  expr.expression_type = expression_type;
  return expr;
}
\end{lstlisting}
\end{onepage}

\paragraph*{Expression with constant folding}

Code~\ref{code:constant-expression-code-generation} shows the code generation for expressions with constant folding.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Expression with constant folding code generation}, label={code:constant-expression-code-generation}]
exp : NUMBER
    {
      $$ = create_expression($1, IMMEDIATE);
    }
    | IDENTIFIER
    {
      int location = get_symbol_location(program, $1, 0);
      $$ = create_expression(location, REGISTER);
      free($1);
    }
    | LPAR exp RPAR
    {
      $$ = $2;
    }
    | /* ... */
\end{lstlisting}
\end{onepage}

\paragraph*{Operators with constant folding}

\texttt{ACSE} offers two helper functions to generate code for operators with constant folding, both defined in the \texttt{axe\_expression.h} file:

\begin{itemize}[label=\textbf{\texttt{>}}]
  \item \texttt{handle\_bin\_numeric\_op()} for arithmetic and logical operations
  \item \texttt{handle\_binary\_comparison()} for comparison operations
\end{itemize}

Both their signatures are shown in Code~\ref{code:constant-expression-helper-functions}, while their usage in operators grammar is shown in Code~\ref{code:constant-expression-operators};
note that in the latter, non-binary operators are handled without any helper function.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Constant expression helper functions in \texttt{axe\_expression.h}}, label={code:constant-expression-helper-functions}]
/*
 * Valid values for binop variables are:
 * ADD SUB MUL DIV ANDL ORL EORL
 * ANDB ORB EORB SHL SHR */
t_axe_expression handle_bin_numeric_op(t_axe_expression left, t_axe_expression right, int binop);
/*
 * Valid values for condition are:
 * _LT_ _GT_ _EQ_ _NOTEQ_ _LTEQ_ _GTEQ_ */
t_axe_expression handle_binary_comparison (t_axe_expression left, t_axe_expression right, int condition);
\end{lstlisting}
\end{onepage}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Constant expression operators via helper functions}, label={code:constant-expression-operators}]
exp : /* ... */
    | exp AND_OP exp { $$ = handle_bin_numeric_op(program, $1, $3, ANDB); }
    | exp OR_OP exp { $$ = handle_bin_numeric_op(program, $1, $3, ORB); }
    | exp PLUS exp { $$ = handle_bin_numeric_op(program, $1, $3, ADD); }
    | exp MINUS exp { $$ = handle_bin_numeric_op(program, $1, $3, SUB); }
    | exp MUL_OP exp { $$ = handle_bin_numeric_op(program, $1, $3, MUL); }
    | exp DIV_OP exp { $$ = handle_bin_numeric_op(program, $1, $3, DIV); }
    | exp LT exp { $$ = handle_binary_comparison(program, $1, $3, _LT_); }
    | exp GT exp { $$ = handle_binary_comparison(program, $1, $3, _GT_); }
    | exp EQ exp { $$ = handle_binary_comparison(program, $1, $3, _EQ_); }
    | exp NOTEQ exp { $$ = handle_binary_comparison(program, $1, $3, _NOTEQ_); }
    | exp LTEQ exp { $$ = handle_binary_comparison(program, $1, $3, _LTEQ_); }
    | exp GTEQ exp { $$ = handle_binary_comparison(program, $1, $3, _GTEQ_); }
    | exp SHL_OP exp { $$ = handle_bin_numeric_op(program, $1, $3, SHL); }
    | exp SHR_OP exp { $$ = handle_bin_numeric_op(program, $1, $3, SHR); }
    | exp ANDAND exp { $$ = handle_bin_numeric_op(program, $1, $3, ANDL); }
    | exp OROR exp { $$ = handle_bin_numeric_op(program, $1, $3, ORL); }
    | /* ... */
\end{lstlisting}
\end{onepage}

\paragraph{Assignment}

Since the right-hand-side of an assignment is an expression, there are two cases:

\begin{enumerate}
  \item the expression is a constant: the value is materialized and assigned
  \item the expression is a register: the code to copy the value from the register to the variable is generated
\end{enumerate}

The code to handle both cases is shown in Code~\ref{code:assignment-code-generation}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Assignment code generation}, label={code:assignment-code-generation}]
assign_statement : IDENTIFIER ASSIGN exp
                 {
                    int location;
                    location = get_symbol_location(program, $1, 0);

                    if ($3.expression_type == IMMEDIATE) {
                      /* constant */
                      gen_move_immediate(program, location, $3.value)
                    } else {
                      /* register */
                      gen_add_instruction(program, location, REG_0, $3.value, 0);
                    }

                    free($1);
                 }
                 ;
\end{lstlisting}
\end{onepage}

\subsection{Arrays}

\paragraph{Array access}

Arrays are stored in memory locations identified by labels, constant pointers to the first element of the array.
The compiler does not know the address of the label, but it is able to access to the element at a given index by offsetting the memory location pointed by the label.

The intermediate representation of the \texttt{MOVA} instruction executes the following steps:

\begin{enumerate}
  \item load the address into a register
  \item add the offset of the desired element to the address
  \item use indirect addressing to read or write the element
\end{enumerate}

Furthermore \texttt{ACSE} provides two helper functions to handle array access, defined in \texttt{axe\_array.h}:

\begin{itemize}[label=\textbf{\texttt{>}}]
  \item \texttt{loadArrayElement()} to load an element from an array
  \item \texttt{storeArrayElement()} to store an element into an array
\end{itemize}

The code to handle array access is shown in Code~\ref{code:array-access-code-generation}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Array access code generation}, label={code:array-access-code-generation}]
/* ID is the variable identifier of the array
 * index is the expression that evaluates to the index of the element to access
 * data is the expression that evaluates to the value to store
 * Return the identifier of the register which will contain the value read from the array element
 */
int loadArrayElement(t_program_infos *program, char *ID, t_axe_expression index);
int storeArrayElement(t_program_infos *program, char *ID, t_axe_expression index, t_axe_expression data);
\end{lstlisting}
\end{onepage}

\paragraph{Arrays in expressions}

When an array appears in an expression:

\begin{enumerate}
  \item generate a \texttt{LOAD} to the array element into a new register
  \item the expression semantic value is that register identifiers
\end{enumerate}

The grammar rule for array access is shown in Code~\ref{code:array-access-grammar}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Array access grammar}, label={code:array-access-grammar}]
exp : /* ... */
    | IDENTIFIER LSQUARE exp RSQUARE
      {
        int reg;
        reg = loadArrayElement(program, $1, $3);
        $$ = create_axe_expression(reg, REG);
        free($1);
      }
    ;
\end{lstlisting}
\end{onepage}

\paragraph{Array assignment}

Value assignment to array is handled by the \texttt{storeArrayElement()} function;
the grammar rule for array assignment is shown in Code~\ref{code:array-assignment-grammar}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Array assignment grammar}, label={code:array-assignment-grammar}]
assign_statement : IDENTIFIER LSQUARE exp RSQUARE ASSIGN exp
                 {
                    storeArrayElement(program, $1, $3, $6);
                    free($1);
                 }
                 | /* ... */
                 ;
\end{lstlisting}
\end{onepage}

\paragraph{Checking variable properties}

Inside \texttt{ACSE}, both arrays and scalars are variables;
as such, it might need necessary to check the properties of a variable, such as its type or its size.
The function to retrieve this information is \texttt{getVariable()}, shown in Code~\ref{code:variable-properties};
the definition of the \texttt{t\_axe\_variable} structure is shown in Code~\ref{code:variable-structure}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Variable properties}, label={code:variable-properties}]
t_variable *getVariable (t_program_infos *program, char *ID);
\end{lstlisting}
\end{onepage}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Variable structure}, label={code:variable-structure}]
typedef struct t_axe_variable {
  int type;
  int isArray; // 1 if the variable is an array, 0 otherwise
  int arraySize, // the size of the array (if isArray == 1)
  int init_value // the initial value of the variable (if isArray == 0)
  char *ID; // the identifier of the variable
  t_axe_label *labelID; // the label of the variable
} t_axe_variable;
\end{lstlisting}
\end{onepage}

\paragraph{Checking if a variable is an array}

A common pattern is checking id a given identifier is associated to an array;
such implementation is shown in Code~\ref{code:is-array}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Checking if a variable is an array}, label={code:is-array}]
char *the_id;
t_axe_variable *v_ident = getVariable(program, the_id);
if (!v_ident->isArray) {
  // the variable is not an array
  yyerror("the variable is not an array");
  YYERROR;
}
\end{lstlisting}
\end{onepage}

\subsection{Control statements}

In intermediate language, control statements are represented by branches, via jump instructions.
Branch destinations are represented by labels, which are used to identify the target of a jump instruction.

There are two kinds of branches:

\begin{itemize}
  \item[\(\rightarrow\)] \textbf{Forward}, where the label is \textbf{after} the branch
  \item[\(\leftarrow\)] \textbf{Backward}, where the label is \textbf{before} the branch
\end{itemize}

Since \texttt{ACSE} is a syntactic directed translator, labels that appear after the branch must be also generated after the branch:
the labels must be allocated without being generated \textit{(they must be not added to the instruction list)}.

\texttt{ACSE} provides \(3\) primary functions to create labels:

\begin{itemize}[label=\textbf{\texttt{>}}]
  \item \texttt{newLabel()}, which creates a new label without inserting into the new instruction list
  \item \texttt{assignLabel()}, which assigns a label to a given instruction
  \item \texttt{assignNewLabel()}, which creates a new label and assigns it to a given instruction,
\end{itemize}

The signatures of these functions are shown in Code~\ref{code:label-functions};
the instructions to create labels are shown in the next Paragraphs.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Label functions}, label={code:label-functions}]
// create a new label
t_axe_label *newLabel(t_program_infos *program);
// assign a label to an instruction
void assignLabel(t_program_infos *program, t_axe_instruction *instruction, t_axe_label *label);
// create a new label and assign it to an instruction
t_axe_label *assignNewLabel(t_program_infos *program) {
  t_axe_label *label = newLabel(program);
  assignLabel(program, instruction, label);
  return label;
}
\end{lstlisting}
\end{onepage}

\paragraph*{Creating forward labels}

\begin{enumerate}
  \item Create the label with the instruction \texttt{newLabel()}
  \item Generate the branch passing the newly created label structure
  \item Insert the label in the program by using the instruction \texttt{assignLabel()} just before generating the destination instruction
\end{enumerate}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Creating forward labels}, label={code:forward-labels}]
t_axe_label *label = newLabel(program);
gen_bt_instruction(program, label, 0);

/* ... */

assignLabel(program, instruction, label);
\end{lstlisting}
\end{onepage}

\paragraph*{Creating backward labels}

\begin{enumerate}
  \item Create and insert the label in the program with the instruction \texttt{assignNewLabel()}
  \item Generate the branch instruction when needed
\end{enumerate}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Creating backward labels}, label={code:backward-labels}]
t_axe_label *label = assignNewLabel(program);
label = assignNewLabel(program);

/* ... */

gen_bt_instruction(program, label, 0);
\end{lstlisting}
\end{onepage}

\paragraph{\texttt{if} statement without \texttt{else}}

The grammar for the \texttt{if} statement without \texttt{else} is shown in Code~\ref{code:if-grammar}.
The expression iside the parenthesis is called \textbf{condition};
the code block is executed only if the condition is not equal to zero.

The instruction in the intermediate representation is a \texttt{BEQ} on the \texttt{Z} flag.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Grammar for the if statement}, label={code:if-grammar}]
if_statement : IF LPAR exp RPAR block;
\end{lstlisting}
\end{onepage}

Three semantic actions are needed:

\begin{enumerate}
  \item One for the code before the body
  \item One for the body
  \item One for assigning the label to the end of the body
\end{enumerate}

Parsing the \texttt{exp} nonterminal does not always results in code generation since the expression can be a variable or a constant.

The label must be shared between the first two actions; the code grammar for the \texttt{if} statement is shown in Code~\ref{code:if-code}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Code for the if statement}, label={code:if-code}]
%union {
  /* ... */
  t_axe_label *label;
  /* ... */
}
%token <label> IF
/* ... */
if_statement : IF LPAR exp RPAR { /* ... */ }
             | code_block { /* ... */ }
             ;
\end{lstlisting}
\end{onepage}

\paragraph*{Conditional jumps and constant expression}

When the conditional expression is of immediate type, the expression can be evaluated at compile time.
Since said expression is constant, it's possible to know in advance \textit{(at compile time)} if the branch will never \textit{(or always)} be taken: the \textbf{conditional} branch can be replaced by an \textbf{unconditional} one.

\paragraph{\texttt{if} statement with \texttt{else}}

Since the \texttt{else} statement is optional, a new nonterminal is needed to handle the case in which it is not present;
such grammar is shown in Code~\ref{code:if-else-grammar}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Grammar for the if statement with else}, label={code:if-else-grammar}]
if_statement : if_stmt
             | if_stmt ELSE code_block
             ;
if_stmt : IF LPAR exp RPAR code_block
        ;
\end{lstlisting}
\end{onepage}

\paragraph{\texttt{while} statement}

This statement repeats the contained code block until a given condition is not satisfied;
this is the simplest looping construct in the language.

Its grammar is shown in Code~\ref{code:while-grammar}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Grammar for the while statement}, label={code:while-grammar}]
while_statement : WHILE LPAR exp RPAR code_block;
\end{lstlisting}
\end{onepage}

A loop is implemented by via an unconditional backward branch at the end of the loop and a conditional one at the start.
Before each iteration, the condition is checked; if not satisfied, the execution of the program continues after the code block.

Due to this structure, it's necessary to share informations between the two semantic actions:

\begin{itemize}
  \item the label for breaking out of the loop at the end
  \item the label for continuing the loop at the start of the loop
\end{itemize}

The definition of the \texttt{while} statement, as implemented in \texttt{axe\_struct.h} is shown in Code~\ref{code:while-code}; the semantic actions are shown in Code~\ref{code:while-actions}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Code for the while statement}, label={code:while-code}]
typedef struct {
  t_axe_label *break_label;
  t_axe_label *continue_label;
  t_axe_code_block *code_block;
} t_axe_while_statement;
\end{lstlisting}
\end{onepage}

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Semantic actions for the while statement}, label={code:while-actions}]
%union {
  /* ... */
  t_axe_while_statement *while_statement;
  /* ... */
}
/* ... */
%token <while_statement> WHILE
/* ... */
  \end{lstlisting}
\end{onepage}

\paragraph{\texttt{do while} statement}

This statement is similar to the \texttt{while} statement, but the condition is checked after the execution of the code block.
It simplifies the control flow graph, since only one label is needed.

The branch instruction is implemented via a \texttt{BNE} instruction because it must be taken if the condition is not satisfied.
As such, the body is executed always at leat once.

The grammar is shown in Code~\ref{code:do-while-grammar}.

\begin{onepage}
  \begin{lstlisting}[language=LANCE, caption={Grammar for the do while statement}, label={code:do-while-grammar}]
do_while_statement : DO code_block WHILE LPAR exp RPAR;
\end{lstlisting}
\end{onepage}