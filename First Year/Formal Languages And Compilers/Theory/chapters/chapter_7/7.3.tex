\section{\textit{FLEX}}

\textit{flex} is a lexical analyser generator:
\begin{itemize}
  \item[\(\rightarrow\)] as \textbf{input} it takes a specification file of the scanner
  \item[\(\leftarrow\)] as \textbf{output} it generates a \clang source code file implementing the scanner
\end{itemize}
The workflow of \textit{flex} is the following:
\begin{enumerate}
  \item The \textbf{specification} file is \textbf{written}
  \item The \textbf{specification} file is \textbf{compiled} with \texttt{FLEX}
  \item The \textbf{generated} \clang source code file is \textbf{compiled} with \texttt{cc}
\end{enumerate}
\begin{figure}[htbp]
  \centering
  \bigskip
  \tikzfig{figure-18.tikz}
  \caption{Workflow of \textit{flex}}
  \label{fig:flex-workflow}
  \bigskip
\end{figure}
The generated parsers implement a nondeterministic \FSA, later made deterministic via the Berry-Sethi algorithm, which tries to match all possible tokens at the same time;
as soon as one is recognized:
\begin{enumerate}
  \item The \textbf{semantic action} is executed
  \item The \textbf{stream} skips past the end of the token
  \item The \textbf{automaton} reboots
\end{enumerate}

\subsection{Specification File}
A \textit{flex} file is structured in three sections, separated by the \texttt{\%\%} token:
\begin{itemize}
  \item the \textbf{definitions}: declare useful \re
  \item the \textbf{rules}: bind \re combinations to actions
  \item the \textbf{user code}: \clang code
\end{itemize}
\paragraph*{Definitions}
A definition associates a name with a set of characters;
\re can be used to define character sets, with quotes \textit{(symbol \texttt{"})} used for literal strings.
They are recalled by putting their names in curly braces \textit{(symbol \texttt{\{\}})}.
Definitions behave like \clang macros.

\paragraph*{Rules}
A rule represents a full token to be recognized:
\begin{itemize}
  \item the \textbf{token} is described by a \re
  \item it exploits definitions to be more readable
  \item it defines a \textbf{semantic action} to be made at each match
        \begin{itemize}
          \item semantic actions are executed \textbf{every time the rules matches} and can access the matched string
          \item global variables:
                \begin{itemize}[label=\textbf{\texttt{>}}]
                  \item \texttt{\textbf{char} *yytext} contains the \textbf{matched string}
                  \item \texttt{\textbf{int} yyleng} contains the \textbf{length of the matched string}
                \end{itemize}
        \end{itemize}
\end{itemize}
Simple applications put the business logic inside the semantic actions;
more complex applications that use a separate parser \textit{(for example compilers)} do the following:
\begin{enumerate}
  \item \textbf{assign} a \textbf{value} to the recognized token
  \item \textbf{return} the token \textbf{type}
\end{enumerate}

\paragraph*{User Code}
User \clang code is copied to the generated scanner \textbf{as is}.
Arbitrary code can be put inside definitions and rules sections by escaping from the \textit{flex} syntax within \texttt{\%\{} and \texttt{\%\}}.
This feature is usually used for header inclusions, global variables, and function definitions.

\subsection{Generated Scanner}
While \textit{flex} generates a scanner, \textbf{it is not a scanner itself};
the generated scanner is a \clang source code file called \texttt{lex.yy.c}, exporting the following variables and functions:
\begin{itemize}[label=\textbf{\texttt{>}}]
  \item \texttt{\textbf{FILE} *yyin}: the input file
        \begin{itemize}
          \item it can assume the value \texttt{stdin} to read from the standard input
        \end{itemize}
  \item \texttt{\textbf{int} yylex(\textbf{void})}
        \begin{itemize}
          \item it parses the input until:
                \begin{enumerate}
                  \item a semantic function returns; the return value is the same as the one in the action
                  \item the file ends; the return value is \texttt{0}
                \end{enumerate}
        \end{itemize}
  \item \texttt{\textbf{void} yyerror(\textbf{char} *msg)}
        \begin{itemize}
          \item prints an error message
        \end{itemize}
  \item \texttt{\textbf{int} yywrap(\textbf{void})}
        \begin{itemize}
          \item it is called when the end of the file is reached
          \item it allows opening a new file and continue scanning from there
          \item return values:
                \begin{itemize}
                  \item \texttt{0}: continue scanning
                  \item \texttt{1}: stop scanning
                \end{itemize}
          \item it can be disabled with the instruction \texttt{\%\%option noyywrap} in the specification file
        \end{itemize}
\end{itemize}

\paragraph*{Behaviour}
Important behaviours of the scanner:
\begin{itemize}
  \item \textbf{Longest matching rule} - if the scanner matches \textbf{more than one string}, the rules that generates the \textbf{longest} one is chosen
  \item \textbf{First rule} - if the scanner matches\textbf{ more than one string with the same length}, the \textbf{first} one is chosen
  \item \textbf{Default action} - if the scanner finds no rule, the next character in input is considered matched implicitly and printed to the standard output
\end{itemize}

\subsection{Multiple scanners}
In order to support multiple scanners, rules can be marked with the same name of the associated scanner \textit{(the start condition)};
special actions are used to switch between scanners.
A start condition \texttt{S} is used to mark rules with as a prefix like \texttt{<S>RULE};
it marks rules as active when the scanner is running the scanner \texttt{S}.
\begin{itemize}
  \item The \texttt{*} start condition matches \textbf{every} start condition
  \item The initial start condition is called \textbf{\texttt{INITIAL}}
  \item The start conditions are stored as \textbf{integers}
  \item The current start condition is stored in the variable \textbf{\texttt{YY\_START}}
\end{itemize}
Start conditions can be:
\begin{itemize}[label=\textbf{\texttt{>}}]
  \item \textbf{exclusive} - declared as \texttt{\%x S;}
        \begin{itemize}
          \item \textbf{disables unmarked rules} when the scanner is in the start condition \texttt{S}
        \end{itemize}
  \item \textbf{inclusive} - declared as \texttt{\%s S;}
        \begin{itemize}
          \item \textbf{enables unmarked rules} when the scanner is in the start condition \texttt{S}
          \item the \texttt{INITIAL} condition is inclusive
        \end{itemize}
\end{itemize}

Command \texttt{BEGIN(S)} switches to the start condition \texttt{S};
command \texttt{ECHO} copies the content of the matched string \texttt{yytext} to the standard output.