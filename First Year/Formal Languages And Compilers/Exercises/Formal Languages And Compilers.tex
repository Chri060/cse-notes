\documentclass[12pt, a4paper]{report}
\usepackage{graphicx, array, amsthm, amssymb, amsmath, algorithm, algpseudocode, float, xcolor, thmtools, thmbox, exercise}
\usepackage[english]{babel}

\makeatletter
\renewcommand\thmbox@headstyle[2]{\bfseries #1}
\makeatother
\newtheorem[style=M,bodystyle=\normalfont]{theorem}{Theorem}
\newtheorem[style=M,bodystyle=\normalfont]{corollary}{Corollary}
\newtheorem[style=M,bodystyle=\normalfont]{lemma}{Lemma}
\newtheorem[style=M,bodystyle=\normalfont]{definition}{Definition}


\title{Formal Languages And Compilers \\ \textit{Exercises}}
\author{Christian Rossi}
\date{Academic Year 2023-2024}

\begin{document}

\maketitle

\newpage

\begin{abstract}
    The lectures are about those topics: 
    \begin{itemize}
        \item Definition of language, theory of formal languages, language operations, regular expressions, regular languages, finite deterministic and non-deterministic automata, 
            BMC and Berry-Sethi algorithms, properties of the families of regular languages, nested lists and regular languages.
        \item Context-free grammars, context-free languages, syntax trees, grammar ambiguity, grammars of regular languages, properties of the families of context-free languages, 
            main syntactic structures and limitations of the context-free languages.
        \item Analysis and recognition (parsing) of phrases, parsing algorithms and automata, push down automata, deterministic languages, bottom-up and recursive top-down syntactic 
            analysis, complexity of recognition.
        \item Syntax-driven translation, direct and inverse translation, syntactic translation schemata, transducer automata, and syntactic analysis and translation. Definition of 
            semantics and semantic properties. Static flow analysis of programs. Semantic translation driven by syntax, semantic functions and attribute grammars, one-pass and 
            multiple-pass computation of the attributes.
    \end{itemize}
    The laboratory sessions are about those topics: 
    \begin{itemize}
        \item Modellization of the lexicon and the syntax of a simple programming language (C-like).
        \item Design of a compiler for translation into an intermediate executable machine language (for a register-based processor).
        \item Use of the automated programming tools Flex and Bison for the construction of syntax-driven lexical and syntactic analyzers and translators.
    \end{itemize}
\end{abstract}

\newpage

\tableofcontents

\newpage

\chapter{Exercise session I}

    \section{Regular expression's equality}
        Given two regular expression: 
        \[R_1=((2b)^{*}c)^* \:\:\:\:\:\:\:\:\:\:\:\: R_2=(c^*(2b)^{*})^*\]
        Check if they are equal. If they are not give a counterexample. 
    \subsection*{Solution}
        It is possible to see that $R_1$ and $R_2$ are not equivalent because the character $c$ is in a different position and can be found multiple times in $R_2$, while in $R_1$ is 
        found exactly one time. An example can be $ab$. This string is included in the second language, but not in the first one. 

    \newpage 

    \section{Regular expression's ambiguity}
        Given the regular expression: 
        \[R_1=(a|\varepsilon)^{+}(ba|bab)^{*}\]
        check if it is ambiguous. 
    \subsection*{Solution}
        First, we enumerate all the characters in the regular expression, obtaining: 
        \[R_1=(a_1|\varepsilon)^{+}(b_2a_3|b_4a_5b_6)^{*}\]
        and now we try to come up with an ambiguous string to prove that the regular expression is ambiguous. 
        A regular expression is considered ambiguous if there is a string which can be matched by more than one way from the regular expression. 
        For instance, we can have the string $a_1$ can be generated multiple times selecting the $\varepsilon \: n - 1$ times. This proves that the regular expression is ambiguous. 

    \newpage

    \section{Operations on languages}
        Given two regular expressions: 
        \[R_1=a((b|bb)a)^{+} \:\:\:\:\:\:\:\:\:\:\:\: R_2=(ab)^{*}ba\]
        Define the quotient language $L=R_1-R_2$. 
        \begin{enumerate}
            \item Write the three shortest strings of the language $L$.
            \item Write a regular expression that defines the language. 
        \end{enumerate}
    \subsection*{Solution}
        First, we enumerate all the characters in the regular expressions, obtaining: 
        \[R_1=a_1((b_2|b_3b_4)a_5)^{+}\]
        \[R_2=(a_1b_2)^{*}b_3a_4\]
        The $a_1$ is surely a prefix for every string in the language, and all the strings have $a_5$ as a suffix. The shortest strings of this language are: $aba$, $ababa$ and $abababa$. 
        
        For the second regular expression we have that every string generated starts with $ab$ and have a single $ba$ as a suffix. The shortest strings of this language are: $ba$, $abba$ and $abababa$. 
        
        We can see that all the strings that have the suffix $aba$ or have at least two $bb$ are certainly in $L$. 

        \begin{enumerate}
            \item Now, we can see that the three shortest strings are: $aba$, $ababa$, and $abbaba$. 
            \item The regular expression is: 
                \[L=\{(a(b|bb))^{*}aba\} \cup \{(a(b|bb))^{*}abba(a(b|bb))^{+}abba\}\]
        \end{enumerate}    
\end{document}