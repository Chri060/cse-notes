\section{Two-phase locking}

The previously presented locking mechanism does not eliminate anomalies caused by non-repeatable reads. 
To address this issue, a two-phase rule can be employed, requiring that a transaction cannot acquire any other lock after releasing one. 
This approach involves three phases: acquiring all locks, executing operations, and finally, unlocking.
\begin{definition}
    The class of \emph{two-phase locking} is the set of all schedules generated by a scheduler that: 
    \begin{itemize}
        \item Only processes well-formed transactions. 
        \item Grant locks according to the conflict table. 
        \item Checks that all transactions apply the two-phase rule.             
    \end{itemize}
\end{definition}
We have that 2PL is a strict subset of CSR and also that 2PL implies CSR. 
\begin{proof}[2PL implies CSR]
    We assume that a schedule $S$ is 2PL. Consider, for each transaction, the moment in which it holds all locks and is going to release the first one. 
    We sort the transactions by this temporal value and consider the corresponding serial schedule $S^{'}$. 
    We want to prove by contradiction that $S$ is conflict-equivalent to $S^{'}$: 
    \[S^{'}\approx_CS,\dots\]
    Consider a generic conflict $o_i \rightarrow o_j$ in $S^{'}$ with $o_i \in T_i$, $0_j \in T_j$, and $i<j$. 
    By definition of conflict, $o_i$ and $o_j$ address the same resource $r$, and at least one of them is write. 
    The two operations cannot occur in reverse order of $S$. 
    This proves that all 2PL schedules are view-serializable. 
\end{proof}
In this state, the remaining anomalies are limited to phantom inserts (requiring predicate locks) and dirty reads.