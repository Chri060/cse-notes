\section{Two-phase locking}

With the locking showed before we do not eliminate the anomalies caused by non-repeatable reads. To avoid this problem we can use a two-phase rule which requires that a 
transaction cannot acquire any other lock after releasing one. So, we have a phase where the transaction acquires all the locks, a phase where it executes all operations and 
a final phase of unlocking. 
\begin{definition}
    The class of \emph{two-phase locking} is the set of all schedules generated by a scheduler that: 
    \begin{itemize}
        \item Only processes well-formed transactions. 
        \item Grant locks according to the conflict table. 
        \item Checks that all transactions apply the two-phase rule.             
    \end{itemize}
\end{definition}
We have that $2PL$ is a strict subset of $CSR$ and also that $2PL$ implies $CSR$. 
\begin{proof}[2PL implies CSR]
    We assume that a schedule $S$ is $2PL$. Consider, for each transaction, the moment in which it holds all locks and is going to release the first one. 
    We sort the transactions by this temporal value and consider the corresponding serial schedule $S^{'}$. We want to prove by contradiction that $S$ is conflict-equivalent to 
    $S^{'}$: 
    \[S^{'}\approx_CS,\dots\]
    Consider a generic conflict $o_i \rightarrow o_j$ in $S^{'}$ with $o_i \in T_i$, $0_j \in T_j$, and $i<j$. 
    By definition of conflict, $o_i$ and $o_j$ address the same resource $r$, and at least one of them is write. The two operations cannot occur in reverse order of $S$. 
    This proves that all $2PL$ schedules are view-serializable. 
\end{proof}
The anomalies that remain in this state are only the phantom inserts (needs predicate locks) and the dirty reads. 