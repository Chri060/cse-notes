\section{Locking}

The prevalent method in commercial systems is the use of locking. 
A transaction is considered well-formed concerning locking if:
\begin{itemize}
    \item Read operations are preceded by r\_lock (shared) and followed by unlock. 
    \item Write operations are preceded by w\_lock (exclusive) and followed by unlock. 
\end{itemize}
In both cases, unlocking can be delayed with respect to the completion of the operations. 
Consequently, every object can be in one of three states: free, r\_locked, or w\_locked.

Transactions that first read and then write an object may acquire a w\_lock already when reading or acquire a r\_lock first and then upgrade it into a w\_lock (escalation).

The lock manager receives requests from transactions and allocates resources based on the conflict table:
\begin{table}[H]
    \centering
    \begin{tabular}{cccc}
    \textbf{}                              & \multicolumn{3}{c}{\textbf{Resource status}}                                                                                                                                                                                                   \\ \cline{2-4} 
    \multicolumn{1}{c|}{\textbf{Request}}  & \multicolumn{1}{c|}{\textit{FREE}}                                          & \multicolumn{1}{c|}{\textit{R\_LOCKED}}                                            & \multicolumn{1}{c|}{\textit{W\_LOCKED}}                                     \\ \hline
    \multicolumn{1}{|c|}{\textit{r\_lock}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\checkmark\\ R\_LOCKED\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\checkmark\\ R\_LOCKED($n++$)\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\tikzxmark\\ W\_LOCKED\end{tabular}} \\ \hline
    \multicolumn{1}{|c|}{\textit{w\_lock}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\checkmark\\ W\_LOCKED\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\tikzxmark\\ R\_LOCKED\end{tabular}}        & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\tikzxmark\\ W\_LOCKED\end{tabular}} \\ \hline
    \multicolumn{1}{|c|}{\textit{unlock}}  & \multicolumn{1}{c|}{ERROR}                                                  & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\checkmark\\ $n--$\end{tabular}}            & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\checkmark\\ FREE\end{tabular}}      \\ \hline
    \end{tabular}
\end{table}

\begin{example}
    Consider a schedule with three transactions and the following operations:
    \[r_1(x)w_1(x)r_2(x)r_3(y)w_1(y)\]
    The resulting locks are as follows:
    \begin{itemize}
        \item $r_1(x)$: $r_1\_lock(x)$ request $\rightarrow$ Ok $\rightarrow$ $x$ is $r\_locked$ with $n_x=1$. 
        \item $w_1(x)$: $w_1\_lock(x)$ request $\rightarrow$ Ok $\rightarrow$ $x$ is $w\_locked$. 
        \item $r_2(x)$: $r_1\_lock(x)$ request $\rightarrow$ No, because $x$ is $w\_locked$ $\rightarrow$ $T_2$ waits. 
        \item $r_3(y)$: $r_3\_lock(y)$ request $\rightarrow$ Ok $\rightarrow$ $y$ is $r\_locked$ with $n_y=1$ and then $T_3$ unlocks $y$. 
        \item $w_1(y)$: $w_1\_lock(y)$ request $\rightarrow$ Ok $\rightarrow$ $y$ is $w\_locked$ and then $x$ and $y$ are freed. 
    \end{itemize}
    The resulting a posteriori schedule becomes:
    \[r_1(x)w_1(x)r_3(y)w_1(y)r_2(x)\]
    Here, transaction two is delayed. 
\end{example}
The locking system is implemented via lock tables, which are hash tables indexing lockable items via hashing. 
Each locked item has an associated linked list, with each node representing the transaction that requested the lock, the lock mode, and the current status. 
Each new lock request for the data item is appended to the list.