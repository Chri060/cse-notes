\section{Query evaluation}

A table
PUBLICATIONS (\underline{PubCode}, ISBN, Title, Date, $\dots$)
has ISBN as candidate key (unique, not null) and stores one million tuples.
It is a hash-based structure, built on the primary key (PubCode), with:
\begin{itemize}
    \item 10 tuples per block. 
    \item An average filling factor of 80\%. 
    \item An average lookup cost of 1.11 I/O operations. 
\end{itemize}
\begin{enumerate}
    \item Ignoring the possible effects of caching, and only taking account of disk I/O operations, estimate the execution cost of the query:
        \begin{lstlisting}[style=SQL]
SELECT *
FROM PUBLICATIONS
WHERE ISBN = '001122345' AND (PubCode = 'ABC123' OR PubCode = 'DEF456')
        \end{lstlisting}
    \item Assume that a secondary access structure is also available, in the form of a B+ tree index with ISBN as search key, with an average fan-out of 100.
        Still ignoring the impact of caching mechanisms, estimate the cost of execution through the secondary structure and compare the result with the previous one.
        \begin{lstlisting}[style=SQL]
SELECT * 
FROM PUBLICATIONS
WHERE ISBN = '001122345' AND (PubCode = 'ABC123' OR PubCode = 'DEF456')
        \end{lstlisting}
\end{enumerate}

\paragraph*{Solution}
\begin{enumerate}
    \item At the out most level of the where clause there is a conjunction of predicates.
        We have: 
        \begin{itemize}
            \item One access structure that supports indexed access based on one predicate (PubCode). 
            \item No support for the other predicate (ISBN). 
        \end{itemize}
        So only the second conjunct can be used to retrieve the relevant tuple.
        Being in turn a disjunction, the second conjunct requires two accesses to the structure to be fully evaluated, at the (average) cost of: 
        \[1.11 \cdot 2 = 2.22 \textnormal{ I/O operations}\]
    \item Even if (optimistic assumption) the B+ tree is full and well-balanced, its depth cannot be less than 3, because $\log_{100}10^6=3$. 
        Thus, each access to the index requires a minimum of 3 I/O operations just to reach a leaf node with the pointer to the primary storage (and one access to actually retrieve the tuple). 
        We conclude that the most convenient approach is still the previous strategy.
\end{enumerate}